<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Alloy Render Engine</title>
</head>
<body>   
  
    <div style="text-align:center;"><canvas width="640" id="ourCanvas" height="480" style="border:1px solid #ccc;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"> </canvas>    <canvas id="canvas" width="640" height="480"  style="border:1px solid #ccc;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></canvas>
	 <div style="text-align:center;">
   try to press【left】【right】【up】【down】【left+right】【up+right】【up+down】【left+down】

 </div>
         <div style="text-align:center;">
     <select id="rdSlt">
         <option value="0">WebGL渲染</option>
         <option value="1">Canvas渲染</option>
     </select>

 </div>
    </div>
    <script>
        var rdSlt = document.getElementById("rdSlt"), webglSupport = function () { try { var n = document.createElement("canvas"); return !!(window.WebGLRenderingContext && (n.getContext("webgl") || n.getContext("experimental-webgl"))) } catch (t) { return !1 } }(), Box2D, Vector, Vector_a2j_Number, i; for (webglSupport || (rdSlt.selectedIndex = 1), localStorage.webgl && (rdSlt.selectedIndex = localStorage.webgl == "0" ? 0 : 1), rdSlt.onchange = function () { var n = rdSlt.selectedIndex, t = rdSlt.options[n].value; localStorage.webgl = t; location.reload() }, Box2D = {}, function (n, t) { function i() { } !(Object.prototype.defineProperty instanceof Function) && Object.prototype.__defineGetter__ instanceof Function && Object.prototype.__defineSetter__ instanceof Function && (Object.defineProperty = function (n, t, i) { i.get instanceof Function && n.__defineGetter__(t, i.get); i.set instanceof Function && n.__defineSetter__(t, i.set) }); n.inherit = function (n, t) { i.prototype = t.prototype; n.prototype = new i; n.prototype.constructor = n }; n.generateCallback = function (n, t) { return function () { t.apply(n, arguments) } }; n.NVector = function (n) { n === t && (n = 0); for (var r = Array(n || 0), i = 0; i < n; ++i) r[i] = 0; return r }; n.is = function (n, i) { return n === null ? !1 : i instanceof Function && n instanceof i ? !0 : n.constructor.__implements != t && n.constructor.__implements[i] ? !0 : !1 }; n.parseUInt = function (n) { return Math.abs(parseInt(n)) } }(Box2D), Vector = Array, Vector_a2j_Number = Box2D.NVector, typeof Box2D == "undefined" && (Box2D = {}), typeof Box2D.Collision == "undefined" && (Box2D.Collision = {}), typeof Box2D.Collision.Shapes == "undefined" && (Box2D.Collision.Shapes = {}), typeof Box2D.Common == "undefined" && (Box2D.Common = {}), typeof Box2D.Common.Math == "undefined" && (Box2D.Common.Math = {}), typeof Box2D.Dynamics == "undefined" && (Box2D.Dynamics = {}), typeof Box2D.Dynamics.Contacts == "undefined" && (Box2D.Dynamics.Contacts = {}), typeof Box2D.Dynamics.Controllers == "undefined" && (Box2D.Dynamics.Controllers = {}), typeof Box2D.Dynamics.Joints == "undefined" && (Box2D.Dynamics.Joints = {}), function () { function li() { li.b2AABB.apply(this, arguments) } function ai() { ai.b2Bound.apply(this, arguments) } function n() { n.b2BoundValues.apply(this, arguments); this.constructor === n && this.b2BoundValues.apply(this, arguments) } function vi() { vi.b2Collision.apply(this, arguments) } function t() { t.b2ContactID.apply(this, arguments); this.constructor === t && this.b2ContactID.apply(this, arguments) } function yi() { yi.b2ContactPoint.apply(this, arguments) } function pi() { pi.b2Distance.apply(this, arguments) } function wi() { wi.b2DistanceInput.apply(this, arguments) } function bi() { bi.b2DistanceOutput.apply(this, arguments) } function ki() { ki.b2DistanceProxy.apply(this, arguments) } function i() { i.b2DynamicTree.apply(this, arguments); this.constructor === i && this.b2DynamicTree.apply(this, arguments) } function di() { di.b2DynamicTreeBroadPhase.apply(this, arguments) } function gi() { gi.b2DynamicTreeNode.apply(this, arguments) } function nr() { nr.b2DynamicTreePair.apply(this, arguments) } function r() { r.b2Manifold.apply(this, arguments); this.constructor === r && this.b2Manifold.apply(this, arguments) } function u() { u.b2ManifoldPoint.apply(this, arguments); this.constructor === u && this.b2ManifoldPoint.apply(this, arguments) } function tr() { tr.b2Point.apply(this, arguments) } function f() { f.b2RayCastInput.apply(this, arguments); this.constructor === f && this.b2RayCastInput.apply(this, arguments) } function ir() { ir.b2RayCastOutput.apply(this, arguments) } function rr() { rr.b2Segment.apply(this, arguments) } function ur() { ur.b2SeparationFunction.apply(this, arguments) } function e() { e.b2Simplex.apply(this, arguments); this.constructor === e && this.b2Simplex.apply(this, arguments) } function fr() { fr.b2SimplexCache.apply(this, arguments) } function er() { er.b2SimplexVertex.apply(this, arguments) } function or() { or.b2TimeOfImpact.apply(this, arguments) } function sr() { sr.b2TOIInput.apply(this, arguments) } function o() { o.b2WorldManifold.apply(this, arguments); this.constructor === o && this.b2WorldManifold.apply(this, arguments) } function hr() { hr.ClipVertex.apply(this, arguments) } function cr() { cr.Features.apply(this, arguments) } function s() { s.b2CircleShape.apply(this, arguments); this.constructor === s && this.b2CircleShape.apply(this, arguments) } function h() { h.b2EdgeChainDef.apply(this, arguments); this.constructor === h && this.b2EdgeChainDef.apply(this, arguments) } function c() { c.b2EdgeShape.apply(this, arguments); this.constructor === c && this.b2EdgeShape.apply(this, arguments) } function lr() { lr.b2MassData.apply(this, arguments) } function l() { l.b2PolygonShape.apply(this, arguments); this.constructor === l && this.b2PolygonShape.apply(this, arguments) } function a() { a.b2Shape.apply(this, arguments); this.constructor === a && this.b2Shape.apply(this, arguments) } function v() { v.b2Color.apply(this, arguments); this.constructor === v && this.b2Color.apply(this, arguments) } function ar() { ar.b2Settings.apply(this, arguments) } function y() { y.b2Mat22.apply(this, arguments); this.constructor === y && this.b2Mat22.apply(this, arguments) } function p() { p.b2Mat33.apply(this, arguments); this.constructor === p && this.b2Mat33.apply(this, arguments) } function vr() { vr.b2Math.apply(this, arguments) } function yr() { yr.b2Sweep.apply(this, arguments) } function w() { w.b2Transform.apply(this, arguments); this.constructor === w && this.b2Transform.apply(this, arguments) } function b() { b.b2Vec2.apply(this, arguments); this.constructor === b && this.b2Vec2.apply(this, arguments) } function k() { k.b2Vec3.apply(this, arguments); this.constructor === k && this.b2Vec3.apply(this, arguments) } function d() { d.b2Body.apply(this, arguments); this.constructor === d && this.b2Body.apply(this, arguments) } function g() { g.b2BodyDef.apply(this, arguments); this.constructor === g && this.b2BodyDef.apply(this, arguments) } function pr() { pr.b2ContactFilter.apply(this, arguments) } function wr() { wr.b2ContactImpulse.apply(this, arguments) } function br() { br.b2ContactListener.apply(this, arguments) } function nt() { nt.b2ContactManager.apply(this, arguments); this.constructor === nt && this.b2ContactManager.apply(this, arguments) } function tt() { tt.b2DebugDraw.apply(this, arguments); this.constructor === tt && this.b2DebugDraw.apply(this, arguments) } function kr() { kr.b2DestructionListener.apply(this, arguments) } function dr() { dr.b2FilterData.apply(this, arguments) } function it() { it.b2Fixture.apply(this, arguments); this.constructor === it && this.b2Fixture.apply(this, arguments) } function rt() { rt.b2FixtureDef.apply(this, arguments); this.constructor === rt && this.b2FixtureDef.apply(this, arguments) } function ut() { ut.b2Island.apply(this, arguments); this.constructor === ut && this.b2Island.apply(this, arguments) } function gr() { gr.b2TimeStep.apply(this, arguments) } function ft() { ft.b2World.apply(this, arguments); this.constructor === ft && this.b2World.apply(this, arguments) } function nu() { nu.b2CircleContact.apply(this, arguments) } function et() { et.b2Contact.apply(this, arguments); this.constructor === et && this.b2Contact.apply(this, arguments) } function ot() { ot.b2ContactConstraint.apply(this, arguments); this.constructor === ot && this.b2ContactConstraint.apply(this, arguments) } function tu() { tu.b2ContactConstraintPoint.apply(this, arguments) } function iu() { iu.b2ContactEdge.apply(this, arguments) } function st() { st.b2ContactFactory.apply(this, arguments); this.constructor === st && this.b2ContactFactory.apply(this, arguments) } function ru() { ru.b2ContactRegister.apply(this, arguments) } function uu() { uu.b2ContactResult.apply(this, arguments) } function ht() { ht.b2ContactSolver.apply(this, arguments); this.constructor === ht && this.b2ContactSolver.apply(this, arguments) } function fu() { fu.b2EdgeAndCircleContact.apply(this, arguments) } function ct() { ct.b2NullContact.apply(this, arguments); this.constructor === ct && this.b2NullContact.apply(this, arguments) } function eu() { eu.b2PolyAndCircleContact.apply(this, arguments) } function ou() { ou.b2PolyAndEdgeContact.apply(this, arguments) } function su() { su.b2PolygonContact.apply(this, arguments) } function lt() { lt.b2PositionSolverManifold.apply(this, arguments); this.constructor === lt && this.b2PositionSolverManifold.apply(this, arguments) } function hu() { hu.b2BuoyancyController.apply(this, arguments) } function cu() { cu.b2ConstantAccelController.apply(this, arguments) } function lu() { lu.b2ConstantForceController.apply(this, arguments) } function au() { au.b2Controller.apply(this, arguments) } function vu() { vu.b2ControllerEdge.apply(this, arguments) } function yu() { yu.b2GravityController.apply(this, arguments) } function pu() { pu.b2TensorDampingController.apply(this, arguments) } function at() { at.b2DistanceJoint.apply(this, arguments); this.constructor === at && this.b2DistanceJoint.apply(this, arguments) } function vt() { vt.b2DistanceJointDef.apply(this, arguments); this.constructor === vt && this.b2DistanceJointDef.apply(this, arguments) } function yt() { yt.b2FrictionJoint.apply(this, arguments); this.constructor === yt && this.b2FrictionJoint.apply(this, arguments) } function pt() { pt.b2FrictionJointDef.apply(this, arguments); this.constructor === pt && this.b2FrictionJointDef.apply(this, arguments) } function wt() { wt.b2GearJoint.apply(this, arguments); this.constructor === wt && this.b2GearJoint.apply(this, arguments) } function bt() { bt.b2GearJointDef.apply(this, arguments); this.constructor === bt && this.b2GearJointDef.apply(this, arguments) } function wu() { wu.b2Jacobian.apply(this, arguments) } function kt() { kt.b2Joint.apply(this, arguments); this.constructor === kt && this.b2Joint.apply(this, arguments) } function dt() { dt.b2JointDef.apply(this, arguments); this.constructor === dt && this.b2JointDef.apply(this, arguments) } function bu() { bu.b2JointEdge.apply(this, arguments) } function gt() { gt.b2LineJoint.apply(this, arguments); this.constructor === gt && this.b2LineJoint.apply(this, arguments) } function ni() { ni.b2LineJointDef.apply(this, arguments); this.constructor === ni && this.b2LineJointDef.apply(this, arguments) } function ti() { ti.b2MouseJoint.apply(this, arguments); this.constructor === ti && this.b2MouseJoint.apply(this, arguments) } function ii() { ii.b2MouseJointDef.apply(this, arguments); this.constructor === ii && this.b2MouseJointDef.apply(this, arguments) } function ri() { ri.b2PrismaticJoint.apply(this, arguments); this.constructor === ri && this.b2PrismaticJoint.apply(this, arguments) } function ui() { ui.b2PrismaticJointDef.apply(this, arguments); this.constructor === ui && this.b2PrismaticJointDef.apply(this, arguments) } function fi() { fi.b2PulleyJoint.apply(this, arguments); this.constructor === fi && this.b2PulleyJoint.apply(this, arguments) } function ei() { ei.b2PulleyJointDef.apply(this, arguments); this.constructor === ei && this.b2PulleyJointDef.apply(this, arguments) } function oi() { oi.b2RevoluteJoint.apply(this, arguments); this.constructor === oi && this.b2RevoluteJoint.apply(this, arguments) } function si() { si.b2RevoluteJointDef.apply(this, arguments); this.constructor === si && this.b2RevoluteJointDef.apply(this, arguments) } function hi() { hi.b2WeldJoint.apply(this, arguments); this.constructor === hi && this.b2WeldJoint.apply(this, arguments) } function ci() { ci.b2WeldJointDef.apply(this, arguments); this.constructor === ci && this.b2WeldJointDef.apply(this, arguments) } Box2D.Collision.IBroadPhase = "Box2D.Collision.IBroadPhase"; Box2D.Collision.b2AABB = li; Box2D.Collision.b2Bound = ai; Box2D.Collision.b2BoundValues = n; Box2D.Collision.b2Collision = vi; Box2D.Collision.b2ContactID = t; Box2D.Collision.b2ContactPoint = yi; Box2D.Collision.b2Distance = pi; Box2D.Collision.b2DistanceInput = wi; Box2D.Collision.b2DistanceOutput = bi; Box2D.Collision.b2DistanceProxy = ki; Box2D.Collision.b2DynamicTree = i; Box2D.Collision.b2DynamicTreeBroadPhase = di; Box2D.Collision.b2DynamicTreeNode = gi; Box2D.Collision.b2DynamicTreePair = nr; Box2D.Collision.b2Manifold = r; Box2D.Collision.b2ManifoldPoint = u; Box2D.Collision.b2Point = tr; Box2D.Collision.b2RayCastInput = f; Box2D.Collision.b2RayCastOutput = ir; Box2D.Collision.b2Segment = rr; Box2D.Collision.b2SeparationFunction = ur; Box2D.Collision.b2Simplex = e; Box2D.Collision.b2SimplexCache = fr; Box2D.Collision.b2SimplexVertex = er; Box2D.Collision.b2TimeOfImpact = or; Box2D.Collision.b2TOIInput = sr; Box2D.Collision.b2WorldManifold = o; Box2D.Collision.ClipVertex = hr; Box2D.Collision.Features = cr; Box2D.Collision.Shapes.b2CircleShape = s; Box2D.Collision.Shapes.b2EdgeChainDef = h; Box2D.Collision.Shapes.b2EdgeShape = c; Box2D.Collision.Shapes.b2MassData = lr; Box2D.Collision.Shapes.b2PolygonShape = l; Box2D.Collision.Shapes.b2Shape = a; Box2D.Common.b2internal = "Box2D.Common.b2internal"; Box2D.Common.b2Color = v; Box2D.Common.b2Settings = ar; Box2D.Common.Math.b2Mat22 = y; Box2D.Common.Math.b2Mat33 = p; Box2D.Common.Math.b2Math = vr; Box2D.Common.Math.b2Sweep = yr; Box2D.Common.Math.b2Transform = w; Box2D.Common.Math.b2Vec2 = b; Box2D.Common.Math.b2Vec3 = k; Box2D.Dynamics.b2Body = d; Box2D.Dynamics.b2BodyDef = g; Box2D.Dynamics.b2ContactFilter = pr; Box2D.Dynamics.b2ContactImpulse = wr; Box2D.Dynamics.b2ContactListener = br; Box2D.Dynamics.b2ContactManager = nt; Box2D.Dynamics.b2DebugDraw = tt; Box2D.Dynamics.b2DestructionListener = kr; Box2D.Dynamics.b2FilterData = dr; Box2D.Dynamics.b2Fixture = it; Box2D.Dynamics.b2FixtureDef = rt; Box2D.Dynamics.b2Island = ut; Box2D.Dynamics.b2TimeStep = gr; Box2D.Dynamics.b2World = ft; Box2D.Dynamics.Contacts.b2CircleContact = nu; Box2D.Dynamics.Contacts.b2Contact = et; Box2D.Dynamics.Contacts.b2ContactConstraint = ot; Box2D.Dynamics.Contacts.b2ContactConstraintPoint = tu; Box2D.Dynamics.Contacts.b2ContactEdge = iu; Box2D.Dynamics.Contacts.b2ContactFactory = st; Box2D.Dynamics.Contacts.b2ContactRegister = ru; Box2D.Dynamics.Contacts.b2ContactResult = uu; Box2D.Dynamics.Contacts.b2ContactSolver = ht; Box2D.Dynamics.Contacts.b2EdgeAndCircleContact = fu; Box2D.Dynamics.Contacts.b2NullContact = ct; Box2D.Dynamics.Contacts.b2PolyAndCircleContact = eu; Box2D.Dynamics.Contacts.b2PolyAndEdgeContact = ou; Box2D.Dynamics.Contacts.b2PolygonContact = su; Box2D.Dynamics.Contacts.b2PositionSolverManifold = lt; Box2D.Dynamics.Controllers.b2BuoyancyController = hu; Box2D.Dynamics.Controllers.b2ConstantAccelController = cu; Box2D.Dynamics.Controllers.b2ConstantForceController = lu; Box2D.Dynamics.Controllers.b2Controller = au; Box2D.Dynamics.Controllers.b2ControllerEdge = vu; Box2D.Dynamics.Controllers.b2GravityController = yu; Box2D.Dynamics.Controllers.b2TensorDampingController = pu; Box2D.Dynamics.Joints.b2DistanceJoint = at; Box2D.Dynamics.Joints.b2DistanceJointDef = vt; Box2D.Dynamics.Joints.b2FrictionJoint = yt; Box2D.Dynamics.Joints.b2FrictionJointDef = pt; Box2D.Dynamics.Joints.b2GearJoint = wt; Box2D.Dynamics.Joints.b2GearJointDef = bt; Box2D.Dynamics.Joints.b2Jacobian = wu; Box2D.Dynamics.Joints.b2Joint = kt; Box2D.Dynamics.Joints.b2JointDef = dt; Box2D.Dynamics.Joints.b2JointEdge = bu; Box2D.Dynamics.Joints.b2LineJoint = gt; Box2D.Dynamics.Joints.b2LineJointDef = ni; Box2D.Dynamics.Joints.b2MouseJoint = ti; Box2D.Dynamics.Joints.b2MouseJointDef = ii; Box2D.Dynamics.Joints.b2PrismaticJoint = ri; Box2D.Dynamics.Joints.b2PrismaticJointDef = ui; Box2D.Dynamics.Joints.b2PulleyJoint = fi; Box2D.Dynamics.Joints.b2PulleyJointDef = ei; Box2D.Dynamics.Joints.b2RevoluteJoint = oi; Box2D.Dynamics.Joints.b2RevoluteJointDef = si; Box2D.Dynamics.Joints.b2WeldJoint = hi; Box2D.Dynamics.Joints.b2WeldJointDef = ci }(), Box2D.postDefs = [], function () { var lt = Box2D.Collision.Shapes.b2CircleShape, at = Box2D.Collision.Shapes.b2PolygonShape, rt = Box2D.Collision.Shapes.b2Shape, u = Box2D.Common.b2Settings, n = Box2D.Common.Math.b2Math, ut = Box2D.Common.Math.b2Sweep, ft = Box2D.Common.Math.b2Transform, i = Box2D.Common.Math.b2Vec2, s = Box2D.Collision.b2AABB, k = Box2D.Collision.b2Bound, et = Box2D.Collision.b2BoundValues, r = Box2D.Collision.b2Collision, l = Box2D.Collision.b2ContactID, vt = Box2D.Collision.b2ContactPoint, a = Box2D.Collision.b2Distance, ot = Box2D.Collision.b2DistanceInput, st = Box2D.Collision.b2DistanceOutput, y = Box2D.Collision.b2DistanceProxy, o = Box2D.Collision.b2DynamicTree, f = Box2D.Collision.b2DynamicTreeBroadPhase, g = Box2D.Collision.b2DynamicTreeNode, ht = Box2D.Collision.b2DynamicTreePair, e = Box2D.Collision.b2Manifold, p = Box2D.Collision.b2ManifoldPoint, nt = Box2D.Collision.b2Point, tt = Box2D.Collision.b2RayCastInput, yt = Box2D.Collision.b2RayCastOutput, w = Box2D.Collision.b2Segment, h = Box2D.Collision.b2SeparationFunction, c = Box2D.Collision.b2Simplex, ct = Box2D.Collision.b2SimplexCache, b = Box2D.Collision.b2SimplexVertex, t = Box2D.Collision.b2TimeOfImpact, pt = Box2D.Collision.b2TOIInput, it = Box2D.Collision.b2WorldManifold, d = Box2D.Collision.ClipVertex, v = Box2D.Collision.Features, wt = Box2D.Collision.IBroadPhase; s.b2AABB = function () { this.lowerBound = new i; this.upperBound = new i }; s.prototype.IsValid = function () { var n = this.upperBound.y - this.lowerBound.y; return (n = this.upperBound.x - this.lowerBound.x >= 0 && n >= 0) && this.lowerBound.IsValid() && this.upperBound.IsValid() }; s.prototype.GetCenter = function () { return new i((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2) }; s.prototype.GetExtents = function () { return new i((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2) }; s.prototype.Contains = function (n) { var t = !0; return (t = (t = (t = t && this.lowerBound.x <= n.lowerBound.x) && this.lowerBound.y <= n.lowerBound.y) && n.upperBound.x <= this.upperBound.x) && n.upperBound.y <= this.upperBound.y }; s.prototype.RayCast = function (n, t) { var f = -Number.MAX_VALUE, e = Number.MAX_VALUE, o = t.p1.x, s = t.p1.y, c = t.p2.x - t.p1.x, l = t.p2.y - t.p1.y, a = Math.abs(l), h = n.normal, i = 0, r = 0, u = i = 0; if (u = 0, Math.abs(c) < Number.MIN_VALUE) { if (o < this.lowerBound.x || this.upperBound.x < o) return !1 } else if (i = 1 / c, r = (this.lowerBound.x - o) * i, i = (this.upperBound.x - o) * i, u = -1, r > i && (u = r, r = i, i = u, u = 1), r > f && (h.x = u, h.y = 0, f = r), e = Math.min(e, i), f > e) return !1; if (a < Number.MIN_VALUE) { if (s < this.lowerBound.y || this.upperBound.y < s) return !1 } else if (i = 1 / l, r = (this.lowerBound.y - s) * i, i = (this.upperBound.y - s) * i, u = -1, r > i && (u = r, r = i, i = u, u = 1), r > f && (h.y = u, h.x = 0, f = r), e = Math.min(e, i), f > e) return !1; return n.fraction = f, !0 }; s.prototype.TestOverlap = function (n) { var t = n.lowerBound.y - this.upperBound.y, i = this.lowerBound.y - n.upperBound.y; return n.lowerBound.x - this.upperBound.x > 0 || t > 0 ? !1 : this.lowerBound.x - n.upperBound.x > 0 || i > 0 ? !1 : !0 }; s.Combine = function (n, t) { var i = new s; return i.Combine(n, t), i }; s.prototype.Combine = function (n, t) { this.lowerBound.x = Math.min(n.lowerBound.x, t.lowerBound.x); this.lowerBound.y = Math.min(n.lowerBound.y, t.lowerBound.y); this.upperBound.x = Math.max(n.upperBound.x, t.upperBound.x); this.upperBound.y = Math.max(n.upperBound.y, t.upperBound.y) }; k.b2Bound = function () { }; k.prototype.IsLower = function () { return (this.value & 1) == 0 }; k.prototype.IsUpper = function () { return (this.value & 1) == 1 }; k.prototype.Swap = function (n) { var t = this.value, i = this.proxy, r = this.stabbingCount; this.value = n.value; this.proxy = n.proxy; this.stabbingCount = n.stabbingCount; n.value = t; n.proxy = i; n.stabbingCount = r }; et.b2BoundValues = function () { }; et.prototype.b2BoundValues = function () { this.lowerValues = new Vector_a2j_Number; this.lowerValues[0] = 0; this.lowerValues[1] = 0; this.upperValues = new Vector_a2j_Number; this.upperValues[0] = 0; this.upperValues[1] = 0 }; r.b2Collision = function () { }; r.ClipSegmentToLine = function (n, t, i, r) { var u, f, e, s, o; return r === undefined && (r = 0), f = 0, u = t[0], e = u.v, u = t[1], s = u.v, o = i.x * e.x + i.y * e.y - r, u = i.x * s.x + i.y * s.y - r, o <= 0 && n[f++].Set(t[0]), u <= 0 && n[f++].Set(t[1]), o * u < 0 && (i = o / (o - u), u = n[f], u = u.v, u.x = e.x + i * (s.x - e.x), u.y = e.y + i * (s.y - e.y), u = n[f], u.id = (o > 0 ? t[0] : t[1]).id, ++f), f }; r.EdgeSeparation = function (n, t, i, r, u) { var o, c, h, f, e, l; i === undefined && (i = 0); parseInt(n.m_vertexCount); o = n.m_vertices; n = n.m_normals; c = parseInt(r.m_vertexCount); h = r.m_vertices; f = t.R; e = n[i]; n = f.col1.x * e.x + f.col2.x * e.y; r = f.col1.y * e.x + f.col2.y * e.y; f = u.R; l = f.col1.x * n + f.col1.y * r; f = f.col2.x * n + f.col2.y * r; for (var a = 0, v = Number.MAX_VALUE, s = 0; s < c; ++s) e = h[s], e = e.x * l + e.y * f, e < v && (v = e, a = s); return e = o[i], f = t.R, i = t.position.x + (f.col1.x * e.x + f.col2.x * e.y), t = t.position.y + (f.col1.y * e.x + f.col2.y * e.y), e = h[a], f = u.R, o = u.position.x + (f.col1.x * e.x + f.col2.x * e.y), u = u.position.y + (f.col1.y * e.x + f.col2.y * e.y), o -= i, u -= t, o * n + u * r }; r.FindMaxSeparation = function (n, t, i, u, f) { var y = parseInt(t.m_vertexCount), l = t.m_normals, e, o, s, c, a, h, v, p; for (o = f.R, e = u.m_centroid, s = f.position.x + (o.col1.x * e.x + o.col2.x * e.y), c = f.position.y + (o.col1.y * e.x + o.col2.y * e.y), o = i.R, e = t.m_centroid, s -= i.position.x + (o.col1.x * e.x + o.col2.x * e.y), c -= i.position.y + (o.col1.y * e.x + o.col2.y * e.y), o = s * i.R.col1.x + c * i.R.col1.y, c = s * i.R.col2.x + c * i.R.col2.y, s = 0, a = -Number.MAX_VALUE, h = 0; h < y; ++h) e = l[h], e = e.x * o + e.y * c, e > a && (a = e, s = h); if (l = r.EdgeSeparation(t, i, s, u, f), e = parseInt(s - 1 >= 0 ? s - 1 : y - 1), o = r.EdgeSeparation(t, i, e, u, f), c = parseInt(s + 1 < y ? s + 1 : 0), a = r.EdgeSeparation(t, i, c, u, f), v = h = 0, p = 0, o > l && o > a) p = -1, h = e, v = o; else if (a > l) p = 1, h = c, v = a; else return n[0] = s, l; for (; ;) if (s = p == -1 ? h - 1 >= 0 ? h - 1 : y - 1 : h + 1 < y ? h + 1 : 0, l = r.EdgeSeparation(t, i, s, u, f), l > v) h = s, v = l; else break; return n[0] = h, v }; r.FindIncidentEdge = function (n, t, i, r, u, f) { var s, o, e, h, l, c; for (r === undefined && (r = 0), parseInt(t.m_vertexCount), s = t.m_normals, o = parseInt(u.m_vertexCount), t = u.m_vertices, u = u.m_normals, e = i.R, i = s[r], s = e.col1.x * i.x + e.col2.x * i.y, h = e.col1.y * i.x + e.col2.y * i.y, e = f.R, i = e.col1.x * s + e.col1.y * h, h = e.col2.x * s + e.col2.y * h, s = i, e = 0, l = Number.MAX_VALUE, c = 0; c < o; ++c) i = u[c], i = s * i.x + h * i.y, i < l && (l = i, e = c); u = parseInt(e); s = parseInt(u + 1 < o ? u + 1 : 0); o = n[0]; i = t[u]; e = f.R; o.v.x = f.position.x + (e.col1.x * i.x + e.col2.x * i.y); o.v.y = f.position.y + (e.col1.y * i.x + e.col2.y * i.y); o.id.features.referenceEdge = r; o.id.features.incidentEdge = u; o.id.features.incidentVertex = 0; o = n[1]; i = t[s]; e = f.R; o.v.x = f.position.x + (e.col1.x * i.x + e.col2.x * i.y); o.v.y = f.position.y + (e.col1.y * i.x + e.col2.y * i.y); o.id.features.referenceEdge = r; o.id.features.incidentEdge = s; o.id.features.incidentVertex = 1 }; r.MakeClipPointVector = function () { var n = new Vector(2); return n[0] = new d, n[1] = new d, n }; r.CollidePolygons = function (n, t, i, f, o) { var a, b, c, s, l, h, k, v, w, y, p; if (n.m_pointCount = 0, b = t.m_radius + f.m_radius, a = 0, r.s_edgeAO[0] = a, c = r.FindMaxSeparation(r.s_edgeAO, t, i, f, o), a = r.s_edgeAO[0], !(c > b) && (s = 0, r.s_edgeBO[0] = s, l = r.FindMaxSeparation(r.s_edgeBO, f, o, t, i), s = r.s_edgeBO[0], !(l > b) && (h = 0, k = 0, l > .98 * c + .001 ? (c = f, f = t, t = o, i = i, h = s, n.m_type = e.e_faceB, k = 1) : (c = t, f = f, t = i, i = o, h = a, n.m_type = e.e_faceA, k = 0), a = r.s_incidentEdge, r.FindIncidentEdge(a, c, t, h, f, i), s = parseInt(c.m_vertexCount), o = c.m_vertices, c = o[h], v = h + 1 < s ? o[parseInt(h + 1)] : o[0], h = r.s_localTangent, h.Set(v.x - c.x, v.y - c.y), h.Normalize(), o = r.s_localNormal, o.x = h.y, o.y = -h.x, f = r.s_planePoint, f.Set(.5 * (c.x + v.x), .5 * (c.y + v.y)), l = r.s_tangent, s = t.R, l.x = s.col1.x * h.x + s.col2.x * h.y, l.y = s.col1.y * h.x + s.col2.y * h.y, w = r.s_tangent2, w.x = -l.x, w.y = -l.y, h = r.s_normal, h.x = l.y, h.y = -l.x, y = r.s_v11, p = r.s_v12, y.x = t.position.x + (s.col1.x * c.x + s.col2.x * c.y), y.y = t.position.y + (s.col1.y * c.x + s.col2.y * c.y), p.x = t.position.x + (s.col1.x * v.x + s.col2.x * v.y), p.y = t.position.y + (s.col1.y * v.x + s.col2.y * v.y), t = h.x * y.x + h.y * y.y, s = l.x * p.x + l.y * p.y + b, v = r.s_clipPoints1, c = r.s_clipPoints2, p = 0, p = r.ClipSegmentToLine(v, a, w, -l.x * y.x - l.y * y.y + b), !(p < 2) && (p = r.ClipSegmentToLine(c, v, l, s), !(p < 2))))) { for (n.m_localPlaneNormal.SetV(o), n.m_localPoint.SetV(f), f = o = 0; f < u.b2_maxManifoldPoints; ++f) a = c[f], h.x * a.v.x + h.y * a.v.y - t <= b && (l = n.m_points[o], s = i.R, w = a.v.x - i.position.x, y = a.v.y - i.position.y, l.m_localPoint.x = w * s.col1.x + y * s.col1.y, l.m_localPoint.y = w * s.col2.x + y * s.col2.y, l.m_id.Set(a.id), l.m_id.features.flip = k, ++o); n.m_pointCount = o } }; r.CollideCircles = function (n, t, i, r, u) { var f, o, s; n.m_pointCount = 0; f = i.R; o = t.m_p; s = i.position.x + (f.col1.x * o.x + f.col2.x * o.y); i = i.position.y + (f.col1.y * o.x + f.col2.y * o.y); f = u.R; o = r.m_p; s = u.position.x + (f.col1.x * o.x + f.col2.x * o.y) - s; u = u.position.y + (f.col1.y * o.x + f.col2.y * o.y) - i; f = t.m_radius + r.m_radius; s * s + u * u > f * f || (n.m_type = e.e_circles, n.m_localPoint.SetV(t.m_p), n.m_localPlaneNormal.SetZero(), n.m_pointCount = 1, n.m_points[0].m_localPoint.SetV(r.m_p), n.m_points[0].m_id.key = 0) }; r.CollidePolygonAndCircle = function (n, t, i, r, u) { var h = n.m_pointCount = 0, l = 0, f, s, c, a, y, o, v; for (s = u.R, f = r.m_p, c = u.position.y + (s.col1.y * f.x + s.col2.y * f.y), h = u.position.x + (s.col1.x * f.x + s.col2.x * f.y) - i.position.x, l = c - i.position.y, s = i.R, i = h * s.col1.x + l * s.col1.y, s = h * s.col2.x + l * s.col2.y, a = 0, c = -Number.MAX_VALUE, u = t.m_radius + r.m_radius, y = parseInt(t.m_vertexCount), o = t.m_vertices, t = t.m_normals, v = 0; v < y; ++v) { if (f = o[v], h = i - f.x, l = s - f.y, f = t[v], h = f.x * h + f.y * l, h > u) return; h > c && (c = h, a = v) } if (h = parseInt(a), l = parseInt(h + 1 < y ? h + 1 : 0), f = o[h], o = o[l], c < Number.MIN_VALUE) n.m_pointCount = 1, n.m_type = e.e_faceA, n.m_localPlaneNormal.SetV(t[a]), n.m_localPoint.x = .5 * (f.x + o.x), n.m_localPoint.y = .5 * (f.y + o.y); else if (c = (i - o.x) * (f.x - o.x) + (s - o.y) * (f.y - o.y), (i - f.x) * (o.x - f.x) + (s - f.y) * (o.y - f.y) <= 0) { if ((i - f.x) * (i - f.x) + (s - f.y) * (s - f.y) > u * u) return; n.m_pointCount = 1; n.m_type = e.e_faceA; n.m_localPlaneNormal.x = i - f.x; n.m_localPlaneNormal.y = s - f.y; n.m_localPlaneNormal.Normalize(); n.m_localPoint.SetV(f) } else if (c <= 0) { if ((i - o.x) * (i - o.x) + (s - o.y) * (s - o.y) > u * u) return; n.m_pointCount = 1; n.m_type = e.e_faceA; n.m_localPlaneNormal.x = i - o.x; n.m_localPlaneNormal.y = s - o.y; n.m_localPlaneNormal.Normalize(); n.m_localPoint.SetV(o) } else { if (a = .5 * (f.x + o.x), f = .5 * (f.y + o.y), c = (i - a) * t[h].x + (s - f) * t[h].y, c > u) return; n.m_pointCount = 1; n.m_type = e.e_faceA; n.m_localPlaneNormal.x = t[h].x; n.m_localPlaneNormal.y = t[h].y; n.m_localPlaneNormal.Normalize(); n.m_localPoint.Set(a, f) } n.m_points[0].m_localPoint.SetV(r.m_p); n.m_points[0].m_id.key = 0 }; r.TestOverlap = function (n, t) { var i = t.lowerBound, r = n.upperBound, f = i.x - r.x, e = i.y - r.y, u; return (i = n.lowerBound, r = t.upperBound, u = i.y - r.y, f > 0 || e > 0) ? !1 : i.x - r.x > 0 || u > 0 ? !1 : !0 }; Box2D.postDefs.push(function () { Box2D.Collision.b2Collision.s_incidentEdge = r.MakeClipPointVector(); Box2D.Collision.b2Collision.s_clipPoints1 = r.MakeClipPointVector(); Box2D.Collision.b2Collision.s_clipPoints2 = r.MakeClipPointVector(); Box2D.Collision.b2Collision.s_edgeAO = new Vector_a2j_Number(1); Box2D.Collision.b2Collision.s_edgeBO = new Vector_a2j_Number(1); Box2D.Collision.b2Collision.s_localTangent = new i; Box2D.Collision.b2Collision.s_localNormal = new i; Box2D.Collision.b2Collision.s_planePoint = new i; Box2D.Collision.b2Collision.s_normal = new i; Box2D.Collision.b2Collision.s_tangent = new i; Box2D.Collision.b2Collision.s_tangent2 = new i; Box2D.Collision.b2Collision.s_v11 = new i; Box2D.Collision.b2Collision.s_v12 = new i; Box2D.Collision.b2Collision.b2CollidePolyTempVec = new i; Box2D.Collision.b2Collision.b2_nullFeature = 255 }); l.b2ContactID = function () { this.features = new v }; l.prototype.b2ContactID = function () { this.features._m_id = this }; l.prototype.Set = function (n) { this.key = n._key }; l.prototype.Copy = function () { var n = new l; return n.key = this.key, n }; Object.defineProperty(l.prototype, "key", { enumerable: !1, configurable: !0, get: function () { return this._key } }); Object.defineProperty(l.prototype, "key", { enumerable: !1, configurable: !0, set: function (n) { n === undefined && (n = 0); this._key = n; this.features._referenceEdge = this._key & 255; this.features._incidentEdge = (this._key & 65280) >> 8 & 255; this.features._incidentVertex = (this._key & 16711680) >> 16 & 255; this.features._flip = (this._key & 4278190080) >> 24 & 255 } }); vt.b2ContactPoint = function () { this.position = new i; this.velocity = new i; this.normal = new i; this.id = new l }; a.b2Distance = function () { }; a.Distance = function (t, r, f) { var o, e, c, b; ++a.b2_gjkCalls; var l = f.proxyA, h = f.proxyB, v = f.transformA, y = f.transformB, s = a.s_simplex; s.ReadCache(r, l, v, h, y); var p = s.m_vertices, k = a.s_saveA, d = a.s_saveB, w = 0; for (s.GetClosestPoint().LengthSquared(), o = 0, c = 0; c < 20;) { for (w = s.m_count, o = 0; o < w; o++) k[o] = p[o].indexA, d[o] = p[o].indexB; switch (s.m_count) { case 1: break; case 2: s.Solve2(); break; case 3: s.Solve3(); break; default: u.b2Assert(!1) } if (s.m_count == 3) break; if (e = s.GetClosestPoint(), e.LengthSquared(), o = s.GetSearchDirection(), o.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) break; for (e = p[s.m_count], e.indexA = l.GetSupport(n.MulTMV(v.R, o.GetNegative())), e.wA = n.MulX(v, l.GetVertex(e.indexA)), e.indexB = h.GetSupport(n.MulTMV(y.R, o)), e.wB = n.MulX(y, h.GetVertex(e.indexB)), e.w = n.SubtractVV(e.wB, e.wA), ++c, ++a.b2_gjkIters, b = !1, o = 0; o < w; o++) if (e.indexA == k[o] && e.indexB == d[o]) { b = !0; break } if (b) break; ++s.m_count } a.b2_gjkMaxIters = n.Max(a.b2_gjkMaxIters, c); s.GetWitnessPoints(t.pointA, t.pointB); t.distance = n.SubtractVV(t.pointA, t.pointB).Length(); t.iterations = c; s.WriteCache(r); f.useRadii && (r = l.m_radius, h = h.m_radius, t.distance > r + h && t.distance > Number.MIN_VALUE ? (t.distance -= r + h, f = n.SubtractVV(t.pointB, t.pointA), f.Normalize(), t.pointA.x += r * f.x, t.pointA.y += r * f.y, t.pointB.x -= h * f.x, t.pointB.y -= h * f.y) : (e = new i, e.x = .5 * (t.pointA.x + t.pointB.x), e.y = .5 * (t.pointA.y + t.pointB.y), t.pointA.x = t.pointB.x = e.x, t.pointA.y = t.pointB.y = e.y, t.distance = 0)) }; Box2D.postDefs.push(function () { Box2D.Collision.b2Distance.s_simplex = new c; Box2D.Collision.b2Distance.s_saveA = new Vector_a2j_Number(3); Box2D.Collision.b2Distance.s_saveB = new Vector_a2j_Number(3) }); ot.b2DistanceInput = function () { }; st.b2DistanceOutput = function () { this.pointA = new i; this.pointB = new i }; y.b2DistanceProxy = function () { }; y.prototype.Set = function (n) { switch (n.GetType()) { case rt.e_circleShape: n = n instanceof lt ? n : null; this.m_vertices = new Vector(1, !0); this.m_vertices[0] = n.m_p; this.m_count = 1; this.m_radius = n.m_radius; break; case rt.e_polygonShape: n = n instanceof at ? n : null; this.m_vertices = n.m_vertices; this.m_count = n.m_vertexCount; this.m_radius = n.m_radius; break; default: u.b2Assert(!1) } }; y.prototype.GetSupport = function (n) { for (var i, r = 0, u = this.m_vertices[0].x * n.x + this.m_vertices[0].y * n.y, t = 1; t < this.m_count; ++t) i = this.m_vertices[t].x * n.x + this.m_vertices[t].y * n.y, i > u && (r = t, u = i); return r }; y.prototype.GetSupportVertex = function (n) { for (var i, r = 0, u = this.m_vertices[0].x * n.x + this.m_vertices[0].y * n.y, t = 1; t < this.m_count; ++t) i = this.m_vertices[t].x * n.x + this.m_vertices[t].y * n.y, i > u && (r = t, u = i); return this.m_vertices[r] }; y.prototype.GetVertexCount = function () { return this.m_count }; y.prototype.GetVertex = function (n) { return n === undefined && (n = 0), u.b2Assert(0 <= n && n < this.m_count), this.m_vertices[n] }; o.b2DynamicTree = function () { }; o.prototype.b2DynamicTree = function () { this.m_freeList = this.m_root = null; this.m_insertionCount = this.m_path = 0 }; o.prototype.CreateProxy = function (n, t) { var i = this.AllocateNode(), r = u.b2_aabbExtension, f = u.b2_aabbExtension; return i.aabb.lowerBound.x = n.lowerBound.x - r, i.aabb.lowerBound.y = n.lowerBound.y - f, i.aabb.upperBound.x = n.upperBound.x + r, i.aabb.upperBound.y = n.upperBound.y + f, i.userData = t, this.InsertLeaf(i), i }; o.prototype.DestroyProxy = function (n) { this.RemoveLeaf(n); this.FreeNode(n) }; o.prototype.MoveProxy = function (n, t, i) { if (u.b2Assert(n.IsLeaf()), n.aabb.Contains(t)) return !1; this.RemoveLeaf(n); var r = u.b2_aabbExtension + u.b2_aabbMultiplier * (i.x > 0 ? i.x : -i.x); return i = u.b2_aabbExtension + u.b2_aabbMultiplier * (i.y > 0 ? i.y : -i.y), n.aabb.lowerBound.x = t.lowerBound.x - r, n.aabb.lowerBound.y = t.lowerBound.y - i, n.aabb.upperBound.x = t.upperBound.x + r, n.aabb.upperBound.y = t.upperBound.y + i, this.InsertLeaf(n), !0 }; o.prototype.Rebalance = function (n) { var r, t, i; if (n === undefined && (n = 0), this.m_root != null) for (r = 0; r < n; r++) { for (t = this.m_root, i = 0; t.IsLeaf() == !1;) t = this.m_path >> i & 1 ? t.child2 : t.child1, i = i + 1 & 31; ++this.m_path; this.RemoveLeaf(t); this.InsertLeaf(t) } }; o.prototype.GetFatAABB = function (n) { return n.aabb }; o.prototype.GetUserData = function (n) { return n.userData }; o.prototype.Query = function (n, t) { var u, i, r; if (this.m_root != null) for (u = new Vector, i = 0, u[i++] = this.m_root; i > 0;) if (r = u[--i], r.aabb.TestOverlap(t)) if (r.IsLeaf()) { if (!n(r)) break } else u[i++] = r.child1, u[i++] = r.child2 }; o.prototype.RayCast = function (t, i) { var a, c; if (this.m_root != null) { var r = i.p1, l = i.p2, h = n.SubtractVV(r, l); h.Normalize(); h = n.CrossFV(1, h); var v = n.AbsV(h), u = i.maxFraction, e = new s, f = 0, o = 0; for (f = r.x + u * (l.x - r.x), o = r.y + u * (l.y - r.y), e.lowerBound.x = Math.min(r.x, f), e.lowerBound.y = Math.min(r.y, o), e.upperBound.x = Math.max(r.x, f), e.upperBound.y = Math.max(r.y, o), a = new Vector, c = 0, a[c++] = this.m_root; c > 0;) if (u = a[--c], u.aabb.TestOverlap(e) != !1 && (f = u.aabb.GetCenter(), o = u.aabb.GetExtents(), !(Math.abs(h.x * (r.x - f.x) + h.y * (r.y - f.y)) - v.x * o.x - v.y * o.y > 0))) if (u.IsLeaf()) { if (f = new tt, f.p1 = i.p1, f.p2 = i.p2, f.maxFraction = i.maxFraction, u = t(f, u), u == 0) break; u > 0 && (f = r.x + u * (l.x - r.x), o = r.y + u * (l.y - r.y), e.lowerBound.x = Math.min(r.x, f), e.lowerBound.y = Math.min(r.y, o), e.upperBound.x = Math.max(r.x, f), e.upperBound.y = Math.max(r.y, o)) } else a[c++] = u.child1, a[c++] = u.child2 } }; o.prototype.AllocateNode = function () { if (this.m_freeList) { var n = this.m_freeList; return this.m_freeList = n.parent, n.parent = null, n.child1 = null, n.child2 = null, n } return new g }; o.prototype.FreeNode = function (n) { n.parent = this.m_freeList; this.m_freeList = n }; o.prototype.InsertLeaf = function (n) { var r, i, t; if (++this.m_insertionCount, this.m_root == null) this.m_root = n, this.m_root.parent = null; else { if (r = n.aabb.GetCenter(), i = this.m_root, i.IsLeaf() == !1) do t = i.child1, i = i.child2, i = Math.abs((t.aabb.lowerBound.x + t.aabb.upperBound.x) / 2 - r.x) + Math.abs((t.aabb.lowerBound.y + t.aabb.upperBound.y) / 2 - r.y) < Math.abs((i.aabb.lowerBound.x + i.aabb.upperBound.x) / 2 - r.x) + Math.abs((i.aabb.lowerBound.y + i.aabb.upperBound.y) / 2 - r.y) ? t : i; while (i.IsLeaf() == !1); if (r = i.parent, t = this.AllocateNode(), t.parent = r, t.userData = null, t.aabb.Combine(n.aabb, i.aabb), r) { i.parent.child1 == i ? r.child1 = t : r.child2 = t; t.child1 = i; t.child2 = n; i.parent = t; n.parent = t; do { if (r.aabb.Contains(t.aabb)) break; r.aabb.Combine(r.child1.aabb, r.child2.aabb); t = r; r = r.parent } while (r) } else t.child1 = i, t.child2 = n, i.parent = t, this.m_root = n.parent = t } }; o.prototype.RemoveLeaf = function (n) { if (n == this.m_root) this.m_root = null; else { var i = n.parent, t = i.parent; if (n = i.child1 == n ? i.child2 : i.child1, t) for (t.child1 == i ? t.child1 = n : t.child2 = n, n.parent = t, this.FreeNode(i) ; t;) { if (i = t.aabb, t.aabb = s.Combine(t.child1.aabb, t.child2.aabb), i.Contains(t.aabb)) break; t = t.parent } else this.m_root = n, n.parent = null, this.FreeNode(i) } }; f.b2DynamicTreeBroadPhase = function () { this.m_tree = new o; this.m_moveBuffer = new Vector; this.m_pairBuffer = new Vector; this.m_pairCount = 0 }; f.prototype.CreateProxy = function (n, t) { var i = this.m_tree.CreateProxy(n, t); return ++this.m_proxyCount, this.BufferMove(i), i }; f.prototype.DestroyProxy = function (n) { this.UnBufferMove(n); --this.m_proxyCount; this.m_tree.DestroyProxy(n) }; f.prototype.MoveProxy = function (n, t, i) { this.m_tree.MoveProxy(n, t, i) && this.BufferMove(n) }; f.prototype.TestOverlap = function (n, t) { var i = this.m_tree.GetFatAABB(n), r = this.m_tree.GetFatAABB(t); return i.TestOverlap(r) }; f.prototype.GetUserData = function (n) { return this.m_tree.GetUserData(n) }; f.prototype.GetFatAABB = function (n) { return this.m_tree.GetFatAABB(n) }; f.prototype.GetProxyCount = function () { return this.m_proxyCount }; f.prototype.UpdatePairs = function (n) { for (var t = this, i = t.m_pairCount = 0, r, u, f, e, i = 0; i < t.m_moveBuffer.length; ++i) r = t.m_moveBuffer[i], u = t.m_tree.GetFatAABB(r), t.m_tree.Query(function (n) { if (n == r) return !0; t.m_pairCount == t.m_pairBuffer.length && (t.m_pairBuffer[t.m_pairCount] = new ht); var i = t.m_pairBuffer[t.m_pairCount]; return i.proxyA = n < r ? n : r, i.proxyB = n >= r ? n : r, ++t.m_pairCount, !0 }, u); for (i = t.m_moveBuffer.length = 0; i < t.m_pairCount;) for (u = t.m_pairBuffer[i], f = t.m_tree.GetUserData(u.proxyA), e = t.m_tree.GetUserData(u.proxyB), n(f, e), ++i; i < t.m_pairCount;) { if (f = t.m_pairBuffer[i], f.proxyA != u.proxyA || f.proxyB != u.proxyB) break; ++i } }; f.prototype.Query = function (n, t) { this.m_tree.Query(n, t) }; f.prototype.RayCast = function (n, t) { this.m_tree.RayCast(n, t) }; f.prototype.Validate = function () { }; f.prototype.Rebalance = function (n) { n === undefined && (n = 0); this.m_tree.Rebalance(n) }; f.prototype.BufferMove = function (n) { this.m_moveBuffer[this.m_moveBuffer.length] = n }; f.prototype.UnBufferMove = function (n) { this.m_moveBuffer.splice(parseInt(this.m_moveBuffer.indexOf(n)), 1) }; f.prototype.ComparePairs = function () { return 0 }; f.__implements = {}; f.__implements[wt] = !0; g.b2DynamicTreeNode = function () { this.aabb = new s }; g.prototype.IsLeaf = function () { return this.child1 == null }; ht.b2DynamicTreePair = function () { }; e.b2Manifold = function () { this.m_pointCount = 0 }; e.prototype.b2Manifold = function () { this.m_points = new Vector(u.b2_maxManifoldPoints); for (var n = 0; n < u.b2_maxManifoldPoints; n++) this.m_points[n] = new p; this.m_localPlaneNormal = new i; this.m_localPoint = new i }; e.prototype.Reset = function () { for (var n = 0; n < u.b2_maxManifoldPoints; n++) (this.m_points[n] instanceof p ? this.m_points[n] : null).Reset(); this.m_localPlaneNormal.SetZero(); this.m_localPoint.SetZero(); this.m_pointCount = this.m_type = 0 }; e.prototype.Set = function (n) { this.m_pointCount = n.m_pointCount; for (var t = 0; t < u.b2_maxManifoldPoints; t++) (this.m_points[t] instanceof p ? this.m_points[t] : null).Set(n.m_points[t]); this.m_localPlaneNormal.SetV(n.m_localPlaneNormal); this.m_localPoint.SetV(n.m_localPoint); this.m_type = n.m_type }; e.prototype.Copy = function () { var n = new e; return n.Set(this), n }; Box2D.postDefs.push(function () { Box2D.Collision.b2Manifold.e_circles = 1; Box2D.Collision.b2Manifold.e_faceA = 2; Box2D.Collision.b2Manifold.e_faceB = 4 }); p.b2ManifoldPoint = function () { this.m_localPoint = new i; this.m_id = new l }; p.prototype.b2ManifoldPoint = function () { this.Reset() }; p.prototype.Reset = function () { this.m_localPoint.SetZero(); this.m_tangentImpulse = this.m_normalImpulse = 0; this.m_id.key = 0 }; p.prototype.Set = function (n) { this.m_localPoint.SetV(n.m_localPoint); this.m_normalImpulse = n.m_normalImpulse; this.m_tangentImpulse = n.m_tangentImpulse; this.m_id.Set(n.m_id) }; nt.b2Point = function () { this.p = new i }; nt.prototype.Support = function () { return this.p }; nt.prototype.GetFirstVertex = function () { return this.p }; tt.b2RayCastInput = function () { this.p1 = new i; this.p2 = new i }; tt.prototype.b2RayCastInput = function (n, t, i) { n === undefined && (n = null); t === undefined && (t = null); i === undefined && (i = 1); n && this.p1.SetV(n); t && this.p2.SetV(t); this.maxFraction = i }; yt.b2RayCastOutput = function () { this.normal = new i }; w.b2Segment = function () { this.p1 = new i; this.p2 = new i }; w.prototype.TestSegment = function (n, t, i, r) { var s, h; r === undefined && (r = 0); var u = i.p1, c = i.p2.x - u.x, l = i.p2.y - u.y; i = this.p2.y - this.p1.y; var f = -(this.p2.x - this.p1.x), o = 100 * Number.MIN_VALUE, e = -(c * i + l * f); return e > o && (s = u.x - this.p1.x, h = u.y - this.p1.y, u = s * i + h * f, 0 <= u && u <= r * e && (r = -c * h + l * s, -o * e <= r && r <= e * (1 + o))) ? (u /= e, r = Math.sqrt(i * i + f * f), i /= r, f /= r, n[0] = u, t.Set(i, f), !0) : !1 }; w.prototype.Extend = function (n) { this.ExtendForward(n); this.ExtendBackward(n) }; w.prototype.ExtendForward = function (n) { var t = this.p2.x - this.p1.x, i = this.p2.y - this.p1.y; n = Math.min(t > 0 ? (n.upperBound.x - this.p1.x) / t : t < 0 ? (n.lowerBound.x - this.p1.x) / t : Number.POSITIVE_INFINITY, i > 0 ? (n.upperBound.y - this.p1.y) / i : i < 0 ? (n.lowerBound.y - this.p1.y) / i : Number.POSITIVE_INFINITY); this.p2.x = this.p1.x + t * n; this.p2.y = this.p1.y + i * n }; w.prototype.ExtendBackward = function (n) { var t = -this.p2.x + this.p1.x, i = -this.p2.y + this.p1.y; n = Math.min(t > 0 ? (n.upperBound.x - this.p2.x) / t : t < 0 ? (n.lowerBound.x - this.p2.x) / t : Number.POSITIVE_INFINITY, i > 0 ? (n.upperBound.y - this.p2.y) / i : i < 0 ? (n.lowerBound.y - this.p2.y) / i : Number.POSITIVE_INFINITY); this.p1.x = this.p2.x + t * n; this.p1.y = this.p2.y + i * n }; h.b2SeparationFunction = function () { this.m_localPoint = new i; this.m_axis = new i }; h.prototype.Initialize = function (t, r, f, e, o) { var s, l, y, a, v, c, p; this.m_proxyA = r; this.m_proxyB = e; s = parseInt(t.count); u.b2Assert(0 < s && s < 3); c = v = a = e = r = 0; p = 0; c = 0; s == 1 ? (this.m_type = h.e_points, l = this.m_proxyA.GetVertex(t.indexA[0]), y = this.m_proxyB.GetVertex(t.indexB[0]), s = l, t = f.R, r = f.position.x + (t.col1.x * s.x + t.col2.x * s.y), e = f.position.y + (t.col1.y * s.x + t.col2.y * s.y), s = y, t = o.R, a = o.position.x + (t.col1.x * s.x + t.col2.x * s.y), v = o.position.y + (t.col1.y * s.x + t.col2.y * s.y), this.m_axis.x = a - r, this.m_axis.y = v - e, this.m_axis.Normalize()) : (t.indexB[0] == t.indexB[1] ? (this.m_type = h.e_faceA, r = this.m_proxyA.GetVertex(t.indexA[0]), e = this.m_proxyA.GetVertex(t.indexA[1]), y = this.m_proxyB.GetVertex(t.indexB[0]), this.m_localPoint.x = .5 * (r.x + e.x), this.m_localPoint.y = .5 * (r.y + e.y), this.m_axis = n.CrossVF(n.SubtractVV(e, r), 1), this.m_axis.Normalize(), s = this.m_axis, t = f.R, c = t.col1.x * s.x + t.col2.x * s.y, p = t.col1.y * s.x + t.col2.y * s.y, s = this.m_localPoint, t = f.R, r = f.position.x + (t.col1.x * s.x + t.col2.x * s.y), e = f.position.y + (t.col1.y * s.x + t.col2.y * s.y), s = y, t = o.R, a = o.position.x + (t.col1.x * s.x + t.col2.x * s.y), v = o.position.y + (t.col1.y * s.x + t.col2.y * s.y), c = (a - r) * c + (v - e) * p) : t.indexA[0] == t.indexA[0] ? (this.m_type = h.e_faceB, a = this.m_proxyB.GetVertex(t.indexB[0]), v = this.m_proxyB.GetVertex(t.indexB[1]), l = this.m_proxyA.GetVertex(t.indexA[0]), this.m_localPoint.x = .5 * (a.x + v.x), this.m_localPoint.y = .5 * (a.y + v.y), this.m_axis = n.CrossVF(n.SubtractVV(v, a), 1), this.m_axis.Normalize(), s = this.m_axis, t = o.R, c = t.col1.x * s.x + t.col2.x * s.y, p = t.col1.y * s.x + t.col2.y * s.y, s = this.m_localPoint, t = o.R, a = o.position.x + (t.col1.x * s.x + t.col2.x * s.y), v = o.position.y + (t.col1.y * s.x + t.col2.y * s.y), s = l, t = f.R, r = f.position.x + (t.col1.x * s.x + t.col2.x * s.y), e = f.position.y + (t.col1.y * s.x + t.col2.y * s.y), c = (r - a) * c + (e - v) * p) : (r = this.m_proxyA.GetVertex(t.indexA[0]), e = this.m_proxyA.GetVertex(t.indexA[1]), a = this.m_proxyB.GetVertex(t.indexB[0]), v = this.m_proxyB.GetVertex(t.indexB[1]), n.MulX(f, l), l = n.MulMV(f.R, n.SubtractVV(e, r)), n.MulX(o, y), c = n.MulMV(o.R, n.SubtractVV(v, a)), o = l.x * l.x + l.y * l.y, y = c.x * c.x + c.y * c.y, t = n.SubtractVV(c, l), f = l.x * t.x + l.y * t.y, t = c.x * t.x + c.y * t.y, l = l.x * c.x + l.y * c.y, p = o * y - l * l, c = 0, p != 0 && (c = n.Clamp((l * t - f * y) / p, 0, 1)), (l * c + t) / y < 0 && (c = n.Clamp((l - f) / o, 0, 1)), l = new i, l.x = r.x + c * (e.x - r.x), l.y = r.y + c * (e.y - r.y), y = new i, y.x = a.x + c * (v.x - a.x), y.y = a.y + c * (v.y - a.y), c == 0 || c == 1 ? (this.m_type = h.e_faceB, this.m_axis = n.CrossVF(n.SubtractVV(v, a), 1), this.m_axis.Normalize(), this.m_localPoint = y) : (this.m_type = h.e_faceA, this.m_axis = n.CrossVF(n.SubtractVV(e, r), 1), this.m_localPoint = l)), c < 0 && this.m_axis.NegativeSelf()) }; h.prototype.Evaluate = function (t, i) { var r, f, e = 0; switch (this.m_type) { case h.e_points: return r = n.MulTMV(t.R, this.m_axis), f = n.MulTMV(i.R, this.m_axis.GetNegative()), r = this.m_proxyA.GetSupportVertex(r), f = this.m_proxyB.GetSupportVertex(f), r = n.MulX(t, r), f = n.MulX(i, f), (f.x - r.x) * this.m_axis.x + (f.y - r.y) * this.m_axis.y; case h.e_faceA: return e = n.MulMV(t.R, this.m_axis), r = n.MulX(t, this.m_localPoint), f = n.MulTMV(i.R, e.GetNegative()), f = this.m_proxyB.GetSupportVertex(f), f = n.MulX(i, f), (f.x - r.x) * e.x + (f.y - r.y) * e.y; case h.e_faceB: return e = n.MulMV(i.R, this.m_axis), f = n.MulX(i, this.m_localPoint), r = n.MulTMV(t.R, e.GetNegative()), r = this.m_proxyA.GetSupportVertex(r), r = n.MulX(t, r), (r.x - f.x) * e.x + (r.y - f.y) * e.y; default: return u.b2Assert(!1), 0 } }; Box2D.postDefs.push(function () { Box2D.Collision.b2SeparationFunction.e_points = 1; Box2D.Collision.b2SeparationFunction.e_faceA = 2; Box2D.Collision.b2SeparationFunction.e_faceB = 4 }); c.b2Simplex = function () { this.m_v1 = new b; this.m_v2 = new b; this.m_v3 = new b; this.m_vertices = new Vector(3) }; c.prototype.b2Simplex = function () { this.m_vertices[0] = this.m_v1; this.m_vertices[1] = this.m_v2; this.m_vertices[2] = this.m_v3 }; c.prototype.ReadCache = function (t, i, r, f, e) { var s, c, l, h, o; for (u.b2Assert(0 <= t.count && t.count <= 3), this.m_count = t.count, l = this.m_vertices, h = 0; h < this.m_count; h++) o = l[h], o.indexA = t.indexA[h], o.indexB = t.indexB[h], s = i.GetVertex(o.indexA), c = f.GetVertex(o.indexB), o.wA = n.MulX(r, s), o.wB = n.MulX(e, c), o.w = n.SubtractVV(o.wB, o.wA), o.a = 0; this.m_count > 1 && (t = t.metric, s = this.GetMetric(), (s < .5 * t || 2 * t < s || s < Number.MIN_VALUE) && (this.m_count = 0)); this.m_count == 0 && (o = l[0], o.indexA = 0, o.indexB = 0, s = i.GetVertex(0), c = f.GetVertex(0), o.wA = n.MulX(r, s), o.wB = n.MulX(e, c), o.w = n.SubtractVV(o.wB, o.wA), this.m_count = 1) }; c.prototype.WriteCache = function (n) { n.metric = this.GetMetric(); n.count = Box2D.parseUInt(this.m_count); for (var i = this.m_vertices, t = 0; t < this.m_count; t++) n.indexA[t] = Box2D.parseUInt(i[t].indexA), n.indexB[t] = Box2D.parseUInt(i[t].indexB) }; c.prototype.GetSearchDirection = function () { switch (this.m_count) { case 1: return this.m_v1.w.GetNegative(); case 2: var t = n.SubtractVV(this.m_v2.w, this.m_v1.w); return n.CrossVV(t, this.m_v1.w.GetNegative()) > 0 ? n.CrossFV(1, t) : n.CrossVF(t, 1); default: return u.b2Assert(!1), new i } }; c.prototype.GetClosestPoint = function () { switch (this.m_count) { case 0: return u.b2Assert(!1), new i; case 1: return this.m_v1.w; case 2: return new i(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y); default: return u.b2Assert(!1), new i } }; c.prototype.GetWitnessPoints = function (n, t) { switch (this.m_count) { case 0: u.b2Assert(!1); break; case 1: n.SetV(this.m_v1.wA); t.SetV(this.m_v1.wB); break; case 2: n.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x; n.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y; t.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x; t.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y; break; case 3: t.x = n.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x; t.y = n.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y; break; default: u.b2Assert(!1) } }; c.prototype.GetMetric = function () { switch (this.m_count) { case 0: return u.b2Assert(!1), 0; case 1: return 0; case 2: return n.SubtractVV(this.m_v1.w, this.m_v2.w).Length(); case 3: return n.CrossVV(n.SubtractVV(this.m_v2.w, this.m_v1.w), n.SubtractVV(this.m_v3.w, this.m_v1.w)); default: return u.b2Assert(!1), 0 } }; c.prototype.Solve2 = function () { var t = this.m_v1.w, i = this.m_v2.w, r = n.SubtractVV(i, t); t = -(t.x * r.x + t.y * r.y); t <= 0 ? this.m_count = this.m_v1.a = 1 : (i = i.x * r.x + i.y * r.y, i <= 0 ? (this.m_count = this.m_v2.a = 1, this.m_v1.Set(this.m_v2)) : (r = 1 / (i + t), this.m_v1.a = i * r, this.m_v2.a = t * r, this.m_count = 2)) }; c.prototype.Solve3 = function () { var i = this.m_v1.w, h = this.m_v2.w, r = this.m_v3.w, f = n.SubtractVV(h, i), c = n.Dot(i, f), t = n.Dot(h, f), u, s; c = -c; var e = n.SubtractVV(r, i), l = n.Dot(i, e), o = n.Dot(r, e); l = -l; u = n.SubtractVV(r, h); s = n.Dot(h, u); u = n.Dot(r, u); s = -s; e = n.CrossVV(f, e); f = e * n.CrossVV(h, r); r = e * n.CrossVV(r, i); i = e * n.CrossVV(i, h); c <= 0 && l <= 0 ? this.m_count = this.m_v1.a = 1 : t > 0 && c > 0 && i <= 0 ? (o = 1 / (t + c), this.m_v1.a = t * o, this.m_v2.a = c * o, this.m_count = 2) : o > 0 && l > 0 && r <= 0 ? (t = 1 / (o + l), this.m_v1.a = o * t, this.m_v3.a = l * t, this.m_count = 2, this.m_v2.Set(this.m_v3)) : t <= 0 && s <= 0 ? (this.m_count = this.m_v2.a = 1, this.m_v1.Set(this.m_v2)) : o <= 0 && u <= 0 ? (this.m_count = this.m_v3.a = 1, this.m_v1.Set(this.m_v3)) : u > 0 && s > 0 && f <= 0 ? (t = 1 / (u + s), this.m_v2.a = u * t, this.m_v3.a = s * t, this.m_count = 2, this.m_v1.Set(this.m_v3)) : (t = 1 / (f + r + i), this.m_v1.a = f * t, this.m_v2.a = r * t, this.m_v3.a = i * t, this.m_count = 3) }; ct.b2SimplexCache = function () { this.indexA = new Vector_a2j_Number(3); this.indexB = new Vector_a2j_Number(3) }; b.b2SimplexVertex = function () { }; b.prototype.Set = function (n) { this.wA.SetV(n.wA); this.wB.SetV(n.wB); this.w.SetV(n.w); this.a = n.a; this.indexA = n.indexA; this.indexB = n.indexB }; t.b2TimeOfImpact = function () { }; t.TimeOfImpact = function (i) { var h, f, b, v, e, y; ++t.b2_toiCalls; var k = i.proxyA, d = i.proxyB, s = i.sweepA, p = i.sweepB; u.b2Assert(s.t0 == p.t0); u.b2Assert(1 - s.t0 > Number.MIN_VALUE); h = k.m_radius + d.m_radius; i = i.tolerance; var r = 0, c = 0, o = 0; for (t.s_cache.count = 0, t.s_distanceInput.useRadii = !1; ;) { if (s.GetTransform(t.s_xfA, r), p.GetTransform(t.s_xfB, r), t.s_distanceInput.proxyA = k, t.s_distanceInput.proxyB = d, t.s_distanceInput.transformA = t.s_xfA, t.s_distanceInput.transformB = t.s_xfB, a.Distance(t.s_distanceOutput, t.s_cache, t.s_distanceInput), t.s_distanceOutput.distance <= 0) { r = 1; break } if (t.s_fcn.Initialize(t.s_cache, k, t.s_xfA, d, t.s_xfB), f = t.s_fcn.Evaluate(t.s_xfA, t.s_xfB), f <= 0) { r = 1; break } if (c == 0 && (o = f > h ? n.Max(h - i, .75 * h) : n.Max(f - i, .02 * h)), f - o < .5 * i) { if (c == 0) { r = 1; break } break } var g = r, w = r, l = 1; if (f = f, s.GetTransform(t.s_xfA, l), p.GetTransform(t.s_xfB, l), b = t.s_fcn.Evaluate(t.s_xfA, t.s_xfB), b >= o) { r = 1; break } for (v = 0; ;) { if (e = 0, e = v & 1 ? w + (o - f) * (l - w) / (b - f) : .5 * (w + l), s.GetTransform(t.s_xfA, e), p.GetTransform(t.s_xfB, e), y = t.s_fcn.Evaluate(t.s_xfA, t.s_xfB), n.Abs(y - o) < .025 * i) { g = e; break } if (y > o ? (w = e, f = y) : (l = e, b = y), ++v, ++t.b2_toiRootIters, v == 50) break } if (t.b2_toiMaxRootIters = n.Max(t.b2_toiMaxRootIters, v), g < (1 + 100 * Number.MIN_VALUE) * r) break; if (r = g, c++, ++t.b2_toiIters, c == 1e3) break } return t.b2_toiMaxIters = n.Max(t.b2_toiMaxIters, c), r }; Box2D.postDefs.push(function () { Box2D.Collision.b2TimeOfImpact.b2_toiCalls = 0; Box2D.Collision.b2TimeOfImpact.b2_toiIters = 0; Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters = 0; Box2D.Collision.b2TimeOfImpact.b2_toiRootIters = 0; Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0; Box2D.Collision.b2TimeOfImpact.s_cache = new ct; Box2D.Collision.b2TimeOfImpact.s_distanceInput = new ot; Box2D.Collision.b2TimeOfImpact.s_xfA = new ft; Box2D.Collision.b2TimeOfImpact.s_xfB = new ft; Box2D.Collision.b2TimeOfImpact.s_fcn = new h; Box2D.Collision.b2TimeOfImpact.s_distanceOutput = new st }); pt.b2TOIInput = function () { this.proxyA = new y; this.proxyB = new y; this.sweepA = new ut; this.sweepB = new ut }; it.b2WorldManifold = function () { this.m_normal = new i }; it.prototype.b2WorldManifold = function () { this.m_points = new Vector(u.b2_maxManifoldPoints); for (var n = 0; n < u.b2_maxManifoldPoints; n++) this.m_points[n] = new i }; it.prototype.Initialize = function (n, t, i, r, u) { if (i === undefined && (i = 0), u === undefined && (u = 0), n.m_pointCount != 0) { var h = 0, f, o, s = 0, c = 0, a = 0, v = 0, l = 0; f = 0; switch (n.m_type) { case e.e_circles: o = t.R; f = n.m_localPoint; h = t.position.x + o.col1.x * f.x + o.col2.x * f.y; t = t.position.y + o.col1.y * f.x + o.col2.y * f.y; o = r.R; f = n.m_points[0].m_localPoint; n = r.position.x + o.col1.x * f.x + o.col2.x * f.y; r = r.position.y + o.col1.y * f.x + o.col2.y * f.y; f = n - h; o = r - t; s = f * f + o * o; s > Number.MIN_VALUE * Number.MIN_VALUE ? (s = Math.sqrt(s), this.m_normal.x = f / s, this.m_normal.y = o / s) : (this.m_normal.x = 1, this.m_normal.y = 0); f = t + i * this.m_normal.y; r = r - u * this.m_normal.y; this.m_points[0].x = .5 * (h + i * this.m_normal.x + (n - u * this.m_normal.x)); this.m_points[0].y = .5 * (f + r); break; case e.e_faceA: for (o = t.R, f = n.m_localPlaneNormal, s = o.col1.x * f.x + o.col2.x * f.y, c = o.col1.y * f.x + o.col2.y * f.y, o = t.R, f = n.m_localPoint, a = t.position.x + o.col1.x * f.x + o.col2.x * f.y, v = t.position.y + o.col1.y * f.x + o.col2.y * f.y, this.m_normal.x = s, this.m_normal.y = c, h = 0; h < n.m_pointCount; h++) o = r.R, f = n.m_points[h].m_localPoint, l = r.position.x + o.col1.x * f.x + o.col2.x * f.y, f = r.position.y + o.col1.y * f.x + o.col2.y * f.y, this.m_points[h].x = l + .5 * (i - (l - a) * s - (f - v) * c - u) * s, this.m_points[h].y = f + .5 * (i - (l - a) * s - (f - v) * c - u) * c; break; case e.e_faceB: for (o = r.R, f = n.m_localPlaneNormal, s = o.col1.x * f.x + o.col2.x * f.y, c = o.col1.y * f.x + o.col2.y * f.y, o = r.R, f = n.m_localPoint, a = r.position.x + o.col1.x * f.x + o.col2.x * f.y, v = r.position.y + o.col1.y * f.x + o.col2.y * f.y, this.m_normal.x = -s, this.m_normal.y = -c, h = 0; h < n.m_pointCount; h++) o = t.R, f = n.m_points[h].m_localPoint, l = t.position.x + o.col1.x * f.x + o.col2.x * f.y, f = t.position.y + o.col1.y * f.x + o.col2.y * f.y, this.m_points[h].x = l + .5 * (u - (l - a) * s - (f - v) * c - i) * s, this.m_points[h].y = f + .5 * (u - (l - a) * s - (f - v) * c - i) * c } } }; d.ClipVertex = function () { this.v = new i; this.id = new l }; d.prototype.Set = function (n) { this.v.SetV(n.v); this.id.Set(n.id) }; v.Features = function () { }; Object.defineProperty(v.prototype, "referenceEdge", { enumerable: !1, configurable: !0, get: function () { return this._referenceEdge } }); Object.defineProperty(v.prototype, "referenceEdge", { enumerable: !1, configurable: !0, set: function (n) { n === undefined && (n = 0); this._referenceEdge = n; this._m_id._key = this._m_id._key & 4294967040 | this._referenceEdge & 255 } }); Object.defineProperty(v.prototype, "incidentEdge", { enumerable: !1, configurable: !0, get: function () { return this._incidentEdge } }); Object.defineProperty(v.prototype, "incidentEdge", { enumerable: !1, configurable: !0, set: function (n) { n === undefined && (n = 0); this._incidentEdge = n; this._m_id._key = this._m_id._key & 4294902015 | this._incidentEdge << 8 & 65280 } }); Object.defineProperty(v.prototype, "incidentVertex", { enumerable: !1, configurable: !0, get: function () { return this._incidentVertex } }); Object.defineProperty(v.prototype, "incidentVertex", { enumerable: !1, configurable: !0, set: function (n) { n === undefined && (n = 0); this._incidentVertex = n; this._m_id._key = this._m_id._key & 4278255615 | this._incidentVertex << 16 & 16711680 } }); Object.defineProperty(v.prototype, "flip", { enumerable: !1, configurable: !0, get: function () { return this._flip } }); Object.defineProperty(v.prototype, "flip", { enumerable: !1, configurable: !0, set: function (n) { n === undefined && (n = 0); this._flip = n; this._m_id._key = this._m_id._key & 16777215 | this._flip << 24 & 4278190080 } }) }(), function () { var e = Box2D.Common.b2Settings, r = Box2D.Collision.Shapes.b2CircleShape, o = Box2D.Collision.Shapes.b2EdgeChainDef, t = Box2D.Collision.Shapes.b2EdgeShape, s = Box2D.Collision.Shapes.b2MassData, n = Box2D.Collision.Shapes.b2PolygonShape, f = Box2D.Collision.Shapes.b2Shape, c = Box2D.Common.Math.b2Mat22, u = Box2D.Common.Math.b2Math, l = Box2D.Common.Math.b2Transform, i = Box2D.Common.Math.b2Vec2, a = Box2D.Collision.b2Distance, v = Box2D.Collision.b2DistanceInput, y = Box2D.Collision.b2DistanceOutput, h = Box2D.Collision.b2DistanceProxy, p = Box2D.Collision.b2SimplexCache; Box2D.inherit(r, Box2D.Collision.Shapes.b2Shape); r.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype; r.b2CircleShape = function () { Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments); this.m_p = new i }; r.prototype.Copy = function () { var n = new r; return n.Set(this), n }; r.prototype.Set = function (n) { this.__super.Set.call(this, n); Box2D.is(n, r) && this.m_p.SetV((n instanceof r ? n : null).m_p) }; r.prototype.TestPoint = function (n, t) { var i = n.R, r = n.position.x + (i.col1.x * this.m_p.x + i.col2.x * this.m_p.y); return i = n.position.y + (i.col1.y * this.m_p.x + i.col2.y * this.m_p.y), r = t.x - r, i = t.y - i, r * r + i * i <= this.m_radius * this.m_radius }; r.prototype.RayCast = function (n, t, i) { var u = i.R, f = t.p1.x - (i.position.x + (u.col1.x * this.m_p.x + u.col2.x * this.m_p.y)); i = t.p1.y - (i.position.y + (u.col1.y * this.m_p.x + u.col2.y * this.m_p.y)); u = t.p2.x - t.p1.x; var e = t.p2.y - t.p1.y, r = f * u + i * e, o = u * u + e * e, s = r * r - o * (f * f + i * i - this.m_radius * this.m_radius); return s < 0 || o < Number.MIN_VALUE ? !1 : (r = -(r + Math.sqrt(s)), 0 <= r && r <= t.maxFraction * o) ? (r /= o, n.fraction = r, n.normal.x = f + r * u, n.normal.y = i + r * e, n.normal.Normalize(), !0) : !1 }; r.prototype.ComputeAABB = function (n, t) { var i = t.R, r = t.position.x + (i.col1.x * this.m_p.x + i.col2.x * this.m_p.y); i = t.position.y + (i.col1.y * this.m_p.x + i.col2.y * this.m_p.y); n.lowerBound.Set(r - this.m_radius, i - this.m_radius); n.upperBound.Set(r + this.m_radius, i + this.m_radius) }; r.prototype.ComputeMass = function (n, t) { t === undefined && (t = 0); n.mass = t * e.b2_pi * this.m_radius * this.m_radius; n.center.SetV(this.m_p); n.I = n.mass * (.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y)) }; r.prototype.ComputeSubmergedArea = function (n, t, i, r) { var f, e; return (t === undefined && (t = 0), i = u.MulX(i, this.m_p), f = -(u.Dot(n, i) - t), f < -this.m_radius + Number.MIN_VALUE) ? 0 : f > this.m_radius ? (r.SetV(i), Math.PI * this.m_radius * this.m_radius) : (t = this.m_radius * this.m_radius, e = f * f, f = t * (Math.asin(f / this.m_radius) + Math.PI / 2) + f * Math.sqrt(t - e), t = -2 / 3 * Math.pow(t - e, 1.5) / f, r.x = i.x + n.x * t, r.y = i.y + n.y * t, f) }; r.prototype.GetLocalPosition = function () { return this.m_p }; r.prototype.SetLocalPosition = function (n) { this.m_p.SetV(n) }; r.prototype.GetRadius = function () { return this.m_radius }; r.prototype.SetRadius = function (n) { n === undefined && (n = 0); this.m_radius = n }; r.prototype.b2CircleShape = function (n) { n === undefined && (n = 0); this.__super.b2Shape.call(this); this.m_type = f.e_circleShape; this.m_radius = n }; o.b2EdgeChainDef = function () { }; o.prototype.b2EdgeChainDef = function () { this.vertexCount = 0; this.isALoop = !0; this.vertices = [] }; Box2D.inherit(t, Box2D.Collision.Shapes.b2Shape); t.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype; t.b2EdgeShape = function () { Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments); this.s_supportVec = new i; this.m_v1 = new i; this.m_v2 = new i; this.m_coreV1 = new i; this.m_coreV2 = new i; this.m_normal = new i; this.m_direction = new i; this.m_cornerDir1 = new i; this.m_cornerDir2 = new i }; t.prototype.TestPoint = function () { return !1 }; t.prototype.RayCast = function (n, t, i) { var r, h = t.p2.x - t.p1.x, c = t.p2.y - t.p1.y, f, s; r = i.R; var e = i.position.x + (r.col1.x * this.m_v1.x + r.col2.x * this.m_v1.y), u = i.position.y + (r.col1.y * this.m_v1.x + r.col2.y * this.m_v1.y), o = i.position.y + (r.col1.y * this.m_v2.x + r.col2.y * this.m_v2.y) - u; return (i = -(i.position.x + (r.col1.x * this.m_v2.x + r.col2.x * this.m_v2.y) - e), r = 100 * Number.MIN_VALUE, f = -(h * o + c * i), f > r && (e = t.p1.x - e, s = t.p1.y - u, u = e * o + s * i, 0 <= u && u <= t.maxFraction * f && (t = -h * s + c * e, -r * f <= t && t <= f * (1 + r)))) ? (u /= f, n.fraction = u, t = Math.sqrt(o * o + i * i), n.normal.x = o / t, n.normal.y = i / t, !0) : !1 }; t.prototype.ComputeAABB = function (n, t) { var i = t.R, r = t.position.x + (i.col1.x * this.m_v1.x + i.col2.x * this.m_v1.y), u = t.position.y + (i.col1.y * this.m_v1.x + i.col2.y * this.m_v1.y), f = t.position.x + (i.col1.x * this.m_v2.x + i.col2.x * this.m_v2.y); i = t.position.y + (i.col1.y * this.m_v2.x + i.col2.y * this.m_v2.y); r < f ? (n.lowerBound.x = r, n.upperBound.x = f) : (n.lowerBound.x = f, n.upperBound.x = r); u < i ? (n.lowerBound.y = u, n.upperBound.y = i) : (n.lowerBound.y = i, n.upperBound.y = u) }; t.prototype.ComputeMass = function (n) { n.mass = 0; n.center.SetV(this.m_v1); n.I = 0 }; t.prototype.ComputeSubmergedArea = function (n, t, r, f) { var s, o, e; if (t === undefined && (t = 0), s = new i(n.x * t, n.y * t), o = u.MulX(r, this.m_v1), r = u.MulX(r, this.m_v2), e = u.Dot(n, o) - t, n = u.Dot(n, r) - t, e > 0) { if (n > 0) return 0; o.x = -n / (e - n) * o.x + e / (e - n) * r.x; o.y = -n / (e - n) * o.y + e / (e - n) * r.y } else n > 0 && (r.x = -n / (e - n) * o.x + e / (e - n) * r.x, r.y = -n / (e - n) * o.y + e / (e - n) * r.y); return f.x = (s.x + o.x + r.x) / 3, f.y = (s.y + o.y + r.y) / 3, .5 * ((o.x - s.x) * (r.y - s.y) - (o.y - s.y) * (r.x - s.x)) }; t.prototype.GetLength = function () { return this.m_length }; t.prototype.GetVertex1 = function () { return this.m_v1 }; t.prototype.GetVertex2 = function () { return this.m_v2 }; t.prototype.GetCoreVertex1 = function () { return this.m_coreV1 }; t.prototype.GetCoreVertex2 = function () { return this.m_coreV2 }; t.prototype.GetNormalVector = function () { return this.m_normal }; t.prototype.GetDirectionVector = function () { return this.m_direction }; t.prototype.GetCorner1Vector = function () { return this.m_cornerDir1 }; t.prototype.GetCorner2Vector = function () { return this.m_cornerDir2 }; t.prototype.Corner1IsConvex = function () { return this.m_cornerConvex1 }; t.prototype.Corner2IsConvex = function () { return this.m_cornerConvex2 }; t.prototype.GetFirstVertex = function (n) { var t = n.R; return new i(n.position.x + (t.col1.x * this.m_coreV1.x + t.col2.x * this.m_coreV1.y), n.position.y + (t.col1.y * this.m_coreV1.x + t.col2.y * this.m_coreV1.y)) }; t.prototype.GetNextEdge = function () { return this.m_nextEdge }; t.prototype.GetPrevEdge = function () { return this.m_prevEdge }; t.prototype.Support = function (n, t, i) { t === undefined && (t = 0); i === undefined && (i = 0); var r = n.R, u = n.position.x + (r.col1.x * this.m_coreV1.x + r.col2.x * this.m_coreV1.y), f = n.position.y + (r.col1.y * this.m_coreV1.x + r.col2.y * this.m_coreV1.y), e = n.position.x + (r.col1.x * this.m_coreV2.x + r.col2.x * this.m_coreV2.y); return n = n.position.y + (r.col1.y * this.m_coreV2.x + r.col2.y * this.m_coreV2.y), u * t + f * i > e * t + n * i ? (this.s_supportVec.x = u, this.s_supportVec.y = f) : (this.s_supportVec.x = e, this.s_supportVec.y = n), this.s_supportVec }; t.prototype.b2EdgeShape = function (n, t) { this.__super.b2Shape.call(this); this.m_type = f.e_edgeShape; this.m_nextEdge = this.m_prevEdge = null; this.m_v1 = n; this.m_v2 = t; this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y); this.m_length = this.m_direction.Normalize(); this.m_normal.Set(this.m_direction.y, -this.m_direction.x); this.m_coreV1.Set(-e.b2_toiSlop * (this.m_normal.x - this.m_direction.x) + this.m_v1.x, -e.b2_toiSlop * (this.m_normal.y - this.m_direction.y) + this.m_v1.y); this.m_coreV2.Set(-e.b2_toiSlop * (this.m_normal.x + this.m_direction.x) + this.m_v2.x, -e.b2_toiSlop * (this.m_normal.y + this.m_direction.y) + this.m_v2.y); this.m_cornerDir1 = this.m_normal; this.m_cornerDir2.Set(-this.m_normal.x, -this.m_normal.y) }; t.prototype.SetPrevEdge = function (n, t, i, r) { this.m_prevEdge = n; this.m_coreV1 = t; this.m_cornerDir1 = i; this.m_cornerConvex1 = r }; t.prototype.SetNextEdge = function (n, t, i, r) { this.m_nextEdge = n; this.m_coreV2 = t; this.m_cornerDir2 = i; this.m_cornerConvex2 = r }; s.b2MassData = function () { this.mass = 0; this.center = new i(0, 0); this.I = 0 }; Box2D.inherit(n, Box2D.Collision.Shapes.b2Shape); n.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype; n.b2PolygonShape = function () { Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments) }; n.prototype.Copy = function () { var t = new n; return t.Set(this), t }; n.prototype.Set = function (t) { if (this.__super.Set.call(this, t), Box2D.is(t, n)) { t = t instanceof n ? t : null; this.m_centroid.SetV(t.m_centroid); this.m_vertexCount = t.m_vertexCount; this.Reserve(this.m_vertexCount); for (var i = 0; i < this.m_vertexCount; i++) this.m_vertices[i].SetV(t.m_vertices[i]), this.m_normals[i].SetV(t.m_normals[i]) } }; n.prototype.SetAsArray = function (n, t) { t === undefined && (t = 0); for (var r = new Vector, i = 0, u, i = 0; i < n.length; ++i) u = n[i], r.push(u); this.SetAsVector(r, t) }; n.AsArray = function (t, i) { i === undefined && (i = 0); var r = new n; return r.SetAsArray(t, i), r }; n.prototype.SetAsVector = function (t, i) { var r, f, o; for (i === undefined && (i = 0), i == 0 && (i = t.length), e.b2Assert(2 <= i), this.m_vertexCount = i, this.Reserve(i), r = 0, r = 0; r < this.m_vertexCount; r++) this.m_vertices[r].SetV(t[r]); for (r = 0; r < this.m_vertexCount; ++r) f = parseInt(r), o = parseInt(r + 1 < this.m_vertexCount ? r + 1 : 0), f = u.SubtractVV(this.m_vertices[o], this.m_vertices[f]), e.b2Assert(f.LengthSquared() > Number.MIN_VALUE), this.m_normals[r].SetV(u.CrossVF(f, 1)), this.m_normals[r].Normalize(); this.m_centroid = n.ComputeCentroid(this.m_vertices, this.m_vertexCount) }; n.AsVector = function (t, i) { i === undefined && (i = 0); var r = new n; return r.SetAsVector(t, i), r }; n.prototype.SetAsBox = function (n, t) { n === undefined && (n = 0); t === undefined && (t = 0); this.m_vertexCount = 4; this.Reserve(4); this.m_vertices[0].Set(-n, -t); this.m_vertices[1].Set(n, -t); this.m_vertices[2].Set(n, t); this.m_vertices[3].Set(-n, t); this.m_normals[0].Set(0, -1); this.m_normals[1].Set(1, 0); this.m_normals[2].Set(0, 1); this.m_normals[3].Set(-1, 0); this.m_centroid.SetZero() }; n.AsBox = function (t, i) { t === undefined && (t = 0); i === undefined && (i = 0); var r = new n; return r.SetAsBox(t, i), r }; n.prototype.SetAsOrientedBox = function (n, t, i, r) { for (n === undefined && (n = 0), t === undefined && (t = 0), i === undefined && (i = null), r === undefined && (r = 0), this.m_vertexCount = 4, this.Reserve(4), this.m_vertices[0].Set(-n, -t), this.m_vertices[1].Set(n, -t), this.m_vertices[2].Set(n, t), this.m_vertices[3].Set(-n, t), this.m_normals[0].Set(0, -1), this.m_normals[1].Set(1, 0), this.m_normals[2].Set(0, 1), this.m_normals[3].Set(-1, 0), this.m_centroid = i, n = new l, n.position = i, n.R.Set(r), i = 0; i < this.m_vertexCount; ++i) this.m_vertices[i] = u.MulX(n, this.m_vertices[i]), this.m_normals[i] = u.MulMV(n.R, this.m_normals[i]) }; n.AsOrientedBox = function (t, i, r, u) { t === undefined && (t = 0); i === undefined && (i = 0); r === undefined && (r = null); u === undefined && (u = 0); var f = new n; return f.SetAsOrientedBox(t, i, r, u), f }; n.prototype.SetAsEdge = function (n, t) { this.m_vertexCount = 2; this.Reserve(2); this.m_vertices[0].SetV(n); this.m_vertices[1].SetV(t); this.m_centroid.x = .5 * (n.x + t.x); this.m_centroid.y = .5 * (n.y + t.y); this.m_normals[0] = u.CrossVF(u.SubtractVV(t, n), 1); this.m_normals[0].Normalize(); this.m_normals[1].x = -this.m_normals[0].x; this.m_normals[1].y = -this.m_normals[0].y }; n.AsEdge = function (t, i) { var r = new n; return r.SetAsEdge(t, i), r }; n.prototype.TestPoint = function (n, t) { for (var i = n.R, r = t.x - n.position.x, u = t.y - n.position.y, e = r * i.col1.x + u * i.col1.y, o = r * i.col2.x + u * i.col2.y, f = 0; f < this.m_vertexCount; ++f) if (i = this.m_vertices[f], r = e - i.x, u = o - i.y, i = this.m_normals[f], i.x * r + i.y * u > 0) return !1; return !0 }; n.prototype.RayCast = function (n, t, i) { var s = 0, c = t.maxFraction, f = 0, u = 0, r, e, l, a, h, o; for (f = t.p1.x - i.position.x, u = t.p1.y - i.position.y, r = i.R, l = f * r.col1.x + u * r.col1.y, a = f * r.col2.x + u * r.col2.y, f = t.p2.x - i.position.x, u = t.p2.y - i.position.y, r = i.R, t = f * r.col1.x + u * r.col1.y - l, r = f * r.col2.x + u * r.col2.y - a, h = parseInt(-1), o = 0; o < this.m_vertexCount; ++o) { if (e = this.m_vertices[o], f = e.x - l, u = e.y - a, e = this.m_normals[o], f = e.x * f + e.y * u, u = e.x * t + e.y * r, u == 0) { if (f < 0) return !1 } else u < 0 && f < s * u ? (s = f / u, h = o) : u > 0 && f < c * u && (c = f / u); if (c < s - Number.MIN_VALUE) return !1 } return h >= 0 ? (n.fraction = s, r = i.R, e = this.m_normals[h], n.normal.x = r.col1.x * e.x + r.col2.x * e.y, n.normal.y = r.col1.y * e.x + r.col2.y * e.y, !0) : !1 }; n.prototype.ComputeAABB = function (n, t) { for (var e, r = t.R, i = this.m_vertices[0], u = t.position.x + (r.col1.x * i.x + r.col2.x * i.y), f = t.position.y + (r.col1.y * i.x + r.col2.y * i.y), o = u, s = f, h = 1; h < this.m_vertexCount; ++h) i = this.m_vertices[h], e = t.position.x + (r.col1.x * i.x + r.col2.x * i.y), i = t.position.y + (r.col1.y * i.x + r.col2.y * i.y), u = u < e ? u : e, f = f < i ? f : i, o = o > e ? o : e, s = s > i ? s : i; n.lowerBound.x = u - this.m_radius; n.lowerBound.y = f - this.m_radius; n.upperBound.x = o + this.m_radius; n.upperBound.y = s + this.m_radius }; n.prototype.ComputeMass = function (n, t) { if (t === undefined && (t = 0), this.m_vertexCount == 2) n.center.x = .5 * (this.m_vertices[0].x + this.m_vertices[1].x), n.center.y = .5 * (this.m_vertices[0].y + this.m_vertices[1].y), n.mass = 0, n.I = 0; else { for (var c = 0, l = 0, o = 0, v = 0, s = 1 / 3, e = 0; e < this.m_vertexCount; ++e) { var i = this.m_vertices[e], h = e + 1 < this.m_vertexCount ? this.m_vertices[parseInt(e + 1)] : this.m_vertices[0], y = i.x - 0, r = i.y - 0, u = h.x - 0, f = h.y - 0, p = y * f - r * u, a = .5 * p; o += a; c += a * s * (0 + i.x + h.x); l += a * s * (0 + i.y + h.y); i = y; r = r; u = u; f = f; v += p * (s * (.25 * (i * i + u * i + u * u) + (0 * i + 0 * u)) + 0 + (s * (.25 * (r * r + f * r + f * f) + (0 * r + 0 * f)) + 0)) } n.mass = t * o; c *= 1 / o; l *= 1 / o; n.center.Set(c, l); n.I = t * v } }; n.prototype.ComputeSubmergedArea = function (n, t, r, f) { var c, v; t === undefined && (t = 0); var a = u.MulTMV(r.R, n), h = t - u.Dot(n, r.position), e = new Vector_a2j_Number, l = 0, o = parseInt(-1); for (t = parseInt(-1), c = !1, n = n = 0; n < this.m_vertexCount; ++n) e[n] = u.Dot(a, this.m_vertices[n]) - h, v = e[n] < -Number.MIN_VALUE, n > 0 && (v ? c || (o = n - 1, l++) : c && (t = n - 1, l++)), c = v; switch (l) { case 0: return c ? (n = new s, this.ComputeMass(n, 1), f.SetV(u.MulX(r, n.center)), n.mass) : 0; case 1: o == -1 ? o = this.m_vertexCount - 1 : t = this.m_vertexCount - 1 } for (n = parseInt((o + 1) % this.m_vertexCount), a = parseInt((t + 1) % this.m_vertexCount), h = (0 - e[o]) / (e[n] - e[o]), e = (0 - e[t]) / (e[a] - e[t]), o = new i(this.m_vertices[o].x * (1 - h) + this.m_vertices[n].x * h, this.m_vertices[o].y * (1 - h) + this.m_vertices[n].y * h), t = new i(this.m_vertices[t].x * (1 - e) + this.m_vertices[a].x * e, this.m_vertices[t].y * (1 - e) + this.m_vertices[a].y * e), e = 0, h = new i, l = this.m_vertices[n], n = n; n != a;) n = (n + 1) % this.m_vertexCount, c = n == a ? t : this.m_vertices[n], v = .5 * ((l.x - o.x) * (c.y - o.y) - (l.y - o.y) * (c.x - o.x)), e += v, h.x += v * (o.x + l.x + c.x) / 3, h.y += v * (o.y + l.y + c.y) / 3, l = c; return h.Multiply(1 / e), f.SetV(u.MulX(r, h)), e }; n.prototype.GetVertexCount = function () { return this.m_vertexCount }; n.prototype.GetVertices = function () { return this.m_vertices }; n.prototype.GetNormals = function () { return this.m_normals }; n.prototype.GetSupport = function (n) { for (var i, r = 0, u = this.m_vertices[0].x * n.x + this.m_vertices[0].y * n.y, t = 1; t < this.m_vertexCount; ++t) i = this.m_vertices[t].x * n.x + this.m_vertices[t].y * n.y, i > u && (r = t, u = i); return r }; n.prototype.GetSupportVertex = function (n) { for (var i, r = 0, u = this.m_vertices[0].x * n.x + this.m_vertices[0].y * n.y, t = 1; t < this.m_vertexCount; ++t) i = this.m_vertices[t].x * n.x + this.m_vertices[t].y * n.y, i > u && (r = t, u = i); return this.m_vertices[r] }; n.prototype.Validate = function () { return !1 }; n.prototype.b2PolygonShape = function () { this.__super.b2Shape.call(this); this.m_type = f.e_polygonShape; this.m_centroid = new i; this.m_vertices = new Vector; this.m_normals = new Vector }; n.prototype.Reserve = function (n) { n === undefined && (n = 0); for (var t = parseInt(this.m_vertices.length) ; t < n; t++) this.m_vertices[t] = new i, this.m_normals[t] = new i }; n.ComputeCentroid = function (n, t) { t === undefined && (t = 0); for (var r = new i, o = 0, h = 1 / 3, u = 0; u < t; ++u) { var f = n[u], e = u + 1 < t ? n[parseInt(u + 1)] : n[0], s = .5 * ((f.x - 0) * (e.y - 0) - (f.y - 0) * (e.x - 0)); o += s; r.x += s * h * (0 + f.x + e.x); r.y += s * h * (0 + f.y + e.y) } return r.x *= 1 / o, r.y *= 1 / o, r }; n.ComputeOBB = function (n, t, i) { var r, u; for (i === undefined && (i = 0), r = 0, u = new Vector(i + 1), r = 0; r < i; ++r) u[r] = t[r]; for (u[i] = u[0], t = Number.MAX_VALUE, r = 1; r <= i; ++r) { var l = u[parseInt(r - 1)], f = u[r].x - l.x, e = u[r].y - l.y, o = Math.sqrt(f * f + e * e); f /= o; e /= o; for (var s = -e, w = f, a = o = Number.MAX_VALUE, v = -Number.MAX_VALUE, y = -Number.MAX_VALUE, h = 0; h < i; ++h) { var c = u[h].x - l.x, b = u[h].y - l.y, p = f * c + e * b; c = s * c + w * b; p < o && (o = p); c < a && (a = c); p > v && (v = p); c > y && (y = c) } h = (v - o) * (y - a); h < .95 * t && (t = h, n.R.col1.x = f, n.R.col1.y = e, n.R.col2.x = s, n.R.col2.y = w, f = .5 * (o + v), e = .5 * (a + y), s = n.R, n.center.x = l.x + (s.col1.x * f + s.col2.x * e), n.center.y = l.y + (s.col1.y * f + s.col2.y * e), n.extents.x = .5 * (v - o), n.extents.y = .5 * (y - a)) } }; Box2D.postDefs.push(function () { Box2D.Collision.Shapes.b2PolygonShape.s_mat = new c }); f.b2Shape = function () { }; f.prototype.Copy = function () { return null }; f.prototype.Set = function (n) { this.m_radius = n.m_radius }; f.prototype.GetType = function () { return this.m_type }; f.prototype.TestPoint = function () { return !1 }; f.prototype.RayCast = function () { return !1 }; f.prototype.ComputeAABB = function () { }; f.prototype.ComputeMass = function () { }; f.prototype.ComputeSubmergedArea = function () { return 0 }; f.TestOverlap = function (n, t, i, r) { var u = new v; return u.proxyA = new h, u.proxyA.Set(n), u.proxyB = new h, u.proxyB.Set(i), u.transformA = t, u.transformB = r, u.useRadii = !0, n = new p, n.count = 0, t = new y, a.Distance(t, n, u), t.distance < 10 * Number.MIN_VALUE }; f.prototype.b2Shape = function () { this.m_type = f.e_unknownShape; this.m_radius = e.b2_linearSlop }; Box2D.postDefs.push(function () { Box2D.Collision.Shapes.b2Shape.e_unknownShape = parseInt(-1); Box2D.Collision.Shapes.b2Shape.e_circleShape = 0; Box2D.Collision.Shapes.b2Shape.e_polygonShape = 1; Box2D.Collision.Shapes.b2Shape.e_edgeShape = 2; Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount = 3; Box2D.Collision.Shapes.b2Shape.e_hitCollide = 1; Box2D.Collision.Shapes.b2Shape.e_missCollide = 0; Box2D.Collision.Shapes.b2Shape.e_startsInsideCollide = parseInt(-1) }) }(), function () { var i = Box2D.Common.b2Color, n = Box2D.Common.b2Settings, t = Box2D.Common.Math.b2Math; i.b2Color = function () { this._b = this._g = this._r = 0 }; i.prototype.b2Color = function (n, i, r) { n === undefined && (n = 0); i === undefined && (i = 0); r === undefined && (r = 0); this._r = Box2D.parseUInt(255 * t.Clamp(n, 0, 1)); this._g = Box2D.parseUInt(255 * t.Clamp(i, 0, 1)); this._b = Box2D.parseUInt(255 * t.Clamp(r, 0, 1)) }; i.prototype.Set = function (n, i, r) { n === undefined && (n = 0); i === undefined && (i = 0); r === undefined && (r = 0); this._r = Box2D.parseUInt(255 * t.Clamp(n, 0, 1)); this._g = Box2D.parseUInt(255 * t.Clamp(i, 0, 1)); this._b = Box2D.parseUInt(255 * t.Clamp(r, 0, 1)) }; Object.defineProperty(i.prototype, "r", { enumerable: !1, configurable: !0, set: function (n) { n === undefined && (n = 0); this._r = Box2D.parseUInt(255 * t.Clamp(n, 0, 1)) } }); Object.defineProperty(i.prototype, "g", { enumerable: !1, configurable: !0, set: function (n) { n === undefined && (n = 0); this._g = Box2D.parseUInt(255 * t.Clamp(n, 0, 1)) } }); Object.defineProperty(i.prototype, "b", { enumerable: !1, configurable: !0, set: function (n) { n === undefined && (n = 0); this._b = Box2D.parseUInt(255 * t.Clamp(n, 0, 1)) } }); Object.defineProperty(i.prototype, "color", { enumerable: !1, configurable: !0, get: function () { return this._r << 16 | this._g << 8 | this._b } }); n.b2Settings = function () { }; n.b2MixFriction = function (n, t) { return n === undefined && (n = 0), t === undefined && (t = 0), Math.sqrt(n * t) }; n.b2MixRestitution = function (n, t) { return n === undefined && (n = 0), t === undefined && (t = 0), n > t ? n : t }; n.b2Assert = function (n) { if (!n) throw "Assertion Failed"; }; Box2D.postDefs.push(function () { Box2D.Common.b2Settings.VERSION = "2.1alpha"; Box2D.Common.b2Settings.USHRT_MAX = 65535; Box2D.Common.b2Settings.b2_pi = Math.PI; Box2D.Common.b2Settings.b2_maxManifoldPoints = 2; Box2D.Common.b2Settings.b2_aabbExtension = .1; Box2D.Common.b2Settings.b2_aabbMultiplier = 2; Box2D.Common.b2Settings.b2_polygonRadius = 2 * n.b2_linearSlop; Box2D.Common.b2Settings.b2_linearSlop = .005; Box2D.Common.b2Settings.b2_angularSlop = 2 / 180 * n.b2_pi; Box2D.Common.b2Settings.b2_toiSlop = 8 * n.b2_linearSlop; Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland = 32; Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland = 32; Box2D.Common.b2Settings.b2_velocityThreshold = 1; Box2D.Common.b2Settings.b2_maxLinearCorrection = .2; Box2D.Common.b2Settings.b2_maxAngularCorrection = 8 / 180 * n.b2_pi; Box2D.Common.b2Settings.b2_maxTranslation = 2; Box2D.Common.b2Settings.b2_maxTranslationSquared = n.b2_maxTranslation * n.b2_maxTranslation; Box2D.Common.b2Settings.b2_maxRotation = .5 * n.b2_pi; Box2D.Common.b2Settings.b2_maxRotationSquared = n.b2_maxRotation * n.b2_maxRotation; Box2D.Common.b2Settings.b2_contactBaumgarte = .2; Box2D.Common.b2Settings.b2_timeToSleep = .5; Box2D.Common.b2Settings.b2_linearSleepTolerance = .01; Box2D.Common.b2Settings.b2_angularSleepTolerance = 2 / 180 * n.b2_pi }) }(), function () { var i = Box2D.Common.Math.b2Mat22, u = Box2D.Common.Math.b2Mat33, n = Box2D.Common.Math.b2Math, e = Box2D.Common.Math.b2Sweep, f = Box2D.Common.Math.b2Transform, t = Box2D.Common.Math.b2Vec2, r = Box2D.Common.Math.b2Vec3; i.b2Mat22 = function () { this.col1 = new t; this.col2 = new t }; i.prototype.b2Mat22 = function () { this.SetIdentity() }; i.FromAngle = function (n) { n === undefined && (n = 0); var t = new i; return t.Set(n), t }; i.FromVV = function (n, t) { var r = new i; return r.SetVV(n, t), r }; i.prototype.Set = function (n) { n === undefined && (n = 0); var t = Math.cos(n); n = Math.sin(n); this.col1.x = t; this.col2.x = -n; this.col1.y = n; this.col2.y = t }; i.prototype.SetVV = function (n, t) { this.col1.SetV(n); this.col2.SetV(t) }; i.prototype.Copy = function () { var n = new i; return n.SetM(this), n }; i.prototype.SetM = function (n) { this.col1.SetV(n.col1); this.col2.SetV(n.col2) }; i.prototype.AddM = function (n) { this.col1.x += n.col1.x; this.col1.y += n.col1.y; this.col2.x += n.col2.x; this.col2.y += n.col2.y }; i.prototype.SetIdentity = function () { this.col1.x = 1; this.col2.x = 0; this.col1.y = 0; this.col2.y = 1 }; i.prototype.SetZero = function () { this.col1.x = 0; this.col2.x = 0; this.col1.y = 0; this.col2.y = 0 }; i.prototype.GetAngle = function () { return Math.atan2(this.col1.y, this.col1.x) }; i.prototype.GetInverse = function (n) { var i = this.col1.x, r = this.col2.x, u = this.col1.y, f = this.col2.y, t = i * f - r * u; return t != 0 && (t = 1 / t), n.col1.x = t * f, n.col2.x = -t * r, n.col1.y = -t * u, n.col2.y = t * i, n }; i.prototype.Solve = function (n, t, i) { t === undefined && (t = 0); i === undefined && (i = 0); var u = this.col1.x, f = this.col2.x, e = this.col1.y, o = this.col2.y, r = u * o - f * e; return r != 0 && (r = 1 / r), n.x = r * (o * t - f * i), n.y = r * (u * i - e * t), n }; i.prototype.Abs = function () { this.col1.Abs(); this.col2.Abs() }; u.b2Mat33 = function () { this.col1 = new r; this.col2 = new r; this.col3 = new r }; u.prototype.b2Mat33 = function (n, t, i) { n === undefined && (n = null); t === undefined && (t = null); i === undefined && (i = null); n || t || i ? (this.col1.SetV(n), this.col2.SetV(t), this.col3.SetV(i)) : (this.col1.SetZero(), this.col2.SetZero(), this.col3.SetZero()) }; u.prototype.SetVVV = function (n, t, i) { this.col1.SetV(n); this.col2.SetV(t); this.col3.SetV(i) }; u.prototype.Copy = function () { return new u(this.col1, this.col2, this.col3) }; u.prototype.SetM = function (n) { this.col1.SetV(n.col1); this.col2.SetV(n.col2); this.col3.SetV(n.col3) }; u.prototype.AddM = function (n) { this.col1.x += n.col1.x; this.col1.y += n.col1.y; this.col1.z += n.col1.z; this.col2.x += n.col2.x; this.col2.y += n.col2.y; this.col2.z += n.col2.z; this.col3.x += n.col3.x; this.col3.y += n.col3.y; this.col3.z += n.col3.z }; u.prototype.SetIdentity = function () { this.col1.x = 1; this.col2.x = 0; this.col3.x = 0; this.col1.y = 0; this.col2.y = 1; this.col3.y = 0; this.col1.z = 0; this.col2.z = 0; this.col3.z = 1 }; u.prototype.SetZero = function () { this.col1.x = 0; this.col2.x = 0; this.col3.x = 0; this.col1.y = 0; this.col2.y = 0; this.col3.y = 0; this.col1.z = 0; this.col2.z = 0; this.col3.z = 0 }; u.prototype.Solve22 = function (n, t, i) { t === undefined && (t = 0); i === undefined && (i = 0); var u = this.col1.x, f = this.col2.x, e = this.col1.y, o = this.col2.y, r = u * o - f * e; return r != 0 && (r = 1 / r), n.x = r * (o * t - f * i), n.y = r * (u * i - e * t), n }; u.prototype.Solve33 = function (n, t, i, r) { t === undefined && (t = 0); i === undefined && (i = 0); r === undefined && (r = 0); var l = this.col1.x, a = this.col1.y, v = this.col1.z, u = this.col2.x, f = this.col2.y, e = this.col2.z, o = this.col3.x, s = this.col3.y, h = this.col3.z, c = l * (f * h - e * s) + a * (e * o - u * h) + v * (u * s - f * o); return c != 0 && (c = 1 / c), n.x = c * (t * (f * h - e * s) + i * (e * o - u * h) + r * (u * s - f * o)), n.y = c * (l * (i * h - r * s) + a * (r * o - t * h) + v * (t * s - i * o)), n.z = c * (l * (f * r - e * i) + a * (e * t - u * r) + v * (u * i - f * t)), n }; n.b2Math = function () { }; n.IsValid = function (n) { return n === undefined && (n = 0), isFinite(n) }; n.Dot = function (n, t) { return n.x * t.x + n.y * t.y }; n.CrossVV = function (n, t) { return n.x * t.y - n.y * t.x }; n.CrossVF = function (n, i) { return i === undefined && (i = 0), new t(i * n.y, -i * n.x) }; n.CrossFV = function (n, i) { return n === undefined && (n = 0), new t(-n * i.y, n * i.x) }; n.MulMV = function (n, i) { return new t(n.col1.x * i.x + n.col2.x * i.y, n.col1.y * i.x + n.col2.y * i.y) }; n.MulTMV = function (i, r) { return new t(n.Dot(r, i.col1), n.Dot(r, i.col2)) }; n.MulX = function (t, i) { var r = n.MulMV(t.R, i); return r.x += t.position.x, r.y += t.position.y, r }; n.MulXT = function (t, i) { var r = n.SubtractVV(i, t.position), u = r.x * t.R.col1.x + r.y * t.R.col1.y; return r.y = r.x * t.R.col2.x + r.y * t.R.col2.y, r.x = u, r }; n.AddVV = function (n, i) { return new t(n.x + i.x, n.y + i.y) }; n.SubtractVV = function (n, i) { return new t(n.x - i.x, n.y - i.y) }; n.Distance = function (n, t) { var i = n.x - t.x, r = n.y - t.y; return Math.sqrt(i * i + r * r) }; n.DistanceSquared = function (n, t) { var i = n.x - t.x, r = n.y - t.y; return i * i + r * r }; n.MulFV = function (n, i) { return n === undefined && (n = 0), new t(n * i.x, n * i.y) }; n.AddMM = function (t, r) { return i.FromVV(n.AddVV(t.col1, r.col1), n.AddVV(t.col2, r.col2)) }; n.MulMM = function (t, r) { return i.FromVV(n.MulMV(t, r.col1), n.MulMV(t, r.col2)) }; n.MulTMM = function (r, u) { var f = new t(n.Dot(r.col1, u.col1), n.Dot(r.col2, u.col1)), e = new t(n.Dot(r.col1, u.col2), n.Dot(r.col2, u.col2)); return i.FromVV(f, e) }; n.Abs = function (n) { return n === undefined && (n = 0), n > 0 ? n : -n }; n.AbsV = function (i) { return new t(n.Abs(i.x), n.Abs(i.y)) }; n.AbsM = function (t) { return i.FromVV(n.AbsV(t.col1), n.AbsV(t.col2)) }; n.Min = function (n, t) { return n === undefined && (n = 0), t === undefined && (t = 0), n < t ? n : t }; n.MinV = function (i, r) { return new t(n.Min(i.x, r.x), n.Min(i.y, r.y)) }; n.Max = function (n, t) { return n === undefined && (n = 0), t === undefined && (t = 0), n > t ? n : t }; n.MaxV = function (i, r) { return new t(n.Max(i.x, r.x), n.Max(i.y, r.y)) }; n.Clamp = function (n, t, i) { return n === undefined && (n = 0), t === undefined && (t = 0), i === undefined && (i = 0), n < t ? t : n > i ? i : n }; n.ClampV = function (t, i, r) { return n.MaxV(i, n.MinV(t, r)) }; n.Swap = function (n, t) { var i = n[0]; n[0] = t[0]; t[0] = i }; n.Random = function () { return Math.random() * 2 - 1 }; n.RandomRange = function (n, t) { n === undefined && (n = 0); t === undefined && (t = 0); var i = Math.random(); return (t - n) * i + n }; n.NextPowerOfTwo = function (n) { return n === undefined && (n = 0), n |= n >> 1 & 2147483647, n |= n >> 2 & 1073741823, n |= n >> 4 & 268435455, n |= n >> 8 & 16777215, n |= n >> 16 & 65535, n + 1 }; n.IsPowerOfTwo = function (n) { return n === undefined && (n = 0), n > 0 && (n & n - 1) == 0 }; Box2D.postDefs.push(function () { Box2D.Common.Math.b2Math.b2Vec2_zero = new t(0, 0); Box2D.Common.Math.b2Math.b2Mat22_identity = i.FromVV(new t(1, 0), new t(0, 1)); Box2D.Common.Math.b2Math.b2Transform_identity = new f(n.b2Vec2_zero, n.b2Mat22_identity) }); e.b2Sweep = function () { this.localCenter = new t; this.c0 = new t; this.c = new t }; e.prototype.Set = function (n) { this.localCenter.SetV(n.localCenter); this.c0.SetV(n.c0); this.c.SetV(n.c); this.a0 = n.a0; this.a = n.a; this.t0 = n.t0 }; e.prototype.Copy = function () { var n = new e; return n.localCenter.SetV(this.localCenter), n.c0.SetV(this.c0), n.c.SetV(this.c), n.a0 = this.a0, n.a = this.a, n.t0 = this.t0, n }; e.prototype.GetTransform = function (n, t) { t === undefined && (t = 0); n.position.x = (1 - t) * this.c0.x + t * this.c.x; n.position.y = (1 - t) * this.c0.y + t * this.c.y; n.R.Set((1 - t) * this.a0 + t * this.a); var i = n.R; n.position.x -= i.col1.x * this.localCenter.x + i.col2.x * this.localCenter.y; n.position.y -= i.col1.y * this.localCenter.x + i.col2.y * this.localCenter.y }; e.prototype.Advance = function (n) { if (n === undefined && (n = 0), this.t0 < n && 1 - this.t0 > Number.MIN_VALUE) { var t = (n - this.t0) / (1 - this.t0); this.c0.x = (1 - t) * this.c0.x + t * this.c.x; this.c0.y = (1 - t) * this.c0.y + t * this.c.y; this.a0 = (1 - t) * this.a0 + t * this.a; this.t0 = n } }; f.b2Transform = function () { this.position = new t; this.R = new i }; f.prototype.b2Transform = function (n, t) { n === undefined && (n = null); t === undefined && (t = null); n && (this.position.SetV(n), this.R.SetM(t)) }; f.prototype.Initialize = function (n, t) { this.position.SetV(n); this.R.SetM(t) }; f.prototype.SetIdentity = function () { this.position.SetZero(); this.R.SetIdentity() }; f.prototype.Set = function (n) { this.position.SetV(n.position); this.R.SetM(n.R) }; f.prototype.GetAngle = function () { return Math.atan2(this.R.col1.y, this.R.col1.x) }; t.b2Vec2 = function () { }; t.prototype.b2Vec2 = function (n, t) { n === undefined && (n = 0); t === undefined && (t = 0); this.x = n; this.y = t }; t.prototype.SetZero = function () { this.y = this.x = 0 }; t.prototype.Set = function (n, t) { n === undefined && (n = 0); t === undefined && (t = 0); this.x = n; this.y = t }; t.prototype.SetV = function (n) { this.x = n.x; this.y = n.y }; t.prototype.GetNegative = function () { return new t(-this.x, -this.y) }; t.prototype.NegativeSelf = function () { this.x = -this.x; this.y = -this.y }; t.Make = function (n, i) { return n === undefined && (n = 0), i === undefined && (i = 0), new t(n, i) }; t.prototype.Copy = function () { return new t(this.x, this.y) }; t.prototype.Add = function (n) { this.x += n.x; this.y += n.y }; t.prototype.Subtract = function (n) { this.x -= n.x; this.y -= n.y }; t.prototype.Multiply = function (n) { n === undefined && (n = 0); this.x *= n; this.y *= n }; t.prototype.MulM = function (n) { var t = this.x; this.x = n.col1.x * t + n.col2.x * this.y; this.y = n.col1.y * t + n.col2.y * this.y }; t.prototype.MulTM = function (t) { var i = n.Dot(this, t.col1); this.y = n.Dot(this, t.col2); this.x = i }; t.prototype.CrossVF = function (n) { n === undefined && (n = 0); var t = this.x; this.x = n * this.y; this.y = -n * t }; t.prototype.CrossFV = function (n) { n === undefined && (n = 0); var t = this.x; this.x = -n * this.y; this.y = n * t }; t.prototype.MinV = function (n) { this.x = this.x < n.x ? this.x : n.x; this.y = this.y < n.y ? this.y : n.y }; t.prototype.MaxV = function (n) { this.x = this.x > n.x ? this.x : n.x; this.y = this.y > n.y ? this.y : n.y }; t.prototype.Abs = function () { this.x < 0 && (this.x = -this.x); this.y < 0 && (this.y = -this.y) }; t.prototype.Length = function () { return Math.sqrt(this.x * this.x + this.y * this.y) }; t.prototype.LengthSquared = function () { return this.x * this.x + this.y * this.y }; t.prototype.Normalize = function () { var n = Math.sqrt(this.x * this.x + this.y * this.y), t; return n < Number.MIN_VALUE ? 0 : (t = 1 / n, this.x *= t, this.y *= t, n) }; t.prototype.IsValid = function () { return n.IsValid(this.x) && n.IsValid(this.y) }; r.b2Vec3 = function () { }; r.prototype.b2Vec3 = function (n, t, i) { n === undefined && (n = 0); t === undefined && (t = 0); i === undefined && (i = 0); this.x = n; this.y = t; this.z = i }; r.prototype.SetZero = function () { this.x = this.y = this.z = 0 }; r.prototype.Set = function (n, t, i) { n === undefined && (n = 0); t === undefined && (t = 0); i === undefined && (i = 0); this.x = n; this.y = t; this.z = i }; r.prototype.SetV = function (n) { this.x = n.x; this.y = n.y; this.z = n.z }; r.prototype.GetNegative = function () { return new r(-this.x, -this.y, -this.z) }; r.prototype.NegativeSelf = function () { this.x = -this.x; this.y = -this.y; this.z = -this.z }; r.prototype.Copy = function () { return new r(this.x, this.y, this.z) }; r.prototype.Add = function (n) { this.x += n.x; this.y += n.y; this.z += n.z }; r.prototype.Subtract = function (n) { this.x -= n.x; this.y -= n.y; this.z -= n.z }; r.prototype.Multiply = function (n) { n === undefined && (n = 0); this.x *= n; this.y *= n; this.z *= n } }(), function () { var f = Box2D.Common.Math.b2Math, d = Box2D.Common.Math.b2Sweep, p = Box2D.Common.Math.b2Transform, e = Box2D.Common.Math.b2Vec2, tt = Box2D.Common.b2Color, r = Box2D.Common.b2Settings, h = Box2D.Collision.b2AABB, rt = Box2D.Collision.b2ContactPoint, ut = Box2D.Collision.b2DynamicTreeBroadPhase, ft = Box2D.Collision.b2RayCastInput, et = Box2D.Collision.b2RayCastOutput, ot = Box2D.Collision.Shapes.b2CircleShape, st = Box2D.Collision.Shapes.b2EdgeShape, ht = Box2D.Collision.Shapes.b2MassData, ct = Box2D.Collision.Shapes.b2PolygonShape, w = Box2D.Collision.Shapes.b2Shape, n = Box2D.Dynamics.b2Body, b = Box2D.Dynamics.b2BodyDef, a = Box2D.Dynamics.b2ContactFilter, it = Box2D.Dynamics.b2ContactImpulse, c = Box2D.Dynamics.b2ContactListener, l = Box2D.Dynamics.b2ContactManager, u = Box2D.Dynamics.b2DebugDraw, g = Box2D.Dynamics.b2DestructionListener, v = Box2D.Dynamics.b2FilterData, i = Box2D.Dynamics.b2Fixture, nt = Box2D.Dynamics.b2FixtureDef, s = Box2D.Dynamics.b2Island, k = Box2D.Dynamics.b2TimeStep, t = Box2D.Dynamics.b2World, o = Box2D.Dynamics.Contacts.b2Contact, lt = Box2D.Dynamics.Contacts.b2ContactFactory, at = Box2D.Dynamics.Contacts.b2ContactSolver, y = Box2D.Dynamics.Joints.b2Joint, vt = Box2D.Dynamics.Joints.b2PulleyJoint; n.b2Body = function () { this.m_xf = new p; this.m_sweep = new d; this.m_linearVelocity = new e; this.m_force = new e }; n.prototype.connectEdges = function (n, t, i) { var e, u, o; return i === undefined && (i = 0), e = Math.atan2(t.GetDirectionVector().y, t.GetDirectionVector().x), i = f.MulFV(Math.tan((e - i) * .5), t.GetDirectionVector()), i = f.SubtractVV(i, t.GetNormalVector()), i = f.MulFV(r.b2_toiSlop, i), i = f.AddVV(i, t.GetVertex1()), u = f.AddVV(n.GetDirectionVector(), t.GetDirectionVector()), u.Normalize(), o = f.Dot(n.GetDirectionVector(), t.GetNormalVector()) > 0, n.SetNextEdge(t, i, u, o), t.SetPrevEdge(n, i, u, o), e }; n.prototype.CreateFixture = function (r) { if (this.m_world.IsLocked() == !0) return null; var u = new i; return u.Create(this, this.m_xf, r), this.m_flags & n.e_activeFlag && u.CreateProxy(this.m_world.m_contactManager.m_broadPhase, this.m_xf), u.m_next = this.m_fixtureList, this.m_fixtureList = u, ++this.m_fixtureCount, u.m_body = this, u.m_density > 0 && this.ResetMassData(), this.m_world.m_flags |= t.e_newFixture, u }; n.prototype.CreateFixture2 = function (n, t) { t === undefined && (t = 0); var i = new nt; return i.shape = n, i.density = t, this.CreateFixture(i) }; n.prototype.DestroyFixture = function (t) { var i, r, u, f; if (this.m_world.IsLocked() != !0) { for (i = this.m_fixtureList, r = null; i != null;) { if (i == t) { r ? r.m_next = t.m_next : this.m_fixtureList = t.m_next; break } r = i; i = i.m_next } for (i = this.m_contactList; i;) r = i.contact, i = i.next, u = r.GetFixtureA(), f = r.GetFixtureB(), (t == u || t == f) && this.m_world.m_contactManager.Destroy(r); this.m_flags & n.e_activeFlag && t.DestroyProxy(this.m_world.m_contactManager.m_broadPhase); t.Destroy(); t.m_body = null; t.m_next = null; --this.m_fixtureCount; this.ResetMassData() } }; n.prototype.SetPositionAndAngle = function (n, t) { var i, r; if (t === undefined && (t = 0), this.m_world.IsLocked() != !0) { for (this.m_xf.R.Set(t), this.m_xf.position.SetV(n), i = this.m_xf.R, r = this.m_sweep.localCenter, this.m_sweep.c.x = i.col1.x * r.x + i.col2.x * r.y, this.m_sweep.c.y = i.col1.y * r.x + i.col2.y * r.y, this.m_sweep.c.x += this.m_xf.position.x, this.m_sweep.c.y += this.m_xf.position.y, this.m_sweep.c0.SetV(this.m_sweep.c), this.m_sweep.a0 = this.m_sweep.a = t, r = this.m_world.m_contactManager.m_broadPhase, i = this.m_fixtureList; i; i = i.m_next) i.Synchronize(r, this.m_xf, this.m_xf); this.m_world.m_contactManager.FindNewContacts() } }; n.prototype.SetTransform = function (n) { this.SetPositionAndAngle(n.position, n.GetAngle()) }; n.prototype.GetTransform = function () { return this.m_xf }; n.prototype.GetPosition = function () { return this.m_xf.position }; n.prototype.SetPosition = function (n) { this.SetPositionAndAngle(n, this.GetAngle()) }; n.prototype.GetAngle = function () { return this.m_sweep.a }; n.prototype.SetAngle = function (n) { n === undefined && (n = 0); this.SetPositionAndAngle(this.GetPosition(), n) }; n.prototype.GetWorldCenter = function () { return this.m_sweep.c }; n.prototype.GetLocalCenter = function () { return this.m_sweep.localCenter }; n.prototype.SetLinearVelocity = function (t) { this.m_type != n.b2_staticBody && this.m_linearVelocity.SetV(t) }; n.prototype.GetLinearVelocity = function () { return this.m_linearVelocity }; n.prototype.SetAngularVelocity = function (t) { t === undefined && (t = 0); this.m_type != n.b2_staticBody && (this.m_angularVelocity = t) }; n.prototype.GetAngularVelocity = function () { return this.m_angularVelocity }; n.prototype.GetDefinition = function () { var t = new b; return t.type = this.GetType(), t.allowSleep = (this.m_flags & n.e_allowSleepFlag) == n.e_allowSleepFlag, t.angle = this.GetAngle(), t.angularDamping = this.m_angularDamping, t.angularVelocity = this.m_angularVelocity, t.fixedRotation = (this.m_flags & n.e_fixedRotationFlag) == n.e_fixedRotationFlag, t.bullet = (this.m_flags & n.e_bulletFlag) == n.e_bulletFlag, t.awake = (this.m_flags & n.e_awakeFlag) == n.e_awakeFlag, t.linearDamping = this.m_linearDamping, t.linearVelocity.SetV(this.GetLinearVelocity()), t.position = this.GetPosition(), t.userData = this.GetUserData(), t }; n.prototype.ApplyForce = function (t, i) { this.m_type == n.b2_dynamicBody && (this.IsAwake() == !1 && this.SetAwake(!0), this.m_force.x += t.x, this.m_force.y += t.y, this.m_torque += (i.x - this.m_sweep.c.x) * t.y - (i.y - this.m_sweep.c.y) * t.x) }; n.prototype.ApplyTorque = function (t) { t === undefined && (t = 0); this.m_type == n.b2_dynamicBody && (this.IsAwake() == !1 && this.SetAwake(!0), this.m_torque += t) }; n.prototype.ApplyImpulse = function (t, i) { this.m_type == n.b2_dynamicBody && (this.IsAwake() == !1 && this.SetAwake(!0), this.m_linearVelocity.x += this.m_invMass * t.x, this.m_linearVelocity.y += this.m_invMass * t.y, this.m_angularVelocity += this.m_invI * ((i.x - this.m_sweep.c.x) * t.y - (i.y - this.m_sweep.c.y) * t.x)) }; n.prototype.Split = function (n) { for (var o, u = this.GetLinearVelocity().Copy(), e = this.GetAngularVelocity(), s = this.GetWorldCenter(), t = this.m_world.CreateBody(this.GetDefinition()), r, i = this.m_fixtureList; i;) n(i) ? (o = i.m_next, r ? r.m_next = o : this.m_fixtureList = o, this.m_fixtureCount--, i.m_next = t.m_fixtureList, t.m_fixtureList = i, t.m_fixtureCount++, i.m_body = t, i = o) : (r = i, i = i.m_next); return this.ResetMassData(), t.ResetMassData(), r = this.GetWorldCenter(), n = t.GetWorldCenter(), r = f.AddVV(u, f.CrossFV(e, f.SubtractVV(r, s))), u = f.AddVV(u, f.CrossFV(e, f.SubtractVV(n, s))), this.SetLinearVelocity(r), t.SetLinearVelocity(u), this.SetAngularVelocity(e), t.SetAngularVelocity(e), this.SynchronizeFixtures(), t.SynchronizeFixtures(), t }; n.prototype.Merge = function (n) { for (var u, i, r, t = n.m_fixtureList; t;) u = t.m_next, n.m_fixtureCount--, t.m_next = this.m_fixtureList, this.m_fixtureList = t, this.m_fixtureCount++, t.m_body = r, t = u; i.m_fixtureCount = 0; i = this; r = n; i.GetWorldCenter(); r.GetWorldCenter(); i.GetLinearVelocity().Copy(); r.GetLinearVelocity().Copy(); i.GetAngularVelocity(); r.GetAngularVelocity(); i.ResetMassData(); this.SynchronizeFixtures() }; n.prototype.GetMass = function () { return this.m_mass }; n.prototype.GetInertia = function () { return this.m_I }; n.prototype.GetMassData = function (n) { n.mass = this.m_mass; n.I = this.m_I; n.center.SetV(this.m_sweep.localCenter) }; n.prototype.SetMassData = function (t) { if (r.b2Assert(this.m_world.IsLocked() == !1), this.m_world.IsLocked() != !0 && this.m_type == n.b2_dynamicBody) { this.m_invI = this.m_I = this.m_invMass = 0; this.m_mass = t.mass; this.m_mass <= 0 && (this.m_mass = 1); this.m_invMass = 1 / this.m_mass; t.I > 0 && (this.m_flags & n.e_fixedRotationFlag) == 0 && (this.m_I = t.I - this.m_mass * (t.center.x * t.center.x + t.center.y * t.center.y), this.m_invI = 1 / this.m_I); var i = this.m_sweep.c.Copy(); this.m_sweep.localCenter.SetV(t.center); this.m_sweep.c0.SetV(f.MulX(this.m_xf, this.m_sweep.localCenter)); this.m_sweep.c.SetV(this.m_sweep.c0); this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - i.y); this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - i.x) } }; n.prototype.ResetMassData = function () { var t, i, u; if (this.m_invI = this.m_I = this.m_invMass = this.m_mass = 0, this.m_sweep.localCenter.SetZero(), !(this.m_type == n.b2_staticBody || this.m_type == n.b2_kinematicBody)) { for (t = e.Make(0, 0), i = this.m_fixtureList; i; i = i.m_next) i.m_density != 0 && (u = i.GetMassData(), this.m_mass += u.mass, t.x += u.center.x * u.mass, t.y += u.center.y * u.mass, this.m_I += u.I); this.m_mass > 0 ? (this.m_invMass = 1 / this.m_mass, t.x *= this.m_invMass, t.y *= this.m_invMass) : this.m_invMass = this.m_mass = 1; this.m_I > 0 && (this.m_flags & n.e_fixedRotationFlag) == 0 ? (this.m_I -= this.m_mass * (t.x * t.x + t.y * t.y), this.m_I *= this.m_inertiaScale, r.b2Assert(this.m_I > 0), this.m_invI = 1 / this.m_I) : this.m_invI = this.m_I = 0; i = this.m_sweep.c.Copy(); this.m_sweep.localCenter.SetV(t); this.m_sweep.c0.SetV(f.MulX(this.m_xf, this.m_sweep.localCenter)); this.m_sweep.c.SetV(this.m_sweep.c0); this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - i.y); this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - i.x) } }; n.prototype.GetWorldPoint = function (n) { var t = this.m_xf.R; return n = new e(t.col1.x * n.x + t.col2.x * n.y, t.col1.y * n.x + t.col2.y * n.y), n.x += this.m_xf.position.x, n.y += this.m_xf.position.y, n }; n.prototype.GetWorldVector = function (n) { return f.MulMV(this.m_xf.R, n) }; n.prototype.GetLocalPoint = function (n) { return f.MulXT(this.m_xf, n) }; n.prototype.GetLocalVector = function (n) { return f.MulTMV(this.m_xf.R, n) }; n.prototype.GetLinearVelocityFromWorldPoint = function (n) { return new e(this.m_linearVelocity.x - this.m_angularVelocity * (n.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (n.x - this.m_sweep.c.x)) }; n.prototype.GetLinearVelocityFromLocalPoint = function (n) { var t = this.m_xf.R; return n = new e(t.col1.x * n.x + t.col2.x * n.y, t.col1.y * n.x + t.col2.y * n.y), n.x += this.m_xf.position.x, n.y += this.m_xf.position.y, new e(this.m_linearVelocity.x - this.m_angularVelocity * (n.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (n.x - this.m_sweep.c.x)) }; n.prototype.GetLinearDamping = function () { return this.m_linearDamping }; n.prototype.SetLinearDamping = function (n) { n === undefined && (n = 0); this.m_linearDamping = n }; n.prototype.GetAngularDamping = function () { return this.m_angularDamping }; n.prototype.SetAngularDamping = function (n) { n === undefined && (n = 0); this.m_angularDamping = n }; n.prototype.SetType = function (t) { if (t === undefined && (t = 0), this.m_type != t) for (this.m_type = t, this.ResetMassData(), this.m_type == n.b2_staticBody && (this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0), this.SetAwake(!0), this.m_force.SetZero(), this.m_torque = 0, t = this.m_contactList; t; t = t.next) t.contact.FlagForFiltering() }; n.prototype.GetType = function () { return this.m_type }; n.prototype.SetBullet = function (t) { t ? this.m_flags |= n.e_bulletFlag : this.m_flags &= ~n.e_bulletFlag }; n.prototype.IsBullet = function () { return (this.m_flags & n.e_bulletFlag) == n.e_bulletFlag }; n.prototype.SetSleepingAllowed = function (t) { t ? this.m_flags |= n.e_allowSleepFlag : (this.m_flags &= ~n.e_allowSleepFlag, this.SetAwake(!0)) }; n.prototype.SetAwake = function (t) { t ? (this.m_flags |= n.e_awakeFlag, this.m_sleepTime = 0) : (this.m_flags &= ~n.e_awakeFlag, this.m_sleepTime = 0, this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_force.SetZero(), this.m_torque = 0) }; n.prototype.IsAwake = function () { return (this.m_flags & n.e_awakeFlag) == n.e_awakeFlag }; n.prototype.SetFixedRotation = function (t) { t ? this.m_flags |= n.e_fixedRotationFlag : this.m_flags &= ~n.e_fixedRotationFlag; this.ResetMassData() }; n.prototype.IsFixedRotation = function () { return (this.m_flags & n.e_fixedRotationFlag) == n.e_fixedRotationFlag }; n.prototype.SetActive = function (t) { if (t != this.IsActive()) { var i; if (t) for (this.m_flags |= n.e_activeFlag, t = this.m_world.m_contactManager.m_broadPhase, i = this.m_fixtureList; i; i = i.m_next) i.CreateProxy(t, this.m_xf); else { for (this.m_flags &= ~n.e_activeFlag, t = this.m_world.m_contactManager.m_broadPhase, i = this.m_fixtureList; i; i = i.m_next) i.DestroyProxy(t); for (t = this.m_contactList; t;) i = t, t = t.next, this.m_world.m_contactManager.Destroy(i.contact); this.m_contactList = null } } }; n.prototype.IsActive = function () { return (this.m_flags & n.e_activeFlag) == n.e_activeFlag }; n.prototype.IsSleepingAllowed = function () { return (this.m_flags & n.e_allowSleepFlag) == n.e_allowSleepFlag }; n.prototype.GetFixtureList = function () { return this.m_fixtureList }; n.prototype.GetJointList = function () { return this.m_jointList }; n.prototype.GetControllerList = function () { return this.m_controllerList }; n.prototype.GetContactList = function () { return this.m_contactList }; n.prototype.GetNext = function () { return this.m_next }; n.prototype.GetUserData = function () { return this.m_userData }; n.prototype.SetUserData = function (n) { this.m_userData = n }; n.prototype.GetWorld = function () { return this.m_world }; n.prototype.b2Body = function (t, i) { this.m_flags = 0; t.bullet && (this.m_flags |= n.e_bulletFlag); t.fixedRotation && (this.m_flags |= n.e_fixedRotationFlag); t.allowSleep && (this.m_flags |= n.e_allowSleepFlag); t.awake && (this.m_flags |= n.e_awakeFlag); t.active && (this.m_flags |= n.e_activeFlag); this.m_world = i; this.m_xf.position.SetV(t.position); this.m_xf.R.Set(t.angle); this.m_sweep.localCenter.SetZero(); this.m_sweep.t0 = 1; this.m_sweep.a0 = this.m_sweep.a = t.angle; var r = this.m_xf.R, u = this.m_sweep.localCenter; this.m_sweep.c.x = r.col1.x * u.x + r.col2.x * u.y; this.m_sweep.c.y = r.col1.y * u.x + r.col2.y * u.y; this.m_sweep.c.x += this.m_xf.position.x; this.m_sweep.c.y += this.m_xf.position.y; this.m_sweep.c0.SetV(this.m_sweep.c); this.m_contactList = this.m_controllerList = this.m_jointList = null; this.m_controllerCount = 0; this.m_next = this.m_prev = null; this.m_linearVelocity.SetV(t.linearVelocity); this.m_angularVelocity = t.angularVelocity; this.m_linearDamping = t.linearDamping; this.m_angularDamping = t.angularDamping; this.m_force.Set(0, 0); this.m_sleepTime = this.m_torque = 0; this.m_type = t.type; this.m_invMass = this.m_type == n.b2_dynamicBody ? this.m_mass = 1 : this.m_mass = 0; this.m_invI = this.m_I = 0; this.m_inertiaScale = t.inertiaScale; this.m_userData = t.userData; this.m_fixtureList = null; this.m_fixtureCount = 0 }; n.prototype.SynchronizeFixtures = function () { var r = n.s_xf1, t, i; for (r.R.Set(this.m_sweep.a0), t = r.R, i = this.m_sweep.localCenter, r.position.x = this.m_sweep.c0.x - (t.col1.x * i.x + t.col2.x * i.y), r.position.y = this.m_sweep.c0.y - (t.col1.y * i.x + t.col2.y * i.y), i = this.m_world.m_contactManager.m_broadPhase, t = this.m_fixtureList; t; t = t.m_next) t.Synchronize(i, r, this.m_xf) }; n.prototype.SynchronizeTransform = function () { this.m_xf.R.Set(this.m_sweep.a); var n = this.m_xf.R, t = this.m_sweep.localCenter; this.m_xf.position.x = this.m_sweep.c.x - (n.col1.x * t.x + n.col2.x * t.y); this.m_xf.position.y = this.m_sweep.c.y - (n.col1.y * t.x + n.col2.y * t.y) }; n.prototype.ShouldCollide = function (t) { if (this.m_type != n.b2_dynamicBody && t.m_type != n.b2_dynamicBody) return !1; for (var i = this.m_jointList; i; i = i.next) if (i.other == t && i.joint.m_collideConnected == !1) return !1; return !0 }; n.prototype.Advance = function (n) { n === undefined && (n = 0); this.m_sweep.Advance(n); this.m_sweep.c.SetV(this.m_sweep.c0); this.m_sweep.a = this.m_sweep.a0; this.SynchronizeTransform() }; Box2D.postDefs.push(function () { Box2D.Dynamics.b2Body.s_xf1 = new p; Box2D.Dynamics.b2Body.e_islandFlag = 1; Box2D.Dynamics.b2Body.e_awakeFlag = 2; Box2D.Dynamics.b2Body.e_allowSleepFlag = 4; Box2D.Dynamics.b2Body.e_bulletFlag = 8; Box2D.Dynamics.b2Body.e_fixedRotationFlag = 16; Box2D.Dynamics.b2Body.e_activeFlag = 32; Box2D.Dynamics.b2Body.b2_staticBody = 0; Box2D.Dynamics.b2Body.b2_kinematicBody = 1; Box2D.Dynamics.b2Body.b2_dynamicBody = 2 }); b.b2BodyDef = function () { this.position = new e; this.linearVelocity = new e }; b.prototype.b2BodyDef = function () { this.userData = null; this.position.Set(0, 0); this.angle = 0; this.linearVelocity.Set(0, 0); this.angularDamping = this.linearDamping = this.angularVelocity = 0; this.awake = this.allowSleep = !0; this.bullet = this.fixedRotation = !1; this.type = n.b2_staticBody; this.active = !0; this.inertiaScale = 1 }; a.b2ContactFilter = function () { }; a.prototype.ShouldCollide = function (n, t) { var i = n.GetFilterData(), r = t.GetFilterData(); return i.groupIndex == r.groupIndex && i.groupIndex != 0 ? i.groupIndex > 0 : (i.maskBits & r.categoryBits) != 0 && (i.categoryBits & r.maskBits) != 0 }; a.prototype.RayCollide = function (n, t) { return n ? this.ShouldCollide(n instanceof i ? n : null, t) : !0 }; Box2D.postDefs.push(function () { Box2D.Dynamics.b2ContactFilter.b2_defaultFilter = new a }); it.b2ContactImpulse = function () { this.normalImpulses = new Vector_a2j_Number(r.b2_maxManifoldPoints); this.tangentImpulses = new Vector_a2j_Number(r.b2_maxManifoldPoints) }; c.b2ContactListener = function () { }; c.prototype.BeginContact = function () { }; c.prototype.EndContact = function () { }; c.prototype.PreSolve = function () { }; c.prototype.PostSolve = function () { }; Box2D.postDefs.push(function () { Box2D.Dynamics.b2ContactListener.b2_defaultListener = new c }); l.b2ContactManager = function () { }; l.prototype.b2ContactManager = function () { this.m_world = null; this.m_contactCount = 0; this.m_contactFilter = a.b2_defaultFilter; this.m_contactListener = c.b2_defaultListener; this.m_contactFactory = new lt(this.m_allocator); this.m_broadPhase = new ut }; l.prototype.AddPair = function (n, t) { var e = n instanceof i ? n : null, o = t instanceof i ? t : null, u = e.GetBody(), f = o.GetBody(), r, s, h; if (u != f) { for (r = f.GetContactList() ; r;) { if (r.other == u) { if (s = r.contact.GetFixtureA(), h = r.contact.GetFixtureB(), s == e && h == o) return; if (s == o && h == e) return } r = r.next } f.ShouldCollide(u) != !1 && this.m_contactFilter.ShouldCollide(e, o) != !1 && (r = this.m_contactFactory.Create(e, o), e = r.GetFixtureA(), o = r.GetFixtureB(), u = e.m_body, f = o.m_body, r.m_prev = null, r.m_next = this.m_world.m_contactList, this.m_world.m_contactList != null && (this.m_world.m_contactList.m_prev = r), this.m_world.m_contactList = r, r.m_nodeA.contact = r, r.m_nodeA.other = f, r.m_nodeA.prev = null, r.m_nodeA.next = u.m_contactList, u.m_contactList != null && (u.m_contactList.prev = r.m_nodeA), u.m_contactList = r.m_nodeA, r.m_nodeB.contact = r, r.m_nodeB.other = u, r.m_nodeB.prev = null, r.m_nodeB.next = f.m_contactList, f.m_contactList != null && (f.m_contactList.prev = r.m_nodeB), f.m_contactList = r.m_nodeB, ++this.m_world.m_contactCount) } }; l.prototype.FindNewContacts = function () { this.m_broadPhase.UpdatePairs(Box2D.generateCallback(this, this.AddPair)) }; l.prototype.Destroy = function (n) { var t = n.GetFixtureA(), i = n.GetFixtureB(); t = t.GetBody(); i = i.GetBody(); n.IsTouching() && this.m_contactListener.EndContact(n); n.m_prev && (n.m_prev.m_next = n.m_next); n.m_next && (n.m_next.m_prev = n.m_prev); n == this.m_world.m_contactList && (this.m_world.m_contactList = n.m_next); n.m_nodeA.prev && (n.m_nodeA.prev.next = n.m_nodeA.next); n.m_nodeA.next && (n.m_nodeA.next.prev = n.m_nodeA.prev); n.m_nodeA == t.m_contactList && (t.m_contactList = n.m_nodeA.next); n.m_nodeB.prev && (n.m_nodeB.prev.next = n.m_nodeB.next); n.m_nodeB.next && (n.m_nodeB.next.prev = n.m_nodeB.prev); n.m_nodeB == i.m_contactList && (i.m_contactList = n.m_nodeB.next); this.m_contactFactory.Destroy(n); --this.m_contactCount }; l.prototype.Collide = function () { for (var n = this.m_world.m_contactList; n;) { var t = n.GetFixtureA(), i = n.GetFixtureB(), r = t.GetBody(), u = i.GetBody(); if (r.IsAwake() == !1 && u.IsAwake() == !1) n = n.GetNext(); else { if (n.m_flags & o.e_filterFlag) { if (u.ShouldCollide(r) == !1) { t = n; n = t.GetNext(); this.Destroy(t); continue } if (this.m_contactFilter.ShouldCollide(t, i) == !1) { t = n; n = t.GetNext(); this.Destroy(t); continue } n.m_flags &= ~o.e_filterFlag } this.m_broadPhase.TestOverlap(t.m_proxy, i.m_proxy) == !1 ? (t = n, n = t.GetNext(), this.Destroy(t)) : (n.Update(this.m_contactListener), n = n.GetNext()) } } }; Box2D.postDefs.push(function () { Box2D.Dynamics.b2ContactManager.s_evalCP = new rt }); u.b2DebugDraw = function () { }; u.prototype.b2DebugDraw = function () { }; u.prototype.SetFlags = function () { }; u.prototype.GetFlags = function () { }; u.prototype.AppendFlags = function () { }; u.prototype.ClearFlags = function () { }; u.prototype.SetSprite = function () { }; u.prototype.GetSprite = function () { }; u.prototype.SetDrawScale = function () { }; u.prototype.GetDrawScale = function () { }; u.prototype.SetLineThickness = function () { }; u.prototype.GetLineThickness = function () { }; u.prototype.SetAlpha = function () { }; u.prototype.GetAlpha = function () { }; u.prototype.SetFillAlpha = function () { }; u.prototype.GetFillAlpha = function () { }; u.prototype.SetXFormScale = function () { }; u.prototype.GetXFormScale = function () { }; u.prototype.DrawPolygon = function () { }; u.prototype.DrawSolidPolygon = function () { }; u.prototype.DrawCircle = function () { }; u.prototype.DrawSolidCircle = function () { }; u.prototype.DrawSegment = function () { }; u.prototype.DrawTransform = function () { }; Box2D.postDefs.push(function () { Box2D.Dynamics.b2DebugDraw.e_shapeBit = 1; Box2D.Dynamics.b2DebugDraw.e_jointBit = 2; Box2D.Dynamics.b2DebugDraw.e_aabbBit = 4; Box2D.Dynamics.b2DebugDraw.e_pairBit = 8; Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit = 16; Box2D.Dynamics.b2DebugDraw.e_controllerBit = 32 }); g.b2DestructionListener = function () { }; g.prototype.SayGoodbyeJoint = function () { }; g.prototype.SayGoodbyeFixture = function () { }; v.b2FilterData = function () { this.categoryBits = 1; this.maskBits = 65535; this.groupIndex = 0 }; v.prototype.Copy = function () { var n = new v; return n.categoryBits = this.categoryBits, n.maskBits = this.maskBits, n.groupIndex = this.groupIndex, n }; i.b2Fixture = function () { this.m_filter = new v }; i.prototype.GetType = function () { return this.m_shape.GetType() }; i.prototype.GetShape = function () { return this.m_shape }; i.prototype.SetSensor = function (n) { if (this.m_isSensor != n && (this.m_isSensor = n, this.m_body != null)) for (n = this.m_body.GetContactList() ; n;) { var t = n.contact, i = t.GetFixtureA(), r = t.GetFixtureB(); (i == this || r == this) && t.SetSensor(i.IsSensor() || r.IsSensor()); n = n.next } }; i.prototype.IsSensor = function () { return this.m_isSensor }; i.prototype.SetFilterData = function (n) { if (this.m_filter = n.Copy(), !this.m_body) for (n = this.m_body.GetContactList() ; n;) { var t = n.contact, i = t.GetFixtureA(), r = t.GetFixtureB(); (i == this || r == this) && t.FlagForFiltering(); n = n.next } }; i.prototype.GetFilterData = function () { return this.m_filter.Copy() }; i.prototype.GetBody = function () { return this.m_body }; i.prototype.GetNext = function () { return this.m_next }; i.prototype.GetUserData = function () { return this.m_userData }; i.prototype.SetUserData = function (n) { this.m_userData = n }; i.prototype.TestPoint = function (n) { return this.m_shape.TestPoint(this.m_body.GetTransform(), n) }; i.prototype.RayCast = function (n, t) { return this.m_shape.RayCast(n, t, this.m_body.GetTransform()) }; i.prototype.GetMassData = function (n) { return n === undefined && (n = null), n == null && (n = new ht), this.m_shape.ComputeMass(n, this.m_density), n }; i.prototype.SetDensity = function (n) { n === undefined && (n = 0); this.m_density = n }; i.prototype.GetDensity = function () { return this.m_density }; i.prototype.GetFriction = function () { return this.m_friction }; i.prototype.SetFriction = function (n) { n === undefined && (n = 0); this.m_friction = n }; i.prototype.GetRestitution = function () { return this.m_restitution }; i.prototype.SetRestitution = function (n) { n === undefined && (n = 0); this.m_restitution = n }; i.prototype.GetAABB = function () { return this.m_aabb }; i.prototype.b2Fixture = function () { this.m_aabb = new h; this.m_shape = this.m_next = this.m_body = this.m_userData = null; this.m_restitution = this.m_friction = this.m_density = 0 }; i.prototype.Create = function (n, t, i) { this.m_userData = i.userData; this.m_friction = i.friction; this.m_restitution = i.restitution; this.m_body = n; this.m_next = null; this.m_filter = i.filter.Copy(); this.m_isSensor = i.isSensor; this.m_shape = i.shape.Copy(); this.m_density = i.density }; i.prototype.Destroy = function () { this.m_shape = null }; i.prototype.CreateProxy = function (n, t) { this.m_shape.ComputeAABB(this.m_aabb, t); this.m_proxy = n.CreateProxy(this.m_aabb, this) }; i.prototype.DestroyProxy = function (n) { this.m_proxy != null && (n.DestroyProxy(this.m_proxy), this.m_proxy = null) }; i.prototype.Synchronize = function (n, t, i) { if (this.m_proxy) { var r = new h, u = new h; this.m_shape.ComputeAABB(r, t); this.m_shape.ComputeAABB(u, i); this.m_aabb.Combine(r, u); t = f.SubtractVV(i.position, t.position); n.MoveProxy(this.m_proxy, this.m_aabb, t) } }; nt.b2FixtureDef = function () { this.filter = new v }; nt.prototype.b2FixtureDef = function () { this.userData = this.shape = null; this.friction = .2; this.density = this.restitution = 0; this.filter.categoryBits = 1; this.filter.maskBits = 65535; this.filter.groupIndex = 0; this.isSensor = !1 }; s.b2Island = function () { }; s.prototype.b2Island = function () { this.m_bodies = new Vector; this.m_contacts = new Vector; this.m_joints = new Vector }; s.prototype.Initialize = function (n, t, i, r, u, f) { n === undefined && (n = 0); t === undefined && (t = 0); i === undefined && (i = 0); var e = 0; for (this.m_bodyCapacity = n, this.m_contactCapacity = t, this.m_jointCapacity = i, this.m_jointCount = this.m_contactCount = this.m_bodyCount = 0, this.m_allocator = r, this.m_listener = u, this.m_contactSolver = f, e = this.m_bodies.length; e < n; e++) this.m_bodies[e] = null; for (e = this.m_contacts.length; e < t; e++) this.m_contacts[e] = null; for (e = this.m_joints.length; e < i; e++) this.m_joints[e] = null }; s.prototype.Clear = function () { this.m_jointCount = this.m_contactCount = this.m_bodyCount = 0 }; s.prototype.Solve = function (t, i, u) { for (var o = 0, e = 0, s, h, c, o = 0; o < this.m_bodyCount; ++o) e = this.m_bodies[o], e.GetType() == n.b2_dynamicBody && (e.m_linearVelocity.x += t.dt * (i.x + e.m_invMass * e.m_force.x), e.m_linearVelocity.y += t.dt * (i.y + e.m_invMass * e.m_force.y), e.m_angularVelocity += t.dt * e.m_invI * e.m_torque, e.m_linearVelocity.Multiply(f.Clamp(1 - t.dt * e.m_linearDamping, 0, 1)), e.m_angularVelocity *= f.Clamp(1 - t.dt * e.m_angularDamping, 0, 1)); for (this.m_contactSolver.Initialize(t, this.m_contacts, this.m_contactCount, this.m_allocator), i = this.m_contactSolver, i.InitVelocityConstraints(t), o = 0; o < this.m_jointCount; ++o) s = this.m_joints[o], s.InitVelocityConstraints(t); for (o = 0; o < t.velocityIterations; ++o) { for (e = 0; e < this.m_jointCount; ++e) s = this.m_joints[e], s.SolveVelocityConstraints(t); i.SolveVelocityConstraints() } for (o = 0; o < this.m_jointCount; ++o) s = this.m_joints[o], s.FinalizeVelocityConstraints(); for (i.FinalizeVelocityConstraints(), o = 0; o < this.m_bodyCount; ++o) e = this.m_bodies[o], e.GetType() != n.b2_staticBody && (h = t.dt * e.m_linearVelocity.x, c = t.dt * e.m_linearVelocity.y, h * h + c * c > r.b2_maxTranslationSquared && (e.m_linearVelocity.Normalize(), e.m_linearVelocity.x *= r.b2_maxTranslation * t.inv_dt, e.m_linearVelocity.y *= r.b2_maxTranslation * t.inv_dt), h = t.dt * e.m_angularVelocity, h * h > r.b2_maxRotationSquared && (e.m_angularVelocity = e.m_angularVelocity < 0 ? -r.b2_maxRotation * t.inv_dt : r.b2_maxRotation * t.inv_dt), e.m_sweep.c0.SetV(e.m_sweep.c), e.m_sweep.a0 = e.m_sweep.a, e.m_sweep.c.x += t.dt * e.m_linearVelocity.x, e.m_sweep.c.y += t.dt * e.m_linearVelocity.y, e.m_sweep.a += t.dt * e.m_angularVelocity, e.SynchronizeTransform()); for (o = 0; o < t.positionIterations; ++o) { for (h = i.SolvePositionConstraints(r.b2_contactBaumgarte), c = !0, e = 0; e < this.m_jointCount; ++e) s = this.m_joints[e], s = s.SolvePositionConstraints(r.b2_contactBaumgarte), c = c && s; if (h && c) break } if (this.Report(i.m_constraints), u) { for (u = Number.MAX_VALUE, i = r.b2_linearSleepTolerance * r.b2_linearSleepTolerance, h = r.b2_angularSleepTolerance * r.b2_angularSleepTolerance, o = 0; o < this.m_bodyCount; ++o) e = this.m_bodies[o], e.GetType() != n.b2_staticBody && ((e.m_flags & n.e_allowSleepFlag) == 0 && (u = e.m_sleepTime = 0), (e.m_flags & n.e_allowSleepFlag) == 0 || e.m_angularVelocity * e.m_angularVelocity > h || f.Dot(e.m_linearVelocity, e.m_linearVelocity) > i ? u = e.m_sleepTime = 0 : (e.m_sleepTime += t.dt, u = f.Min(u, e.m_sleepTime))); if (u >= r.b2_timeToSleep) for (o = 0; o < this.m_bodyCount; ++o) e = this.m_bodies[o], e.SetAwake(!1) } }; s.prototype.SolveTOI = function (t) { var u = 0, i = 0, o, f, e, s; for (this.m_contactSolver.Initialize(t, this.m_contacts, this.m_contactCount, this.m_allocator), o = this.m_contactSolver, u = 0; u < this.m_jointCount; ++u) this.m_joints[u].InitVelocityConstraints(t); for (u = 0; u < t.velocityIterations; ++u) for (o.SolveVelocityConstraints(), i = 0; i < this.m_jointCount; ++i) this.m_joints[i].SolveVelocityConstraints(t); for (u = 0; u < this.m_bodyCount; ++u) i = this.m_bodies[u], i.GetType() != n.b2_staticBody && (f = t.dt * i.m_linearVelocity.x, e = t.dt * i.m_linearVelocity.y, f * f + e * e > r.b2_maxTranslationSquared && (i.m_linearVelocity.Normalize(), i.m_linearVelocity.x *= r.b2_maxTranslation * t.inv_dt, i.m_linearVelocity.y *= r.b2_maxTranslation * t.inv_dt), f = t.dt * i.m_angularVelocity, f * f > r.b2_maxRotationSquared && (i.m_angularVelocity = i.m_angularVelocity < 0 ? -r.b2_maxRotation * t.inv_dt : r.b2_maxRotation * t.inv_dt), i.m_sweep.c0.SetV(i.m_sweep.c), i.m_sweep.a0 = i.m_sweep.a, i.m_sweep.c.x += t.dt * i.m_linearVelocity.x, i.m_sweep.c.y += t.dt * i.m_linearVelocity.y, i.m_sweep.a += t.dt * i.m_angularVelocity, i.SynchronizeTransform()); for (u = 0; u < t.positionIterations; ++u) { for (f = o.SolvePositionConstraints(.75), e = !0, i = 0; i < this.m_jointCount; ++i) s = this.m_joints[i].SolvePositionConstraints(r.b2_contactBaumgarte), e = e && s; if (f && e) break } this.Report(o.m_constraints) }; s.prototype.Report = function (n) { var i; if (this.m_listener != null) for (i = 0; i < this.m_contactCount; ++i) { for (var u = this.m_contacts[i], r = n[i], t = 0; t < r.pointCount; ++t) s.s_impulse.normalImpulses[t] = r.points[t].normalImpulse, s.s_impulse.tangentImpulses[t] = r.points[t].tangentImpulse; this.m_listener.PostSolve(u, s.s_impulse) } }; s.prototype.AddBody = function (n) { n.m_islandIndex = this.m_bodyCount; this.m_bodies[this.m_bodyCount++] = n }; s.prototype.AddContact = function (n) { this.m_contacts[this.m_contactCount++] = n }; s.prototype.AddJoint = function (n) { this.m_joints[this.m_jointCount++] = n }; Box2D.postDefs.push(function () { Box2D.Dynamics.b2Island.s_impulse = new it }); k.b2TimeStep = function () { }; k.prototype.Set = function (n) { this.dt = n.dt; this.inv_dt = n.inv_dt; this.positionIterations = n.positionIterations; this.velocityIterations = n.velocityIterations; this.warmStarting = n.warmStarting }; t.b2World = function () { this.s_stack = new Vector; this.m_contactManager = new l; this.m_contactSolver = new at; this.m_island = new s }; t.prototype.b2World = function (n, i) { this.m_controllerList = this.m_jointList = this.m_contactList = this.m_bodyList = this.m_debugDraw = this.m_destructionListener = null; this.m_controllerCount = this.m_jointCount = this.m_contactCount = this.m_bodyCount = 0; t.m_warmStarting = !0; t.m_continuousPhysics = !0; this.m_allowSleep = i; this.m_gravity = n; this.m_inv_dt0 = 0; this.m_contactManager.m_world = this; this.m_groundBody = this.CreateBody(new b) }; t.prototype.SetDestructionListener = function (n) { this.m_destructionListener = n }; t.prototype.SetContactFilter = function (n) { this.m_contactManager.m_contactFilter = n }; t.prototype.SetContactListener = function (n) { this.m_contactManager.m_contactListener = n }; t.prototype.SetDebugDraw = function (n) { this.m_debugDraw = n }; t.prototype.SetBroadPhase = function (n) { var r = this.m_contactManager.m_broadPhase, i, t; for (this.m_contactManager.m_broadPhase = n, i = this.m_bodyList; i; i = i.m_next) for (t = i.m_fixtureList; t; t = t.m_next) t.m_proxy = n.CreateProxy(r.GetFatAABB(t.m_proxy), t) }; t.prototype.Validate = function () { this.m_contactManager.m_broadPhase.Validate() }; t.prototype.GetProxyCount = function () { return this.m_contactManager.m_broadPhase.GetProxyCount() }; t.prototype.CreateBody = function (t) { return this.IsLocked() == !0 ? null : (t = new n(t, this), t.m_prev = null, (t.m_next = this.m_bodyList) && (this.m_bodyList.m_prev = t), this.m_bodyList = t, ++this.m_bodyCount, t) }; t.prototype.DestroyBody = function (n) { var t, i; if (this.IsLocked() != !0) { for (t = n.m_jointList; t;) i = t, t = t.next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeJoint(i.joint), this.DestroyJoint(i.joint); for (t = n.m_controllerList; t;) i = t, t = t.nextController, i.controller.RemoveBody(n); for (t = n.m_contactList; t;) i = t, t = t.next, this.m_contactManager.Destroy(i.contact); for (n.m_contactList = null, t = n.m_fixtureList; t;) i = t, t = t.m_next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeFixture(i), i.DestroyProxy(this.m_contactManager.m_broadPhase), i.Destroy(); n.m_fixtureList = null; n.m_fixtureCount = 0; n.m_prev && (n.m_prev.m_next = n.m_next); n.m_next && (n.m_next.m_prev = n.m_prev); n == this.m_bodyList && (this.m_bodyList = n.m_next); --this.m_bodyCount } }; t.prototype.CreateJoint = function (n) { var t = y.Create(n, null), i, r; if (t.m_prev = null, (t.m_next = this.m_jointList) && (this.m_jointList.m_prev = t), this.m_jointList = t, ++this.m_jointCount, t.m_edgeA.joint = t, t.m_edgeA.other = t.m_bodyB, t.m_edgeA.prev = null, (t.m_edgeA.next = t.m_bodyA.m_jointList) && (t.m_bodyA.m_jointList.prev = t.m_edgeA), t.m_bodyA.m_jointList = t.m_edgeA, t.m_edgeB.joint = t, t.m_edgeB.other = t.m_bodyA, t.m_edgeB.prev = null, (t.m_edgeB.next = t.m_bodyB.m_jointList) && (t.m_bodyB.m_jointList.prev = t.m_edgeB), t.m_bodyB.m_jointList = t.m_edgeB, i = n.bodyA, r = n.bodyB, n.collideConnected == !1) for (n = r.GetContactList() ; n;) n.other == i && n.contact.FlagForFiltering(), n = n.next; return t }; t.prototype.DestroyJoint = function (n) { var r = n.m_collideConnected, t, i; if (n.m_prev && (n.m_prev.m_next = n.m_next), n.m_next && (n.m_next.m_prev = n.m_prev), n == this.m_jointList && (this.m_jointList = n.m_next), t = n.m_bodyA, i = n.m_bodyB, t.SetAwake(!0), i.SetAwake(!0), n.m_edgeA.prev && (n.m_edgeA.prev.next = n.m_edgeA.next), n.m_edgeA.next && (n.m_edgeA.next.prev = n.m_edgeA.prev), n.m_edgeA == t.m_jointList && (t.m_jointList = n.m_edgeA.next), n.m_edgeA.prev = null, n.m_edgeA.next = null, n.m_edgeB.prev && (n.m_edgeB.prev.next = n.m_edgeB.next), n.m_edgeB.next && (n.m_edgeB.next.prev = n.m_edgeB.prev), n.m_edgeB == i.m_jointList && (i.m_jointList = n.m_edgeB.next), n.m_edgeB.prev = null, n.m_edgeB.next = null, y.Destroy(n, null), --this.m_jointCount, r == !1) for (n = i.GetContactList() ; n;) n.other == t && n.contact.FlagForFiltering(), n = n.next }; t.prototype.AddController = function (n) { return n.m_next = this.m_controllerList, n.m_prev = null, this.m_controllerList = n, n.m_world = this, this.m_controllerCount++, n }; t.prototype.RemoveController = function (n) { n.m_prev && (n.m_prev.m_next = n.m_next); n.m_next && (n.m_next.m_prev = n.m_prev); this.m_controllerList == n && (this.m_controllerList = n.m_next); this.m_controllerCount-- }; t.prototype.CreateController = function (n) { if (n.m_world != this) throw Error("Controller can only be a member of one world"); return n.m_next = this.m_controllerList, n.m_prev = null, this.m_controllerList && (this.m_controllerList.m_prev = n), this.m_controllerList = n, ++this.m_controllerCount, n.m_world = this, n }; t.prototype.DestroyController = function (n) { n.Clear(); n.m_next && (n.m_next.m_prev = n.m_prev); n.m_prev && (n.m_prev.m_next = n.m_next); n == this.m_controllerList && (this.m_controllerList = n.m_next); --this.m_controllerCount }; t.prototype.SetWarmStarting = function (n) { t.m_warmStarting = n }; t.prototype.SetContinuousPhysics = function (n) { t.m_continuousPhysics = n }; t.prototype.GetBodyCount = function () { return this.m_bodyCount }; t.prototype.GetJointCount = function () { return this.m_jointCount }; t.prototype.GetContactCount = function () { return this.m_contactCount }; t.prototype.SetGravity = function (n) { this.m_gravity = n }; t.prototype.GetGravity = function () { return this.m_gravity }; t.prototype.GetGroundBody = function () { return this.m_groundBody }; t.prototype.Step = function (n, i, r) { n === undefined && (n = 0); i === undefined && (i = 0); r === undefined && (r = 0); this.m_flags & t.e_newFixture && (this.m_contactManager.FindNewContacts(), this.m_flags &= ~t.e_newFixture); this.m_flags |= t.e_locked; var u = t.s_timestep2; u.dt = n; u.velocityIterations = i; u.positionIterations = r; u.inv_dt = n > 0 ? 1 / n : 0; u.dtRatio = this.m_inv_dt0 * n; u.warmStarting = t.m_warmStarting; this.m_contactManager.Collide(); u.dt > 0 && this.Solve(u); t.m_continuousPhysics && u.dt > 0 && this.SolveTOI(u); u.dt > 0 && (this.m_inv_dt0 = u.inv_dt); this.m_flags &= ~t.e_locked }; t.prototype.ClearForces = function () { for (var n = this.m_bodyList; n; n = n.m_next) n.m_force.SetZero(), n.m_torque = 0 }; t.prototype.DrawDebugData = function () { var l, i, r, c, f, o, s; if (this.m_debugDraw != null) { if (this.m_debugDraw.m_sprite.graphics.clear(), l = this.m_debugDraw.GetFlags(), new e, new e, new e, new h, new h, f = [new e, new e, new e, new e], o = new tt(0, 0, 0), l & u.e_shapeBit) for (i = this.m_bodyList; i; i = i.m_next) for (f = i.m_xf, r = i.GetFixtureList() ; r; r = r.m_next) c = r.GetShape(), i.IsActive() == !1 ? o.Set(.5, .5, .3) : i.GetType() == n.b2_staticBody ? o.Set(.5, .9, .5) : i.GetType() == n.b2_kinematicBody ? o.Set(.5, .5, .9) : i.IsAwake() == !1 ? o.Set(.6, .6, .6) : o.Set(.9, .7, .7), this.DrawShape(c, f, o); if (l & u.e_jointBit) for (i = this.m_jointList; i; i = i.m_next) this.DrawJoint(i); if (l & u.e_controllerBit) for (i = this.m_controllerList; i; i = i.m_next) i.Draw(this.m_debugDraw); if (l & u.e_pairBit) for (o.Set(.3, .9, .9), i = this.m_contactManager.m_contactList; i; i = i.GetNext()) c = i.GetFixtureA(), r = i.GetFixtureB(), c = c.GetAABB().GetCenter(), r = r.GetAABB().GetCenter(), this.m_debugDraw.DrawSegment(c, r, o); if (l & u.e_aabbBit) for (c = this.m_contactManager.m_broadPhase, f = [new e, new e, new e, new e], i = this.m_bodyList; i; i = i.GetNext()) if (i.IsActive() != !1) for (r = i.GetFixtureList() ; r; r = r.GetNext()) s = c.GetFatAABB(r.m_proxy), f[0].Set(s.lowerBound.x, s.lowerBound.y), f[1].Set(s.upperBound.x, s.lowerBound.y), f[2].Set(s.upperBound.x, s.upperBound.y), f[3].Set(s.lowerBound.x, s.upperBound.y), this.m_debugDraw.DrawPolygon(f, 4, o); if (l & u.e_centerOfMassBit) for (i = this.m_bodyList; i; i = i.m_next) f = t.s_xf, f.R = i.m_xf.R, f.position = i.GetWorldCenter(), this.m_debugDraw.DrawTransform(f) } }; t.prototype.QueryAABB = function (n, t) { var i = this.m_contactManager.m_broadPhase; i.Query(function (t) { return n(i.GetUserData(t)) }, t) }; t.prototype.QueryShape = function (n, t, r) { r === undefined && (r = null); r == null && (r = new p, r.SetIdentity()); var u = this.m_contactManager.m_broadPhase, f = new h; t.ComputeAABB(f, r); u.Query(function (f) { return (f = u.GetUserData(f) instanceof i ? u.GetUserData(f) : null, w.TestOverlap(t, r, f.GetShape(), f.GetBody().GetTransform())) ? n(f) : !0 }, f) }; t.prototype.QueryPoint = function (n, t) { var u = this.m_contactManager.m_broadPhase, f = new h; f.lowerBound.Set(t.x - r.b2_linearSlop, t.y - r.b2_linearSlop); f.upperBound.Set(t.x + r.b2_linearSlop, t.y + r.b2_linearSlop); u.Query(function (r) { return (r = u.GetUserData(r) instanceof i ? u.GetUserData(r) : null, r.TestPoint(t)) ? n(r) : !0 }, f) }; t.prototype.RayCast = function (n, t, r) { var f = this.m_contactManager.m_broadPhase, u = new et, o = new ft(t, r); f.RayCast(function (o, s) { var c = f.GetUserData(s), h, l; return (c = c instanceof i ? c : null, c.RayCast(u, o)) ? (h = u.fraction, l = new e((1 - h) * t.x + h * r.x, (1 - h) * t.y + h * r.y), n(c, l, u.normal, h)) : o.maxFraction }, o) }; t.prototype.RayCastOne = function (n, t) { var i; return this.RayCast(function (n, t, r, u) { return u === undefined && (u = 0), i = n, u }, n, t), i }; t.prototype.RayCastAll = function (n, t) { var i = new Vector; return this.RayCast(function (n) { return i[i.length] = n, 1 }, n, t), i }; t.prototype.GetBodyList = function () { return this.m_bodyList }; t.prototype.GetJointList = function () { return this.m_jointList }; t.prototype.GetContactList = function () { return this.m_contactList }; t.prototype.IsLocked = function () { return (this.m_flags & t.e_locked) > 0 }; t.prototype.Solve = function (t) { for (var i, r, s, u, h, e, f = this.m_controllerList; f; f = f.m_next) f.Step(t); for (f = this.m_island, f.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver), i = this.m_bodyList; i; i = i.m_next) i.m_flags &= ~n.e_islandFlag; for (r = this.m_contactList; r; r = r.m_next) r.m_flags &= ~o.e_islandFlag; for (r = this.m_jointList; r; r = r.m_next) r.m_islandFlag = !1; for (parseInt(this.m_bodyCount), r = this.s_stack, s = this.m_bodyList; s; s = s.m_next) if (!(s.m_flags & n.e_islandFlag) && !(s.IsAwake() == !1 || s.IsActive() == !1) && s.GetType() != n.b2_staticBody) { for (f.Clear(), u = 0, r[u++] = s, s.m_flags |= n.e_islandFlag; u > 0;) if (i = r[--u], f.AddBody(i), i.IsAwake() == !1 && i.SetAwake(!0), i.GetType() != n.b2_staticBody) { for (e = i.m_contactList; e; e = e.next) e.contact.m_flags & o.e_islandFlag || e.contact.IsSensor() == !0 || e.contact.IsEnabled() == !1 || e.contact.IsTouching() == !1 || (f.AddContact(e.contact), e.contact.m_flags |= o.e_islandFlag, h = e.other, h.m_flags & n.e_islandFlag || (r[u++] = h, h.m_flags |= n.e_islandFlag)); for (i = i.m_jointList; i; i = i.next) i.joint.m_islandFlag != !0 && (h = i.other, h.IsActive() != !1 && (f.AddJoint(i.joint), i.joint.m_islandFlag = !0, h.m_flags & n.e_islandFlag || (r[u++] = h, h.m_flags |= n.e_islandFlag))) } for (f.Solve(t, this.m_gravity, this.m_allowSleep), u = 0; u < f.m_bodyCount; ++u) i = f.m_bodies[u], i.GetType() == n.b2_staticBody && (i.m_flags &= ~n.e_islandFlag) } for (u = 0; u < r.length; ++u) { if (!r[u]) break; r[u] = null } for (i = this.m_bodyList; i; i = i.m_next) i.IsAwake() == !1 || i.IsActive() == !1 || i.GetType() != n.b2_staticBody && i.SynchronizeFixtures(); this.m_contactManager.FindNewContacts() }; t.prototype.SolveTOI = function (i) { var u, e, f, l = this.m_island, a, c, s, h; for (l.Initialize(this.m_bodyCount, r.b2_maxTOIContactsPerIsland, r.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver), a = t.s_queue, u = this.m_bodyList; u; u = u.m_next) u.m_flags &= ~n.e_islandFlag, u.m_sweep.t0 = 0; for (f = this.m_contactList; f; f = f.m_next) f.m_flags &= ~(o.e_toiFlag | o.e_islandFlag); for (f = this.m_jointList; f; f = f.m_next) f.m_islandFlag = !1; for (; ;) { for (c = null, s = 1, f = this.m_contactList; f; f = f.m_next) if (!(f.IsSensor() == !0 || f.IsEnabled() == !1 || f.IsContinuous() == !1)) { if (u = 1, f.m_flags & o.e_toiFlag) u = f.m_toi; else { if (u = f.m_fixtureA, e = f.m_fixtureB, u = u.m_body, e = e.m_body, (u.GetType() != n.b2_dynamicBody || u.IsAwake() == !1) && (e.GetType() != n.b2_dynamicBody || e.IsAwake() == !1)) continue; h = u.m_sweep.t0; u.m_sweep.t0 < e.m_sweep.t0 ? (h = e.m_sweep.t0, u.m_sweep.Advance(h)) : e.m_sweep.t0 < u.m_sweep.t0 && (h = u.m_sweep.t0, e.m_sweep.Advance(h)); u = f.ComputeTOI(u.m_sweep, e.m_sweep); r.b2Assert(0 <= u && u <= 1); u > 0 && u < 1 && (u = (1 - u) * h + u, u > 1 && (u = 1)); f.m_toi = u; f.m_flags |= o.e_toiFlag } Number.MIN_VALUE < u && u < s && (c = f, s = u) } if (c == null || 1 - 100 * Number.MIN_VALUE < s) break; if (u = c.m_fixtureA, e = c.m_fixtureB, u = u.m_body, e = e.m_body, t.s_backupA.Set(u.m_sweep), t.s_backupB.Set(e.m_sweep), u.Advance(s), e.Advance(s), c.Update(this.m_contactManager.m_contactListener), c.m_flags &= ~o.e_toiFlag, c.IsSensor() == !0 || c.IsEnabled() == !1) u.m_sweep.Set(t.s_backupA), e.m_sweep.Set(t.s_backupB), u.SynchronizeTransform(), e.SynchronizeTransform(); else if (c.IsTouching() != !1) { for (u = u, u.GetType() != n.b2_dynamicBody && (u = e), l.Clear(), c = f = 0, a[f + c++] = u, u.m_flags |= n.e_islandFlag; c > 0;) if (u = a[f++], --c, l.AddBody(u), u.IsAwake() == !1 && u.SetAwake(!0), u.GetType() == n.b2_dynamicBody) { for (e = u.m_contactList; e; e = e.next) { if (l.m_contactCount == l.m_contactCapacity) break; e.contact.m_flags & o.e_islandFlag || e.contact.IsSensor() == !0 || e.contact.IsEnabled() == !1 || e.contact.IsTouching() == !1 || (l.AddContact(e.contact), e.contact.m_flags |= o.e_islandFlag, h = e.other, h.m_flags & n.e_islandFlag || (h.GetType() != n.b2_staticBody && (h.Advance(s), h.SetAwake(!0)), a[f + c] = h, ++c, h.m_flags |= n.e_islandFlag)) } for (u = u.m_jointList; u; u = u.next) l.m_jointCount != l.m_jointCapacity && u.joint.m_islandFlag != !0 && (h = u.other, h.IsActive() != !1 && (l.AddJoint(u.joint), u.joint.m_islandFlag = !0, h.m_flags & n.e_islandFlag || (h.GetType() != n.b2_staticBody && (h.Advance(s), h.SetAwake(!0)), a[f + c] = h, ++c, h.m_flags |= n.e_islandFlag))) } for (f = t.s_timestep, f.warmStarting = !1, f.dt = (1 - s) * i.dt, f.inv_dt = 1 / f.dt, f.dtRatio = 0, f.velocityIterations = i.velocityIterations, f.positionIterations = i.positionIterations, l.SolveTOI(f), s = s = 0; s < l.m_bodyCount; ++s) if (u = l.m_bodies[s], u.m_flags &= ~n.e_islandFlag, u.IsAwake() != !1 && u.GetType() == n.b2_dynamicBody) for (u.SynchronizeFixtures(), e = u.m_contactList; e; e = e.next) e.contact.m_flags &= ~o.e_toiFlag; for (s = 0; s < l.m_contactCount; ++s) f = l.m_contacts[s], f.m_flags &= ~(o.e_toiFlag | o.e_islandFlag); for (s = 0; s < l.m_jointCount; ++s) f = l.m_joints[s], f.m_islandFlag = !1; this.m_contactManager.FindNewContacts() } } }; t.prototype.DrawJoint = function (n) { var i = n.GetBodyA(), e = n.GetBodyB(), o = i.m_xf.position, s = e.m_xf.position, u = n.GetAnchorA(), f = n.GetAnchorB(), r = t.s_jointColor; switch (n.m_type) { case y.e_distanceJoint: this.m_debugDraw.DrawSegment(u, f, r); break; case y.e_pulleyJoint: i = n instanceof vt ? n : null; n = i.GetGroundAnchorA(); i = i.GetGroundAnchorB(); this.m_debugDraw.DrawSegment(n, u, r); this.m_debugDraw.DrawSegment(i, f, r); this.m_debugDraw.DrawSegment(n, i, r); break; case y.e_mouseJoint: this.m_debugDraw.DrawSegment(u, f, r); break; default: i != this.m_groundBody && this.m_debugDraw.DrawSegment(o, u, r); this.m_debugDraw.DrawSegment(u, f, r); e != this.m_groundBody && this.m_debugDraw.DrawSegment(s, f, r) } }; t.prototype.DrawShape = function (n, t, i) { var r, e, u; switch (n.m_type) { case w.e_circleShape: r = n instanceof ot ? n : null; this.m_debugDraw.DrawSolidCircle(f.MulX(t, r.m_p), r.m_radius, t.R.col1, i); break; case w.e_polygonShape: for (r = 0, r = n instanceof ct ? n : null, n = parseInt(r.GetVertexCount()), e = r.GetVertices(), u = new Vector(n), r = 0; r < n; ++r) u[r] = f.MulX(t, e[r]); this.m_debugDraw.DrawSolidPolygon(u, n, i); break; case w.e_edgeShape: r = n instanceof st ? n : null; this.m_debugDraw.DrawSegment(f.MulX(t, r.GetVertex1()), f.MulX(t, r.GetVertex2()), i) } }; Box2D.postDefs.push(function () { Box2D.Dynamics.b2World.s_timestep2 = new k; Box2D.Dynamics.b2World.s_xf = new p; Box2D.Dynamics.b2World.s_backupA = new d; Box2D.Dynamics.b2World.s_backupB = new d; Box2D.Dynamics.b2World.s_timestep = new k; Box2D.Dynamics.b2World.s_queue = new Vector; Box2D.Dynamics.b2World.s_jointColor = new tt(.5, .8, .8); Box2D.Dynamics.b2World.e_newFixture = 1; Box2D.Dynamics.b2World.e_locked = 2 }) }(), function () { var v = Box2D.Collision.Shapes.b2CircleShape, g = Box2D.Collision.Shapes.b2EdgeShape, y = Box2D.Collision.Shapes.b2PolygonShape, t = Box2D.Collision.Shapes.b2Shape, o = Box2D.Dynamics.Contacts.b2CircleContact, n = Box2D.Dynamics.Contacts.b2Contact, b = Box2D.Dynamics.Contacts.b2ContactConstraint, nt = Box2D.Dynamics.Contacts.b2ContactConstraintPoint, k = Box2D.Dynamics.Contacts.b2ContactEdge, c = Box2D.Dynamics.Contacts.b2ContactFactory, tt = Box2D.Dynamics.Contacts.b2ContactRegister, ut = Box2D.Dynamics.Contacts.b2ContactResult, i = Box2D.Dynamics.Contacts.b2ContactSolver, f = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact, l = Box2D.Dynamics.Contacts.b2NullContact, s = Box2D.Dynamics.Contacts.b2PolyAndCircleContact, e = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact, h = Box2D.Dynamics.Contacts.b2PolygonContact, p = Box2D.Dynamics.Contacts.b2PositionSolverManifold, w = Box2D.Dynamics.b2Body, ft = Box2D.Dynamics.b2TimeStep, r = Box2D.Common.b2Settings, it = Box2D.Common.Math.b2Mat22, rt = Box2D.Common.Math.b2Math, u = Box2D.Common.Math.b2Vec2, d = Box2D.Collision.b2Collision, et = Box2D.Collision.b2ContactID, a = Box2D.Collision.b2Manifold, ot = Box2D.Collision.b2TimeOfImpact, st = Box2D.Collision.b2TOIInput, ht = Box2D.Collision.b2WorldManifold; Box2D.inherit(o, Box2D.Dynamics.Contacts.b2Contact); o.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype; o.b2CircleContact = function () { Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments) }; o.Create = function () { return new o }; o.Destroy = function () { }; o.prototype.Reset = function (n, t) { this.__super.Reset.call(this, n, t) }; o.prototype.Evaluate = function () { var n = this.m_fixtureA.GetBody(), t = this.m_fixtureB.GetBody(); d.CollideCircles(this.m_manifold, this.m_fixtureA.GetShape() instanceof v ? this.m_fixtureA.GetShape() : null, n.m_xf, this.m_fixtureB.GetShape() instanceof v ? this.m_fixtureB.GetShape() : null, t.m_xf) }; n.b2Contact = function () { this.m_nodeA = new k; this.m_nodeB = new k; this.m_manifold = new a; this.m_oldManifold = new a }; n.prototype.GetManifold = function () { return this.m_manifold }; n.prototype.GetWorldManifold = function (n) { var t = this.m_fixtureA.GetBody(), i = this.m_fixtureB.GetBody(), r = this.m_fixtureA.GetShape(), u = this.m_fixtureB.GetShape(); n.Initialize(this.m_manifold, t.GetTransform(), r.m_radius, i.GetTransform(), u.m_radius) }; n.prototype.IsTouching = function () { return (this.m_flags & n.e_touchingFlag) == n.e_touchingFlag }; n.prototype.IsContinuous = function () { return (this.m_flags & n.e_continuousFlag) == n.e_continuousFlag }; n.prototype.SetSensor = function (t) { t ? this.m_flags |= n.e_sensorFlag : this.m_flags &= ~n.e_sensorFlag }; n.prototype.IsSensor = function () { return (this.m_flags & n.e_sensorFlag) == n.e_sensorFlag }; n.prototype.SetEnabled = function (t) { t ? this.m_flags |= n.e_enabledFlag : this.m_flags &= ~n.e_enabledFlag }; n.prototype.IsEnabled = function () { return (this.m_flags & n.e_enabledFlag) == n.e_enabledFlag }; n.prototype.GetNext = function () { return this.m_next }; n.prototype.GetFixtureA = function () { return this.m_fixtureA }; n.prototype.GetFixtureB = function () { return this.m_fixtureB }; n.prototype.FlagForFiltering = function () { this.m_flags |= n.e_filterFlag }; n.prototype.b2Contact = function () { }; n.prototype.Reset = function (t, i) { if (t === undefined && (t = null), i === undefined && (i = null), this.m_flags = n.e_enabledFlag, t && i) { (t.IsSensor() || i.IsSensor()) && (this.m_flags |= n.e_sensorFlag); var r = t.GetBody(), u = i.GetBody(); (r.GetType() != w.b2_dynamicBody || r.IsBullet() || u.GetType() != w.b2_dynamicBody || u.IsBullet()) && (this.m_flags |= n.e_continuousFlag); this.m_fixtureA = t; this.m_fixtureB = i; this.m_manifold.m_pointCount = 0; this.m_next = this.m_prev = null; this.m_nodeA.contact = null; this.m_nodeA.prev = null; this.m_nodeA.next = null; this.m_nodeA.other = null; this.m_nodeB.contact = null; this.m_nodeB.prev = null; this.m_nodeB.next = null; this.m_nodeB.other = null } else this.m_fixtureB = this.m_fixtureA = null }; n.prototype.Update = function (i) { var s = this.m_oldManifold, r, o, l, h, c; this.m_oldManifold = this.m_manifold; this.m_manifold = s; this.m_flags |= n.e_enabledFlag; r = !1; s = (this.m_flags & n.e_touchingFlag) == n.e_touchingFlag; var f = this.m_fixtureA.m_body, e = this.m_fixtureB.m_body, u = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb); if (this.m_flags & n.e_sensorFlag) u && (r = this.m_fixtureA.GetShape(), u = this.m_fixtureB.GetShape(), f = f.GetTransform(), e = e.GetTransform(), r = t.TestOverlap(r, f, u, e)), this.m_manifold.m_pointCount = 0; else { if (f.GetType() != w.b2_dynamicBody || f.IsBullet() || e.GetType() != w.b2_dynamicBody || e.IsBullet() ? this.m_flags |= n.e_continuousFlag : this.m_flags &= ~n.e_continuousFlag, u) { for (this.Evaluate(), r = this.m_manifold.m_pointCount > 0, u = 0; u < this.m_manifold.m_pointCount; ++u) for (o = this.m_manifold.m_points[u], o.m_normalImpulse = 0, o.m_tangentImpulse = 0, l = o.m_id, h = 0; h < this.m_oldManifold.m_pointCount; ++h) if (c = this.m_oldManifold.m_points[h], c.m_id.key == l.key) { o.m_normalImpulse = c.m_normalImpulse; o.m_tangentImpulse = c.m_tangentImpulse; break } } else this.m_manifold.m_pointCount = 0; r != s && (f.SetAwake(!0), e.SetAwake(!0)) } r ? this.m_flags |= n.e_touchingFlag : this.m_flags &= ~n.e_touchingFlag; s == !1 && r == !0 && i.BeginContact(this); s == !0 && r == !1 && i.EndContact(this); (this.m_flags & n.e_sensorFlag) == 0 && i.PreSolve(this, this.m_oldManifold) }; n.prototype.Evaluate = function () { }; n.prototype.ComputeTOI = function (t, i) { return n.s_input.proxyA.Set(this.m_fixtureA.GetShape()), n.s_input.proxyB.Set(this.m_fixtureB.GetShape()), n.s_input.sweepA = t, n.s_input.sweepB = i, n.s_input.tolerance = r.b2_linearSlop, ot.TimeOfImpact(n.s_input) }; Box2D.postDefs.push(function () { Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag = 1; Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag = 2; Box2D.Dynamics.Contacts.b2Contact.e_islandFlag = 4; Box2D.Dynamics.Contacts.b2Contact.e_toiFlag = 8; Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag = 16; Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag = 32; Box2D.Dynamics.Contacts.b2Contact.e_filterFlag = 64; Box2D.Dynamics.Contacts.b2Contact.s_input = new st }); b.b2ContactConstraint = function () { this.localPlaneNormal = new u; this.localPoint = new u; this.normal = new u; this.normalMass = new it; this.K = new it }; b.prototype.b2ContactConstraint = function () { this.points = new Vector(r.b2_maxManifoldPoints); for (var n = 0; n < r.b2_maxManifoldPoints; n++) this.points[n] = new nt }; nt.b2ContactConstraintPoint = function () { this.localPoint = new u; this.rA = new u; this.rB = new u }; k.b2ContactEdge = function () { }; c.b2ContactFactory = function () { }; c.prototype.b2ContactFactory = function (n) { this.m_allocator = n; this.InitializeRegisters() }; c.prototype.AddType = function (n, t, i, r) { i === undefined && (i = 0); r === undefined && (r = 0); this.m_registers[i][r].createFcn = n; this.m_registers[i][r].destroyFcn = t; this.m_registers[i][r].primary = !0; i != r && (this.m_registers[r][i].createFcn = n, this.m_registers[r][i].destroyFcn = t, this.m_registers[r][i].primary = !1) }; c.prototype.InitializeRegisters = function () { var n, i; for (this.m_registers = new Vector(t.e_shapeTypeCount), n = 0; n < t.e_shapeTypeCount; n++) for (this.m_registers[n] = new Vector(t.e_shapeTypeCount), i = 0; i < t.e_shapeTypeCount; i++) this.m_registers[n][i] = new tt; this.AddType(o.Create, o.Destroy, t.e_circleShape, t.e_circleShape); this.AddType(s.Create, s.Destroy, t.e_polygonShape, t.e_circleShape); this.AddType(h.Create, h.Destroy, t.e_polygonShape, t.e_polygonShape); this.AddType(f.Create, f.Destroy, t.e_edgeShape, t.e_circleShape); this.AddType(e.Create, e.Destroy, t.e_polygonShape, t.e_edgeShape) }; c.prototype.Create = function (n, t) { var r = parseInt(n.GetType()), i = parseInt(t.GetType()); return (r = this.m_registers[r][i], r.pool) ? (i = r.pool, r.pool = i.m_next, r.poolCount--, i.Reset(n, t), i) : (i = r.createFcn, i != null ? (r.primary ? (i = i(this.m_allocator), i.Reset(n, t)) : (i = i(this.m_allocator), i.Reset(t, n)), i) : null) }; c.prototype.Destroy = function (n) { n.m_manifold.m_pointCount > 0 && (n.m_fixtureA.m_body.SetAwake(!0), n.m_fixtureB.m_body.SetAwake(!0)); var t = parseInt(n.m_fixtureA.GetType()), i = parseInt(n.m_fixtureB.GetType()); t = this.m_registers[t][i]; t.poolCount++; n.m_next = t.pool; t.pool = n; t = t.destroyFcn; t(n, this.m_allocator) }; tt.b2ContactRegister = function () { }; ut.b2ContactResult = function () { this.position = new u; this.normal = new u; this.id = new et }; i.b2ContactSolver = function () { this.m_step = new ft; this.m_constraints = new Vector }; i.prototype.b2ContactSolver = function () { }; i.prototype.Initialize = function (n, t, u, f) { var h, g; for (u === undefined && (u = 0), this.m_step.Set(n), this.m_allocator = f, n = 0, this.m_constraintCount = u; this.m_constraints.length < this.m_constraintCount;) this.m_constraints[this.m_constraints.length] = new b; for (n = 0; n < u; ++n) { h = t[n]; f = h.m_fixtureA; var s = h.m_fixtureB, v = f.m_shape.m_radius, c = s.m_shape.m_radius, o = f.m_body, e = s.m_body, l = h.GetManifold(), a = r.b2MixFriction(f.GetFriction(), s.GetFriction()), nt = r.b2MixRestitution(f.GetRestitution(), s.GetRestitution()), tt = o.m_linearVelocity.x, it = o.m_linearVelocity.y, p = e.m_linearVelocity.x, w = e.m_linearVelocity.y, d = o.m_angularVelocity, ft = e.m_angularVelocity; for (r.b2Assert(l.m_pointCount > 0), i.s_worldManifold.Initialize(l, o.m_xf, v, e.m_xf, c), s = i.s_worldManifold.m_normal.x, h = i.s_worldManifold.m_normal.y, f = this.m_constraints[n], f.bodyA = o, f.bodyB = e, f.manifold = l, f.normal.x = s, f.normal.y = h, f.pointCount = l.m_pointCount, f.friction = a, f.restitution = nt, f.localPlaneNormal.x = l.m_localPlaneNormal.x, f.localPlaneNormal.y = l.m_localPlaneNormal.y, f.localPoint.x = l.m_localPoint.x, f.localPoint.y = l.m_localPoint.y, f.radius = v + c, f.type = l.m_type, v = 0; v < f.pointCount; ++v) { a = l.m_points[v]; c = f.points[v]; c.normalImpulse = a.m_normalImpulse; c.tangentImpulse = a.m_tangentImpulse; c.localPoint.SetV(a.m_localPoint); a = c.rA.x = i.s_worldManifold.m_points[v].x - o.m_sweep.c.x; nt = c.rA.y = i.s_worldManifold.m_points[v].y - o.m_sweep.c.y; var rt = c.rB.x = i.s_worldManifold.m_points[v].x - e.m_sweep.c.x, ut = c.rB.y = i.s_worldManifold.m_points[v].y - e.m_sweep.c.y, k = a * h - nt * s, y = rt * h - ut * s; k *= k; y *= y; c.normalMass = 1 / (o.m_invMass + e.m_invMass + o.m_invI * k + e.m_invI * y); g = o.m_mass * o.m_invMass + e.m_mass * e.m_invMass; g += o.m_mass * o.m_invI * k + e.m_mass * e.m_invI * y; c.equalizedMass = 1 / g; y = h; g = -s; k = a * g - nt * y; y = rt * g - ut * y; k *= k; y *= y; c.tangentMass = 1 / (o.m_invMass + e.m_invMass + o.m_invI * k + e.m_invI * y); c.velocityBias = 0; a = f.normal.x * (p + -ft * ut - tt - -d * nt) + f.normal.y * (w + ft * rt - it - d * a); a < -r.b2_velocityThreshold && (c.velocityBias += -f.restitution * a) } f.pointCount == 2 && (w = f.points[0], p = f.points[1], l = o.m_invMass, o = o.m_invI, tt = e.m_invMass, e = e.m_invI, it = w.rA.x * h - w.rA.y * s, w = w.rB.x * h - w.rB.y * s, d = p.rA.x * h - p.rA.y * s, p = p.rB.x * h - p.rB.y * s, s = l + tt + o * it * it + e * w * w, h = l + tt + o * d * d + e * p * p, e = l + tt + o * it * d + e * w * p, s * s < 100 * (s * h - e * e) ? (f.K.col1.Set(s, e), f.K.col2.Set(e, h), f.K.GetInverse(f.normalMass)) : f.pointCount = 1) } }; i.prototype.InitVelocityConstraints = function (n) { for (var t, e, o, s = 0; s < this.m_constraintCount; ++s) { var i = this.m_constraints[s], r = i.bodyA, f = i.bodyB, c = r.m_invMass, y = r.m_invI, l = f.m_invMass, p = f.m_invI, a = i.normal.x, v = i.normal.y, w = v, b = -a, u = 0, h = 0; if (n.warmStarting) for (h = i.pointCount, u = 0; u < h; ++u) t = i.points[u], t.normalImpulse *= n.dtRatio, t.tangentImpulse *= n.dtRatio, e = t.normalImpulse * a + t.tangentImpulse * w, o = t.normalImpulse * v + t.tangentImpulse * b, r.m_angularVelocity -= y * (t.rA.x * o - t.rA.y * e), r.m_linearVelocity.x -= c * e, r.m_linearVelocity.y -= c * o, f.m_angularVelocity += p * (t.rB.x * o - t.rB.y * e), f.m_linearVelocity.x += l * e, f.m_linearVelocity.y += l * o; else for (h = i.pointCount, u = 0; u < h; ++u) r = i.points[u], r.normalImpulse = 0, r.tangentImpulse = 0 } }; i.prototype.SolveVelocityConstraints = function () { for (var l, d, g, f = 0, t, n = 0, o = 0, i = 0, a = o = o = n = n = 0, s = n = n = 0, r = n = i = 0, u = 0, e, it = 0; it < this.m_constraintCount; ++it) { i = this.m_constraints[it]; var nt = i.bodyA, tt = i.bodyB, v = nt.m_angularVelocity, y = tt.m_angularVelocity, h = nt.m_linearVelocity, c = tt.m_linearVelocity, p = nt.m_invMass, b = nt.m_invI, w = tt.m_invMass, k = tt.m_invI; for (r = i.normal.x, l = u = i.normal.y, e = -r, s = i.friction, f = 0; f < i.pointCount; f++) t = i.points[f], n = c.x - y * t.rB.y - h.x + v * t.rA.y, o = c.y + y * t.rB.x - h.y - v * t.rA.x, n = n * l + o * e, n = t.tangentMass * -n, o = s * t.normalImpulse, o = rt.Clamp(t.tangentImpulse + n, -o, o), n = o - t.tangentImpulse, a = n * l, n = n * e, h.x -= p * a, h.y -= p * n, v -= b * (t.rA.x * n - t.rA.y * a), c.x += w * a, c.y += w * n, y += k * (t.rB.x * n - t.rB.y * a), t.tangentImpulse = o; if (parseInt(i.pointCount), i.pointCount == 1) t = i.points[0], n = c.x + -y * t.rB.y - h.x - -v * t.rA.y, o = c.y + y * t.rB.x - h.y - v * t.rA.x, i = n * r + o * u, n = -t.normalMass * (i - t.velocityBias), o = t.normalImpulse + n, o = o > 0 ? o : 0, n = o - t.normalImpulse, a = n * r, n = n * u, h.x -= p * a, h.y -= p * n, v -= b * (t.rA.x * n - t.rA.y * a), c.x += w * a, c.y += w * n, y += k * (t.rB.x * n - t.rB.y * a), t.normalImpulse = o; else for (t = i.points[0], f = i.points[1], n = t.normalImpulse, s = f.normalImpulse, d = (c.x - y * t.rB.y - h.x + v * t.rA.y) * r + (c.y + y * t.rB.x - h.y - v * t.rA.x) * u, g = (c.x - y * f.rB.y - h.x + v * f.rA.y) * r + (c.y + y * f.rB.x - h.y - v * f.rA.x) * u, o = d - t.velocityBias, a = g - f.velocityBias, e = i.K, o -= e.col1.x * n + e.col2.x * s, a -= e.col1.y * n + e.col2.y * s; ;) { if (e = i.normalMass, l = -(e.col1.x * o + e.col2.x * a), e = -(e.col1.y * o + e.col2.y * a), l >= 0 && e >= 0) { n = l - n; s = e - s; i = n * r; n = n * u; r = s * r; u = s * u; h.x -= p * (i + r); h.y -= p * (n + u); v -= b * (t.rA.x * n - t.rA.y * i + f.rA.x * u - f.rA.y * r); c.x += w * (i + r); c.y += w * (n + u); y += k * (t.rB.x * n - t.rB.y * i + f.rB.x * u - f.rB.y * r); t.normalImpulse = l; f.normalImpulse = e; break } if (l = -t.normalMass * o, e = 0, g = i.K.col1.y * l + a, l >= 0 && g >= 0) { n = l - n; s = e - s; i = n * r; n = n * u; r = s * r; u = s * u; h.x -= p * (i + r); h.y -= p * (n + u); v -= b * (t.rA.x * n - t.rA.y * i + f.rA.x * u - f.rA.y * r); c.x += w * (i + r); c.y += w * (n + u); y += k * (t.rB.x * n - t.rB.y * i + f.rB.x * u - f.rB.y * r); t.normalImpulse = l; f.normalImpulse = e; break } if (l = 0, e = -f.normalMass * a, d = i.K.col2.x * e + o, e >= 0 && d >= 0) { n = l - n; s = e - s; i = n * r; n = n * u; r = s * r; u = s * u; h.x -= p * (i + r); h.y -= p * (n + u); v -= b * (t.rA.x * n - t.rA.y * i + f.rA.x * u - f.rA.y * r); c.x += w * (i + r); c.y += w * (n + u); y += k * (t.rB.x * n - t.rB.y * i + f.rB.x * u - f.rB.y * r); t.normalImpulse = l; f.normalImpulse = e; break } if (e = l = 0, d = o, g = a, d >= 0 && g >= 0) { n = l - n; s = e - s; i = n * r; n = n * u; r = s * r; u = s * u; h.x -= p * (i + r); h.y -= p * (n + u); v -= b * (t.rA.x * n - t.rA.y * i + f.rA.x * u - f.rA.y * r); c.x += w * (i + r); c.y += w * (n + u); y += k * (t.rB.x * n - t.rB.y * i + f.rB.x * u - f.rB.y * r); t.normalImpulse = l; f.normalImpulse = e; break } break } nt.m_angularVelocity = v; tt.m_angularVelocity = y } }; i.prototype.FinalizeVelocityConstraints = function () { for (var r, u, n = 0; n < this.m_constraintCount; ++n) for (var i = this.m_constraints[n], f = i.manifold, t = 0; t < i.pointCount; ++t) r = f.m_points[t], u = i.points[t], r.m_normalImpulse = u.normalImpulse, r.m_tangentImpulse = u.tangentImpulse }; i.prototype.SolvePositionConstraints = function (n) { var h, l, a, e; for (n === undefined && (n = 0), h = 0, l = 0; l < this.m_constraintCount; l++) { var c = this.m_constraints[l], u = c.bodyA, f = c.bodyB, v = u.m_mass * u.m_invMass, p = u.m_mass * u.m_invI, y = f.m_mass * f.m_invMass, w = f.m_mass * f.m_invI; for (i.s_psm.Initialize(c), a = i.s_psm.m_normal, e = 0; e < c.pointCount; e++) { var o = c.points[e], s = i.s_psm.m_points[e], t = i.s_psm.m_separations[e], b = s.x - u.m_sweep.c.x, k = s.y - u.m_sweep.c.y, d = s.x - f.m_sweep.c.x; s = s.y - f.m_sweep.c.y; h = h < t ? h : t; t = rt.Clamp(n * (t + r.b2_linearSlop), -r.b2_maxLinearCorrection, 0); t = -o.equalizedMass * t; o = t * a.x; t = t * a.y; u.m_sweep.c.x -= v * o; u.m_sweep.c.y -= v * t; u.m_sweep.a -= p * (b * t - k * o); u.SynchronizeTransform(); f.m_sweep.c.x += y * o; f.m_sweep.c.y += y * t; f.m_sweep.a += w * (d * t - s * o); f.SynchronizeTransform() } } return h > -1.5 * r.b2_linearSlop }; Box2D.postDefs.push(function () { Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new ht; Box2D.Dynamics.Contacts.b2ContactSolver.s_psm = new p }); Box2D.inherit(f, Box2D.Dynamics.Contacts.b2Contact); f.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype; f.b2EdgeAndCircleContact = function () { Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments) }; f.Create = function () { return new f }; f.Destroy = function () { }; f.prototype.Reset = function (n, t) { this.__super.Reset.call(this, n, t) }; f.prototype.Evaluate = function () { var n = this.m_fixtureA.GetBody(), t = this.m_fixtureB.GetBody(); this.b2CollideEdgeAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof g ? this.m_fixtureA.GetShape() : null, n.m_xf, this.m_fixtureB.GetShape() instanceof v ? this.m_fixtureB.GetShape() : null, t.m_xf) }; f.prototype.b2CollideEdgeAndCircle = function () { }; Box2D.inherit(l, Box2D.Dynamics.Contacts.b2Contact); l.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype; l.b2NullContact = function () { Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments) }; l.prototype.b2NullContact = function () { this.__super.b2Contact.call(this) }; l.prototype.Evaluate = function () { }; Box2D.inherit(s, Box2D.Dynamics.Contacts.b2Contact); s.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype; s.b2PolyAndCircleContact = function () { Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments) }; s.Create = function () { return new s }; s.Destroy = function () { }; s.prototype.Reset = function (n, i) { this.__super.Reset.call(this, n, i); r.b2Assert(n.GetType() == t.e_polygonShape); r.b2Assert(i.GetType() == t.e_circleShape) }; s.prototype.Evaluate = function () { var n = this.m_fixtureA.m_body, t = this.m_fixtureB.m_body; d.CollidePolygonAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof y ? this.m_fixtureA.GetShape() : null, n.m_xf, this.m_fixtureB.GetShape() instanceof v ? this.m_fixtureB.GetShape() : null, t.m_xf) }; Box2D.inherit(e, Box2D.Dynamics.Contacts.b2Contact); e.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype; e.b2PolyAndEdgeContact = function () { Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments) }; e.Create = function () { return new e }; e.Destroy = function () { }; e.prototype.Reset = function (n, i) { this.__super.Reset.call(this, n, i); r.b2Assert(n.GetType() == t.e_polygonShape); r.b2Assert(i.GetType() == t.e_edgeShape) }; e.prototype.Evaluate = function () { var n = this.m_fixtureA.GetBody(), t = this.m_fixtureB.GetBody(); this.b2CollidePolyAndEdge(this.m_manifold, this.m_fixtureA.GetShape() instanceof y ? this.m_fixtureA.GetShape() : null, n.m_xf, this.m_fixtureB.GetShape() instanceof g ? this.m_fixtureB.GetShape() : null, t.m_xf) }; e.prototype.b2CollidePolyAndEdge = function () { }; Box2D.inherit(h, Box2D.Dynamics.Contacts.b2Contact); h.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype; h.b2PolygonContact = function () { Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments) }; h.Create = function () { return new h }; h.Destroy = function () { }; h.prototype.Reset = function (n, t) { this.__super.Reset.call(this, n, t) }; h.prototype.Evaluate = function () { var n = this.m_fixtureA.GetBody(), t = this.m_fixtureB.GetBody(); d.CollidePolygons(this.m_manifold, this.m_fixtureA.GetShape() instanceof y ? this.m_fixtureA.GetShape() : null, n.m_xf, this.m_fixtureB.GetShape() instanceof y ? this.m_fixtureB.GetShape() : null, t.m_xf) }; p.b2PositionSolverManifold = function () { }; p.prototype.b2PositionSolverManifold = function () { this.m_normal = new u; this.m_separations = new Vector_a2j_Number(r.b2_maxManifoldPoints); this.m_points = new Vector(r.b2_maxManifoldPoints); for (var n = 0; n < r.b2_maxManifoldPoints; n++) this.m_points[n] = new u }; p.prototype.Initialize = function (n) { var s; r.b2Assert(n.pointCount > 0); var u = 0, f = 0, t = 0, i, o = 0, e = 0; switch (n.type) { case a.e_circles: i = n.bodyA.m_xf.R; t = n.localPoint; u = n.bodyA.m_xf.position.x + (i.col1.x * t.x + i.col2.x * t.y); f = n.bodyA.m_xf.position.y + (i.col1.y * t.x + i.col2.y * t.y); i = n.bodyB.m_xf.R; t = n.points[0].localPoint; o = n.bodyB.m_xf.position.x + (i.col1.x * t.x + i.col2.x * t.y); i = n.bodyB.m_xf.position.y + (i.col1.y * t.x + i.col2.y * t.y); t = o - u; e = i - f; s = t * t + e * e; s > Number.MIN_VALUE * Number.MIN_VALUE ? (s = Math.sqrt(s), this.m_normal.x = t / s, this.m_normal.y = e / s) : (this.m_normal.x = 1, this.m_normal.y = 0); this.m_points[0].x = .5 * (u + o); this.m_points[0].y = .5 * (f + i); this.m_separations[0] = t * this.m_normal.x + e * this.m_normal.y - n.radius; break; case a.e_faceA: for (i = n.bodyA.m_xf.R, t = n.localPlaneNormal, this.m_normal.x = i.col1.x * t.x + i.col2.x * t.y, this.m_normal.y = i.col1.y * t.x + i.col2.y * t.y, i = n.bodyA.m_xf.R, t = n.localPoint, o = n.bodyA.m_xf.position.x + (i.col1.x * t.x + i.col2.x * t.y), e = n.bodyA.m_xf.position.y + (i.col1.y * t.x + i.col2.y * t.y), i = n.bodyB.m_xf.R, u = 0; u < n.pointCount; ++u) t = n.points[u].localPoint, f = n.bodyB.m_xf.position.x + (i.col1.x * t.x + i.col2.x * t.y), t = n.bodyB.m_xf.position.y + (i.col1.y * t.x + i.col2.y * t.y), this.m_separations[u] = (f - o) * this.m_normal.x + (t - e) * this.m_normal.y - n.radius, this.m_points[u].x = f, this.m_points[u].y = t; break; case a.e_faceB: for (i = n.bodyB.m_xf.R, t = n.localPlaneNormal, this.m_normal.x = i.col1.x * t.x + i.col2.x * t.y, this.m_normal.y = i.col1.y * t.x + i.col2.y * t.y, i = n.bodyB.m_xf.R, t = n.localPoint, o = n.bodyB.m_xf.position.x + (i.col1.x * t.x + i.col2.x * t.y), e = n.bodyB.m_xf.position.y + (i.col1.y * t.x + i.col2.y * t.y), i = n.bodyA.m_xf.R, u = 0; u < n.pointCount; ++u) t = n.points[u].localPoint, f = n.bodyA.m_xf.position.x + (i.col1.x * t.x + i.col2.x * t.y), t = n.bodyA.m_xf.position.y + (i.col1.y * t.x + i.col2.y * t.y), this.m_separations[u] = (f - o) * this.m_normal.x + (t - e) * this.m_normal.y - n.radius, this.m_points[u].Set(f, t); this.m_normal.x *= -1; this.m_normal.y *= -1 } }; Box2D.postDefs.push(function () { Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new u; Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new u }) }(), function () { var s = Box2D.Common.Math.b2Mat22, h = Box2D.Common.Math.b2Math, n = Box2D.Common.Math.b2Vec2, c = Box2D.Common.b2Color, i = Box2D.Dynamics.Controllers.b2BuoyancyController, u = Box2D.Dynamics.Controllers.b2ConstantAccelController, f = Box2D.Dynamics.Controllers.b2ConstantForceController, t = Box2D.Dynamics.Controllers.b2Controller, o = Box2D.Dynamics.Controllers.b2ControllerEdge, e = Box2D.Dynamics.Controllers.b2GravityController, r = Box2D.Dynamics.Controllers.b2TensorDampingController; Box2D.inherit(i, Box2D.Dynamics.Controllers.b2Controller); i.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype; i.b2BuoyancyController = function () { Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments); this.normal = new n(0, -1); this.density = this.offset = 0; this.velocity = new n(0, 0); this.linearDrag = 2; this.angularDrag = 1; this.useDensity = !1; this.useWorldGravity = !0; this.gravity = null }; i.prototype.Step = function () { var s, t, o, u, h; if (this.m_bodyList) for (this.useWorldGravity && (this.gravity = this.GetWorld().GetGravity().Copy()), s = this.m_bodyList; s; s = s.nextBody) if (t = s.body, t.IsAwake() != !1) { for (var f = new n, i = new n, r = 0, e = 0, c = t.GetFixtureList() ; c; c = c.GetNext()) o = new n, u = c.GetShape().ComputeSubmergedArea(this.normal, this.offset, t.GetTransform(), o), r += u, f.x += u * o.x, f.y += u * o.y, h = 0, h = 1, e += u * h, i.x += u * o.x * h, i.y += u * o.y * h; f.x /= r; f.y /= r; i.x /= e; i.y /= e; r < Number.MIN_VALUE || (e = this.gravity.GetNegative(), e.Multiply(this.density * r), t.ApplyForce(e, i), i = t.GetLinearVelocityFromWorldPoint(f), i.Subtract(this.velocity), i.Multiply(-this.linearDrag * r), t.ApplyForce(i, f), t.ApplyTorque(-t.GetInertia() / t.GetMass() * r * t.GetAngularVelocity() * this.angularDrag)) } }; i.prototype.Draw = function (t) { var i = new n, r = new n, u; i.x = this.normal.x * this.offset + this.normal.y * 1e3; i.y = this.normal.y * this.offset - this.normal.x * 1e3; r.x = this.normal.x * this.offset - this.normal.y * 1e3; r.y = this.normal.y * this.offset + this.normal.x * 1e3; u = new c(0, 0, 1); t.DrawSegment(i, r, u) }; Box2D.inherit(u, Box2D.Dynamics.Controllers.b2Controller); u.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype; u.b2ConstantAccelController = function () { Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments); this.A = new n(0, 0) }; u.prototype.Step = function (t) { var i, r; for (t = new n(this.A.x * t.dt, this.A.y * t.dt), i = this.m_bodyList; i; i = i.nextBody) r = i.body, r.IsAwake() && r.SetLinearVelocity(new n(r.GetLinearVelocity().x + t.x, r.GetLinearVelocity().y + t.y)) }; Box2D.inherit(f, Box2D.Dynamics.Controllers.b2Controller); f.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype; f.b2ConstantForceController = function () { Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments); this.F = new n(0, 0) }; f.prototype.Step = function () { for (var t, n = this.m_bodyList; n; n = n.nextBody) t = n.body, t.IsAwake() && t.ApplyForce(this.F, t.GetWorldCenter()) }; t.b2Controller = function () { }; t.prototype.Step = function () { }; t.prototype.Draw = function () { }; t.prototype.AddBody = function (n) { var t = new o; t.controller = this; t.body = n; t.nextBody = this.m_bodyList; t.prevBody = null; this.m_bodyList = t; t.nextBody && (t.nextBody.prevBody = t); this.m_bodyCount++; t.nextController = n.m_controllerList; t.prevController = null; n.m_controllerList = t; t.nextController && (t.nextController.prevController = t); n.m_controllerCount++ }; t.prototype.RemoveBody = function (n) { for (var t = n.m_controllerList; t && t.controller != this;) t = t.nextController; t.prevBody && (t.prevBody.nextBody = t.nextBody); t.nextBody && (t.nextBody.prevBody = t.prevBody); t.nextController && (t.nextController.prevController = t.prevController); t.prevController && (t.prevController.nextController = t.nextController); this.m_bodyList == t && (this.m_bodyList = t.nextBody); n.m_controllerList == t && (n.m_controllerList = t.nextController); n.m_controllerCount--; this.m_bodyCount-- }; t.prototype.Clear = function () { for (; this.m_bodyList;) this.RemoveBody(this.m_bodyList.body) }; t.prototype.GetNext = function () { return this.m_next }; t.prototype.GetWorld = function () { return this.m_world }; t.prototype.GetBodyList = function () { return this.m_bodyList }; o.b2ControllerEdge = function () { }; Box2D.inherit(e, Box2D.Dynamics.Controllers.b2Controller); e.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype; e.b2GravityController = function () { Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments); this.G = 1; this.invSqr = !0 }; e.prototype.Step = function () { var i = null, r = null, e = null, c = 0, u = null, f = null, o = null, t = 0, s = 0, h = 0; if (t = null, this.invSqr) for (i = this.m_bodyList; i; i = i.nextBody) for (r = i.body, e = r.GetWorldCenter(), c = r.GetMass(), u = this.m_bodyList; u != i; u = u.nextBody) f = u.body, o = f.GetWorldCenter(), t = o.x - e.x, s = o.y - e.y, h = t * t + s * s, h < Number.MIN_VALUE || (t = new n(t, s), t.Multiply(this.G / h / Math.sqrt(h) * c * f.GetMass()), r.IsAwake() && r.ApplyForce(t, e), t.Multiply(-1), f.IsAwake() && f.ApplyForce(t, o)); else for (i = this.m_bodyList; i; i = i.nextBody) for (r = i.body, e = r.GetWorldCenter(), c = r.GetMass(), u = this.m_bodyList; u != i; u = u.nextBody) f = u.body, o = f.GetWorldCenter(), t = o.x - e.x, s = o.y - e.y, h = t * t + s * s, h < Number.MIN_VALUE || (t = new n(t, s), t.Multiply(this.G / h * c * f.GetMass()), r.IsAwake() && r.ApplyForce(t, e), t.Multiply(-1), f.IsAwake() && f.ApplyForce(t, o)) }; Box2D.inherit(r, Box2D.Dynamics.Controllers.b2Controller); r.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype; r.b2TensorDampingController = function () { Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments); this.T = new s; this.maxTimestep = 0 }; r.prototype.SetAxisAligned = function (n, t) { n === undefined && (n = 0); t === undefined && (t = 0); this.T.col1.x = -n; this.T.col1.y = 0; this.T.col2.x = 0; this.T.col2.y = -t; this.maxTimestep = n > 0 || t > 0 ? 1 / Math.max(n, t) : 0 }; r.prototype.Step = function (t) { var r, i, u; if (t = t.dt, !(t <= Number.MIN_VALUE)) for (t > this.maxTimestep && this.maxTimestep > 0 && (t = this.maxTimestep), r = this.m_bodyList; r; r = r.nextBody) i = r.body, i.IsAwake() && (u = i.GetWorldVector(h.MulMV(this.T, i.GetLocalVector(i.GetLinearVelocity()))), i.SetLinearVelocity(new n(i.GetLinearVelocity().x + u.x * t, i.GetLinearVelocity().y + u.y * t))) } }(), function () { var r = Box2D.Common.b2Settings, l = Box2D.Common.Math.b2Mat22, ut = Box2D.Common.Math.b2Mat33, i = Box2D.Common.Math.b2Math, t = Box2D.Common.Math.b2Vec2, y = Box2D.Common.Math.b2Vec3, h = Box2D.Dynamics.Joints.b2DistanceJoint, p = Box2D.Dynamics.Joints.b2DistanceJointDef, c = Box2D.Dynamics.Joints.b2FrictionJoint, w = Box2D.Dynamics.Joints.b2FrictionJointDef, a = Box2D.Dynamics.Joints.b2GearJoint, tt = Box2D.Dynamics.Joints.b2GearJointDef, it = Box2D.Dynamics.Joints.b2Jacobian, n = Box2D.Dynamics.Joints.b2Joint, et = Box2D.Dynamics.Joints.b2JointDef, ft = Box2D.Dynamics.Joints.b2JointEdge, e = Box2D.Dynamics.Joints.b2LineJoint, b = Box2D.Dynamics.Joints.b2LineJointDef, s = Box2D.Dynamics.Joints.b2MouseJoint, rt = Box2D.Dynamics.Joints.b2MouseJointDef, f = Box2D.Dynamics.Joints.b2PrismaticJoint, k = Box2D.Dynamics.Joints.b2PrismaticJointDef, o = Box2D.Dynamics.Joints.b2PulleyJoint, d = Box2D.Dynamics.Joints.b2PulleyJointDef, u = Box2D.Dynamics.Joints.b2RevoluteJoint, g = Box2D.Dynamics.Joints.b2RevoluteJointDef, v = Box2D.Dynamics.Joints.b2WeldJoint, nt = Box2D.Dynamics.Joints.b2WeldJointDef; Box2D.inherit(h, Box2D.Dynamics.Joints.b2Joint); h.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype; h.b2DistanceJoint = function () { Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments); this.m_localAnchor1 = new t; this.m_localAnchor2 = new t; this.m_u = new t }; h.prototype.GetAnchorA = function () { return this.m_bodyA.GetWorldPoint(this.m_localAnchor1) }; h.prototype.GetAnchorB = function () { return this.m_bodyB.GetWorldPoint(this.m_localAnchor2) }; h.prototype.GetReactionForce = function (n) { return n === undefined && (n = 0), new t(n * this.m_impulse * this.m_u.x, n * this.m_impulse * this.m_u.y) }; h.prototype.GetReactionTorque = function () { return 0 }; h.prototype.GetLength = function () { return this.m_length }; h.prototype.SetLength = function (n) { n === undefined && (n = 0); this.m_length = n }; h.prototype.GetFrequency = function () { return this.m_frequencyHz }; h.prototype.SetFrequency = function (n) { n === undefined && (n = 0); this.m_frequencyHz = n }; h.prototype.GetDampingRatio = function () { return this.m_dampingRatio }; h.prototype.SetDampingRatio = function (n) { n === undefined && (n = 0); this.m_dampingRatio = n }; h.prototype.b2DistanceJoint = function (n) { this.__super.b2Joint.call(this, n); this.m_localAnchor1.SetV(n.localAnchorA); this.m_localAnchor2.SetV(n.localAnchorB); this.m_length = n.length; this.m_frequencyHz = n.frequencyHz; this.m_dampingRatio = n.dampingRatio; this.m_bias = this.m_gamma = this.m_impulse = 0 }; h.prototype.InitVelocityConstraints = function (n) { var t, f = 0, i = this.m_bodyA, u = this.m_bodyB, e, o, s, h, c, l; t = i.m_xf.R; e = this.m_localAnchor1.x - i.m_sweep.localCenter.x; o = this.m_localAnchor1.y - i.m_sweep.localCenter.y; f = t.col1.x * e + t.col2.x * o; o = t.col1.y * e + t.col2.y * o; e = f; t = u.m_xf.R; s = this.m_localAnchor2.x - u.m_sweep.localCenter.x; h = this.m_localAnchor2.y - u.m_sweep.localCenter.y; f = t.col1.x * s + t.col2.x * h; h = t.col1.y * s + t.col2.y * h; s = f; this.m_u.x = u.m_sweep.c.x + s - i.m_sweep.c.x - e; this.m_u.y = u.m_sweep.c.y + h - i.m_sweep.c.y - o; f = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y); f > r.b2_linearSlop ? this.m_u.Multiply(1 / f) : this.m_u.SetZero(); t = e * this.m_u.y - o * this.m_u.x; c = s * this.m_u.y - h * this.m_u.x; t = i.m_invMass + i.m_invI * t * t + u.m_invMass + u.m_invI * c * c; this.m_mass = t != 0 ? 1 / t : 0; this.m_frequencyHz > 0 && (f = f - this.m_length, c = 2 * Math.PI * this.m_frequencyHz, l = this.m_mass * c * c, this.m_gamma = n.dt * (2 * this.m_mass * this.m_dampingRatio * c + n.dt * l), this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0, this.m_bias = f * n.dt * l * this.m_gamma, this.m_mass = t + this.m_gamma, this.m_mass = this.m_mass != 0 ? 1 / this.m_mass : 0); n.warmStarting ? (this.m_impulse *= n.dtRatio, n = this.m_impulse * this.m_u.x, t = this.m_impulse * this.m_u.y, i.m_linearVelocity.x -= i.m_invMass * n, i.m_linearVelocity.y -= i.m_invMass * t, i.m_angularVelocity -= i.m_invI * (e * t - o * n), u.m_linearVelocity.x += u.m_invMass * n, u.m_linearVelocity.y += u.m_invMass * t, u.m_angularVelocity += u.m_invI * (s * t - h * n)) : this.m_impulse = 0 }; h.prototype.SolveVelocityConstraints = function () { var n, t = this.m_bodyA, i = this.m_bodyB, u, f; n = t.m_xf.R; var e = this.m_localAnchor1.x - t.m_sweep.localCenter.x, o = this.m_localAnchor1.y - t.m_sweep.localCenter.y, r = n.col1.x * e + n.col2.x * o; o = n.col1.y * e + n.col2.y * o; e = r; n = i.m_xf.R; u = this.m_localAnchor2.x - i.m_sweep.localCenter.x; f = this.m_localAnchor2.y - i.m_sweep.localCenter.y; r = n.col1.x * u + n.col2.x * f; f = n.col1.y * u + n.col2.y * f; u = r; r = -this.m_mass * (this.m_u.x * (i.m_linearVelocity.x + -i.m_angularVelocity * f - (t.m_linearVelocity.x + -t.m_angularVelocity * o)) + this.m_u.y * (i.m_linearVelocity.y + i.m_angularVelocity * u - (t.m_linearVelocity.y + t.m_angularVelocity * e)) + this.m_bias + this.m_gamma * this.m_impulse); this.m_impulse += r; n = r * this.m_u.x; r = r * this.m_u.y; t.m_linearVelocity.x -= t.m_invMass * n; t.m_linearVelocity.y -= t.m_invMass * r; t.m_angularVelocity -= t.m_invI * (e * r - o * n); i.m_linearVelocity.x += i.m_invMass * n; i.m_linearVelocity.y += i.m_invMass * r; i.m_angularVelocity += i.m_invI * (u * r - f * n) }; h.prototype.SolvePositionConstraints = function () { var n, t, u, o, s, e, l; if (this.m_frequencyHz > 0) return !0; t = this.m_bodyA; u = this.m_bodyB; n = t.m_xf.R; var h = this.m_localAnchor1.x - t.m_sweep.localCenter.x, c = this.m_localAnchor1.y - t.m_sweep.localCenter.y, f = n.col1.x * h + n.col2.x * c; return c = n.col1.y * h + n.col2.y * c, h = f, n = u.m_xf.R, o = this.m_localAnchor2.x - u.m_sweep.localCenter.x, s = this.m_localAnchor2.y - u.m_sweep.localCenter.y, f = n.col1.x * o + n.col2.x * s, s = n.col1.y * o + n.col2.y * s, o = f, f = u.m_sweep.c.x + o - t.m_sweep.c.x - h, e = u.m_sweep.c.y + s - t.m_sweep.c.y - c, n = Math.sqrt(f * f + e * e), f /= n, e /= n, n = n - this.m_length, n = i.Clamp(n, -r.b2_maxLinearCorrection, r.b2_maxLinearCorrection), l = -this.m_mass * n, this.m_u.Set(f, e), f = l * this.m_u.x, e = l * this.m_u.y, t.m_sweep.c.x -= t.m_invMass * f, t.m_sweep.c.y -= t.m_invMass * e, t.m_sweep.a -= t.m_invI * (h * e - c * f), u.m_sweep.c.x += u.m_invMass * f, u.m_sweep.c.y += u.m_invMass * e, u.m_sweep.a += u.m_invI * (o * e - s * f), t.SynchronizeTransform(), u.SynchronizeTransform(), i.Abs(n) < r.b2_linearSlop }; Box2D.inherit(p, Box2D.Dynamics.Joints.b2JointDef); p.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype; p.b2DistanceJointDef = function () { Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments); this.localAnchorA = new t; this.localAnchorB = new t }; p.prototype.b2DistanceJointDef = function () { this.__super.b2JointDef.call(this); this.type = n.e_distanceJoint; this.length = 1; this.dampingRatio = this.frequencyHz = 0 }; p.prototype.Initialize = function (n, t, i, r) { this.bodyA = n; this.bodyB = t; this.localAnchorA.SetV(this.bodyA.GetLocalPoint(i)); this.localAnchorB.SetV(this.bodyB.GetLocalPoint(r)); n = r.x - i.x; i = r.y - i.y; this.length = Math.sqrt(n * n + i * i); this.dampingRatio = this.frequencyHz = 0 }; Box2D.inherit(c, Box2D.Dynamics.Joints.b2Joint); c.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype; c.b2FrictionJoint = function () { Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments); this.m_localAnchorA = new t; this.m_localAnchorB = new t; this.m_linearMass = new l; this.m_linearImpulse = new t }; c.prototype.GetAnchorA = function () { return this.m_bodyA.GetWorldPoint(this.m_localAnchorA) }; c.prototype.GetAnchorB = function () { return this.m_bodyB.GetWorldPoint(this.m_localAnchorB) }; c.prototype.GetReactionForce = function (n) { return n === undefined && (n = 0), new t(n * this.m_linearImpulse.x, n * this.m_linearImpulse.y) }; c.prototype.GetReactionTorque = function (n) { return n === undefined && (n = 0), n * this.m_angularImpulse }; c.prototype.SetMaxForce = function (n) { n === undefined && (n = 0); this.m_maxForce = n }; c.prototype.GetMaxForce = function () { return this.m_maxForce }; c.prototype.SetMaxTorque = function (n) { n === undefined && (n = 0); this.m_maxTorque = n }; c.prototype.GetMaxTorque = function () { return this.m_maxTorque }; c.prototype.b2FrictionJoint = function (n) { this.__super.b2Joint.call(this, n); this.m_localAnchorA.SetV(n.localAnchorA); this.m_localAnchorB.SetV(n.localAnchorB); this.m_linearMass.SetZero(); this.m_angularMass = 0; this.m_linearImpulse.SetZero(); this.m_angularImpulse = 0; this.m_maxForce = n.maxForce; this.m_maxTorque = n.maxTorque }; c.prototype.InitVelocityConstraints = function (n) { var t, r = 0, s = this.m_bodyA, h = this.m_bodyB, u, f, e, o; t = s.m_xf.R; u = this.m_localAnchorA.x - s.m_sweep.localCenter.x; f = this.m_localAnchorA.y - s.m_sweep.localCenter.y; r = t.col1.x * u + t.col2.x * f; f = t.col1.y * u + t.col2.y * f; u = r; t = h.m_xf.R; e = this.m_localAnchorB.x - h.m_sweep.localCenter.x; o = this.m_localAnchorB.y - h.m_sweep.localCenter.y; r = t.col1.x * e + t.col2.x * o; o = t.col1.y * e + t.col2.y * o; e = r; t = s.m_invMass; r = h.m_invMass; var c = s.m_invI, a = h.m_invI, i = new l; i.col1.x = t + r; i.col2.x = 0; i.col1.y = 0; i.col2.y = t + r; i.col1.x += c * f * f; i.col2.x += -c * u * f; i.col1.y += -c * u * f; i.col2.y += c * u * u; i.col1.x += a * o * o; i.col2.x += -a * e * o; i.col1.y += -a * e * o; i.col2.y += a * e * e; i.GetInverse(this.m_linearMass); this.m_angularMass = c + a; this.m_angularMass > 0 && (this.m_angularMass = 1 / this.m_angularMass); n.warmStarting ? (this.m_linearImpulse.x *= n.dtRatio, this.m_linearImpulse.y *= n.dtRatio, this.m_angularImpulse *= n.dtRatio, n = this.m_linearImpulse, s.m_linearVelocity.x -= t * n.x, s.m_linearVelocity.y -= t * n.y, s.m_angularVelocity -= c * (u * n.y - f * n.x + this.m_angularImpulse), h.m_linearVelocity.x += r * n.x, h.m_linearVelocity.y += r * n.y, h.m_angularVelocity += a * (e * n.y - o * n.x + this.m_angularImpulse)) : (this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0) }; c.prototype.SolveVelocityConstraints = function (n) { var r, u = 0, f = this.m_bodyA, e = this.m_bodyB, v = f.m_linearVelocity, o = f.m_angularVelocity, y = e.m_linearVelocity, s = e.m_angularVelocity, p = f.m_invMass, w = e.m_invMass, b = f.m_invI, k = e.m_invI, h, c, l, a, d; r = f.m_xf.R; h = this.m_localAnchorA.x - f.m_sweep.localCenter.x; c = this.m_localAnchorA.y - f.m_sweep.localCenter.y; u = r.col1.x * h + r.col2.x * c; c = r.col1.y * h + r.col2.y * c; h = u; r = e.m_xf.R; l = this.m_localAnchorB.x - e.m_sweep.localCenter.x; a = this.m_localAnchorB.y - e.m_sweep.localCenter.y; u = r.col1.x * l + r.col2.x * a; a = r.col1.y * l + r.col2.y * a; l = u; r = 0; u = -this.m_angularMass * (s - o); d = this.m_angularImpulse; r = n.dt * this.m_maxTorque; this.m_angularImpulse = i.Clamp(this.m_angularImpulse + u, -r, r); u = this.m_angularImpulse - d; o -= b * u; s += k * u; r = i.MulMV(this.m_linearMass, new t(-(y.x - s * a - v.x + o * c), -(y.y + s * l - v.y - o * h))); u = this.m_linearImpulse.Copy(); this.m_linearImpulse.Add(r); r = n.dt * this.m_maxForce; this.m_linearImpulse.LengthSquared() > r * r && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.Multiply(r)); r = i.SubtractVV(this.m_linearImpulse, u); v.x -= p * r.x; v.y -= p * r.y; o -= b * (h * r.y - c * r.x); y.x += w * r.x; y.y += w * r.y; s += k * (l * r.y - a * r.x); f.m_angularVelocity = o; e.m_angularVelocity = s }; c.prototype.SolvePositionConstraints = function () { return !0 }; Box2D.inherit(w, Box2D.Dynamics.Joints.b2JointDef); w.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype; w.b2FrictionJointDef = function () { Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments); this.localAnchorA = new t; this.localAnchorB = new t }; w.prototype.b2FrictionJointDef = function () { this.__super.b2JointDef.call(this); this.type = n.e_frictionJoint; this.maxTorque = this.maxForce = 0 }; w.prototype.Initialize = function (n, t, i) { this.bodyA = n; this.bodyB = t; this.localAnchorA.SetV(this.bodyA.GetLocalPoint(i)); this.localAnchorB.SetV(this.bodyB.GetLocalPoint(i)) }; Box2D.inherit(a, Box2D.Dynamics.Joints.b2Joint); a.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype; a.b2GearJoint = function () { Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments); this.m_groundAnchor1 = new t; this.m_groundAnchor2 = new t; this.m_localAnchor1 = new t; this.m_localAnchor2 = new t; this.m_J = new it }; a.prototype.GetAnchorA = function () { return this.m_bodyA.GetWorldPoint(this.m_localAnchor1) }; a.prototype.GetAnchorB = function () { return this.m_bodyB.GetWorldPoint(this.m_localAnchor2) }; a.prototype.GetReactionForce = function (n) { return n === undefined && (n = 0), new t(n * this.m_impulse * this.m_J.linearB.x, n * this.m_impulse * this.m_J.linearB.y) }; a.prototype.GetReactionTorque = function (n) { n === undefined && (n = 0); var t = this.m_bodyB.m_xf.R, i = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x, r = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y, u = t.col1.x * i + t.col2.x * r; return r = t.col1.y * i + t.col2.y * r, i = u, n * (this.m_impulse * this.m_J.angularB - i * this.m_impulse * this.m_J.linearB.y + r * this.m_impulse * this.m_J.linearB.x) }; a.prototype.GetRatio = function () { return this.m_ratio }; a.prototype.SetRatio = function (n) { n === undefined && (n = 0); this.m_ratio = n }; a.prototype.b2GearJoint = function (t) { var e, o, i, r; this.__super.b2Joint.call(this, t); e = parseInt(t.joint1.m_type); o = parseInt(t.joint2.m_type); this.m_prismatic2 = this.m_revolute2 = this.m_prismatic1 = this.m_revolute1 = null; i = 0; r = 0; this.m_ground1 = t.joint1.GetBodyA(); this.m_bodyA = t.joint1.GetBodyB(); e == n.e_revoluteJoint ? (this.m_revolute1 = t.joint1 instanceof u ? t.joint1 : null, this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1), this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2), i = this.m_revolute1.GetJointAngle()) : (this.m_prismatic1 = t.joint1 instanceof f ? t.joint1 : null, this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1), this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2), i = this.m_prismatic1.GetJointTranslation()); this.m_ground2 = t.joint2.GetBodyA(); this.m_bodyB = t.joint2.GetBodyB(); o == n.e_revoluteJoint ? (this.m_revolute2 = t.joint2 instanceof u ? t.joint2 : null, this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1), this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2), r = this.m_revolute2.GetJointAngle()) : (this.m_prismatic2 = t.joint2 instanceof f ? t.joint2 : null, this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1), this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2), r = this.m_prismatic2.GetJointTranslation()); this.m_ratio = t.ratio; this.m_constant = i + this.m_ratio * r; this.m_impulse = 0 }; a.prototype.InitVelocityConstraints = function (n) { var t = this.m_ground1, c = this.m_ground2, u = this.m_bodyA, f = this.m_bodyB, o = 0, r = 0, i = 0, e = 0, h = i = 0, s = 0; this.m_J.SetZero(); this.m_revolute1 ? (this.m_J.angularA = -1, s += u.m_invI) : (t = t.m_xf.R, r = this.m_prismatic1.m_localXAxis1, o = t.col1.x * r.x + t.col2.x * r.y, r = t.col1.y * r.x + t.col2.y * r.y, t = u.m_xf.R, i = this.m_localAnchor1.x - u.m_sweep.localCenter.x, e = this.m_localAnchor1.y - u.m_sweep.localCenter.y, h = t.col1.x * i + t.col2.x * e, e = t.col1.y * i + t.col2.y * e, i = h, i = i * r - e * o, this.m_J.linearA.Set(-o, -r), this.m_J.angularA = -i, s += u.m_invMass + u.m_invI * i * i); this.m_revolute2 ? (this.m_J.angularB = -this.m_ratio, s += this.m_ratio * this.m_ratio * f.m_invI) : (t = c.m_xf.R, r = this.m_prismatic2.m_localXAxis1, o = t.col1.x * r.x + t.col2.x * r.y, r = t.col1.y * r.x + t.col2.y * r.y, t = f.m_xf.R, i = this.m_localAnchor2.x - f.m_sweep.localCenter.x, e = this.m_localAnchor2.y - f.m_sweep.localCenter.y, h = t.col1.x * i + t.col2.x * e, e = t.col1.y * i + t.col2.y * e, i = h, i = i * r - e * o, this.m_J.linearB.Set(-this.m_ratio * o, -this.m_ratio * r), this.m_J.angularB = -this.m_ratio * i, s += this.m_ratio * this.m_ratio * (f.m_invMass + f.m_invI * i * i)); this.m_mass = s > 0 ? 1 / s : 0; n.warmStarting ? (u.m_linearVelocity.x += u.m_invMass * this.m_impulse * this.m_J.linearA.x, u.m_linearVelocity.y += u.m_invMass * this.m_impulse * this.m_J.linearA.y, u.m_angularVelocity += u.m_invI * this.m_impulse * this.m_J.angularA, f.m_linearVelocity.x += f.m_invMass * this.m_impulse * this.m_J.linearB.x, f.m_linearVelocity.y += f.m_invMass * this.m_impulse * this.m_J.linearB.y, f.m_angularVelocity += f.m_invI * this.m_impulse * this.m_J.angularB) : this.m_impulse = 0 }; a.prototype.SolveVelocityConstraints = function () { var n = this.m_bodyA, t = this.m_bodyB, i = -this.m_mass * this.m_J.Compute(n.m_linearVelocity, n.m_angularVelocity, t.m_linearVelocity, t.m_angularVelocity); this.m_impulse += i; n.m_linearVelocity.x += n.m_invMass * i * this.m_J.linearA.x; n.m_linearVelocity.y += n.m_invMass * i * this.m_J.linearA.y; n.m_angularVelocity += n.m_invI * i * this.m_J.angularA; t.m_linearVelocity.x += t.m_invMass * i * this.m_J.linearB.x; t.m_linearVelocity.y += t.m_invMass * i * this.m_J.linearB.y; t.m_angularVelocity += t.m_invI * i * this.m_J.angularB }; a.prototype.SolvePositionConstraints = function () { var t = this.m_bodyA, i = this.m_bodyB, n = 0, u = 0; return n = this.m_revolute1 ? this.m_revolute1.GetJointAngle() : this.m_prismatic1.GetJointTranslation(), u = this.m_revolute2 ? this.m_revolute2.GetJointAngle() : this.m_prismatic2.GetJointTranslation(), n = -this.m_mass * (this.m_constant - (n + this.m_ratio * u)), t.m_sweep.c.x += t.m_invMass * n * this.m_J.linearA.x, t.m_sweep.c.y += t.m_invMass * n * this.m_J.linearA.y, t.m_sweep.a += t.m_invI * n * this.m_J.angularA, i.m_sweep.c.x += i.m_invMass * n * this.m_J.linearB.x, i.m_sweep.c.y += i.m_invMass * n * this.m_J.linearB.y, i.m_sweep.a += i.m_invI * n * this.m_J.angularB, t.SynchronizeTransform(), i.SynchronizeTransform(), 0 < r.b2_linearSlop }; Box2D.inherit(tt, Box2D.Dynamics.Joints.b2JointDef); tt.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype; tt.b2GearJointDef = function () { Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments) }; tt.prototype.b2GearJointDef = function () { this.__super.b2JointDef.call(this); this.type = n.e_gearJoint; this.joint2 = this.joint1 = null; this.ratio = 1 }; it.b2Jacobian = function () { this.linearA = new t; this.linearB = new t }; it.prototype.SetZero = function () { this.linearA.SetZero(); this.angularA = 0; this.linearB.SetZero(); this.angularB = 0 }; it.prototype.Set = function (n, t, i, r) { t === undefined && (t = 0); r === undefined && (r = 0); this.linearA.SetV(n); this.angularA = t; this.linearB.SetV(i); this.angularB = r }; it.prototype.Compute = function (n, t, i, r) { return t === undefined && (t = 0), r === undefined && (r = 0), this.linearA.x * n.x + this.linearA.y * n.y + this.angularA * t + (this.linearB.x * i.x + this.linearB.y * i.y) + this.angularB * r }; n.b2Joint = function () { this.m_edgeA = new ft; this.m_edgeB = new ft; this.m_localCenterA = new t; this.m_localCenterB = new t }; n.prototype.GetType = function () { return this.m_type }; n.prototype.GetAnchorA = function () { return null }; n.prototype.GetAnchorB = function () { return null }; n.prototype.GetReactionForce = function () { return null }; n.prototype.GetReactionTorque = function () { return 0 }; n.prototype.GetBodyA = function () { return this.m_bodyA }; n.prototype.GetBodyB = function () { return this.m_bodyB }; n.prototype.GetNext = function () { return this.m_next }; n.prototype.GetUserData = function () { return this.m_userData }; n.prototype.SetUserData = function (n) { this.m_userData = n }; n.prototype.IsActive = function () { return this.m_bodyA.IsActive() && this.m_bodyB.IsActive() }; n.Create = function (t) { var i = null; switch (t.type) { case n.e_distanceJoint: i = new h(t instanceof p ? t : null); break; case n.e_mouseJoint: i = new s(t instanceof rt ? t : null); break; case n.e_prismaticJoint: i = new f(t instanceof k ? t : null); break; case n.e_revoluteJoint: i = new u(t instanceof g ? t : null); break; case n.e_pulleyJoint: i = new o(t instanceof d ? t : null); break; case n.e_gearJoint: i = new a(t instanceof tt ? t : null); break; case n.e_lineJoint: i = new e(t instanceof b ? t : null); break; case n.e_weldJoint: i = new v(t instanceof nt ? t : null); break; case n.e_frictionJoint: i = new c(t instanceof w ? t : null) } return i }; n.Destroy = function () { }; n.prototype.b2Joint = function (n) { r.b2Assert(n.bodyA != n.bodyB); this.m_type = n.type; this.m_next = this.m_prev = null; this.m_bodyA = n.bodyA; this.m_bodyB = n.bodyB; this.m_collideConnected = n.collideConnected; this.m_islandFlag = !1; this.m_userData = n.userData }; n.prototype.InitVelocityConstraints = function () { }; n.prototype.SolveVelocityConstraints = function () { }; n.prototype.FinalizeVelocityConstraints = function () { }; n.prototype.SolvePositionConstraints = function () { return !1 }; Box2D.postDefs.push(function () { Box2D.Dynamics.Joints.b2Joint.e_unknownJoint = 0; Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint = 1; Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint = 2; Box2D.Dynamics.Joints.b2Joint.e_distanceJoint = 3; Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint = 4; Box2D.Dynamics.Joints.b2Joint.e_mouseJoint = 5; Box2D.Dynamics.Joints.b2Joint.e_gearJoint = 6; Box2D.Dynamics.Joints.b2Joint.e_lineJoint = 7; Box2D.Dynamics.Joints.b2Joint.e_weldJoint = 8; Box2D.Dynamics.Joints.b2Joint.e_frictionJoint = 9; Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit = 0; Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit = 1; Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit = 2; Box2D.Dynamics.Joints.b2Joint.e_equalLimits = 3 }); et.b2JointDef = function () { }; et.prototype.b2JointDef = function () { this.type = n.e_unknownJoint; this.bodyB = this.bodyA = this.userData = null; this.collideConnected = !1 }; ft.b2JointEdge = function () { }; Box2D.inherit(e, Box2D.Dynamics.Joints.b2Joint); e.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype; e.b2LineJoint = function () { Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments); this.m_localAnchor1 = new t; this.m_localAnchor2 = new t; this.m_localXAxis1 = new t; this.m_localYAxis1 = new t; this.m_axis = new t; this.m_perp = new t; this.m_K = new l; this.m_impulse = new t }; e.prototype.GetAnchorA = function () { return this.m_bodyA.GetWorldPoint(this.m_localAnchor1) }; e.prototype.GetAnchorB = function () { return this.m_bodyB.GetWorldPoint(this.m_localAnchor2) }; e.prototype.GetReactionForce = function (n) { return n === undefined && (n = 0), new t(n * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), n * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y)) }; e.prototype.GetReactionTorque = function (n) { return n === undefined && (n = 0), n * this.m_impulse.y }; e.prototype.GetJointTranslation = function () { var n = this.m_bodyA, i = this.m_bodyB, t = n.GetWorldPoint(this.m_localAnchor1), r = i.GetWorldPoint(this.m_localAnchor2); return i = r.x - t.x, t = r.y - t.y, n = n.GetWorldVector(this.m_localXAxis1), n.x * i + n.y * t }; e.prototype.GetJointSpeed = function () { var n = this.m_bodyA, i = this.m_bodyB, t, r, u; t = n.m_xf.R; var f = this.m_localAnchor1.x - n.m_sweep.localCenter.x, e = this.m_localAnchor1.y - n.m_sweep.localCenter.y, o = t.col1.x * f + t.col2.x * e; e = t.col1.y * f + t.col2.y * e; f = o; t = i.m_xf.R; r = this.m_localAnchor2.x - i.m_sweep.localCenter.x; u = this.m_localAnchor2.y - i.m_sweep.localCenter.y; o = t.col1.x * r + t.col2.x * u; u = t.col1.y * r + t.col2.y * u; r = o; t = i.m_sweep.c.x + r - (n.m_sweep.c.x + f); o = i.m_sweep.c.y + u - (n.m_sweep.c.y + e); var s = n.GetWorldVector(this.m_localXAxis1), h = n.m_linearVelocity, c = i.m_linearVelocity; return n = n.m_angularVelocity, i = i.m_angularVelocity, t * -n * s.y + o * n * s.x + (s.x * (c.x + -i * u - h.x - -n * e) + s.y * (c.y + i * r - h.y - n * f)) }; e.prototype.IsLimitEnabled = function () { return this.m_enableLimit }; e.prototype.EnableLimit = function (n) { this.m_bodyA.SetAwake(!0); this.m_bodyB.SetAwake(!0); this.m_enableLimit = n }; e.prototype.GetLowerLimit = function () { return this.m_lowerTranslation }; e.prototype.GetUpperLimit = function () { return this.m_upperTranslation }; e.prototype.SetLimits = function (n, t) { n === undefined && (n = 0); t === undefined && (t = 0); this.m_bodyA.SetAwake(!0); this.m_bodyB.SetAwake(!0); this.m_lowerTranslation = n; this.m_upperTranslation = t }; e.prototype.IsMotorEnabled = function () { return this.m_enableMotor }; e.prototype.EnableMotor = function (n) { this.m_bodyA.SetAwake(!0); this.m_bodyB.SetAwake(!0); this.m_enableMotor = n }; e.prototype.SetMotorSpeed = function (n) { n === undefined && (n = 0); this.m_bodyA.SetAwake(!0); this.m_bodyB.SetAwake(!0); this.m_motorSpeed = n }; e.prototype.GetMotorSpeed = function () { return this.m_motorSpeed }; e.prototype.SetMaxMotorForce = function (n) { n === undefined && (n = 0); this.m_bodyA.SetAwake(!0); this.m_bodyB.SetAwake(!0); this.m_maxMotorForce = n }; e.prototype.GetMaxMotorForce = function () { return this.m_maxMotorForce }; e.prototype.GetMotorForce = function () { return this.m_motorImpulse }; e.prototype.b2LineJoint = function (t) { this.__super.b2Joint.call(this, t); this.m_localAnchor1.SetV(t.localAnchorA); this.m_localAnchor2.SetV(t.localAnchorB); this.m_localXAxis1.SetV(t.localAxisA); this.m_localYAxis1.x = -this.m_localXAxis1.y; this.m_localYAxis1.y = this.m_localXAxis1.x; this.m_impulse.SetZero(); this.m_motorImpulse = this.m_motorMass = 0; this.m_lowerTranslation = t.lowerTranslation; this.m_upperTranslation = t.upperTranslation; this.m_maxMotorForce = t.maxMotorForce; this.m_motorSpeed = t.motorSpeed; this.m_enableLimit = t.enableLimit; this.m_enableMotor = t.enableMotor; this.m_limitState = n.e_inactiveLimit; this.m_axis.SetZero(); this.m_perp.SetZero() }; e.prototype.InitVelocityConstraints = function (t) { var o = this.m_bodyA, s = this.m_bodyB, u, h = 0, l, c, f, e, a; this.m_localCenterA.SetV(o.GetLocalCenter()); this.m_localCenterB.SetV(s.GetLocalCenter()); l = o.GetTransform(); s.GetTransform(); u = o.m_xf.R; c = this.m_localAnchor1.x - this.m_localCenterA.x; f = this.m_localAnchor1.y - this.m_localCenterA.y; h = u.col1.x * c + u.col2.x * f; f = u.col1.y * c + u.col2.y * f; c = h; u = s.m_xf.R; e = this.m_localAnchor2.x - this.m_localCenterB.x; a = this.m_localAnchor2.y - this.m_localCenterB.y; h = u.col1.x * e + u.col2.x * a; a = u.col1.y * e + u.col2.y * a; e = h; u = s.m_sweep.c.x + e - o.m_sweep.c.x - c; h = s.m_sweep.c.y + a - o.m_sweep.c.y - f; this.m_invMassA = o.m_invMass; this.m_invMassB = s.m_invMass; this.m_invIA = o.m_invI; this.m_invIB = s.m_invI; this.m_axis.SetV(i.MulMV(l.R, this.m_localXAxis1)); this.m_a1 = (u + c) * this.m_axis.y - (h + f) * this.m_axis.x; this.m_a2 = e * this.m_axis.y - a * this.m_axis.x; this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2; this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1 / this.m_motorMass : 0; this.m_perp.SetV(i.MulMV(l.R, this.m_localYAxis1)); this.m_s1 = (u + c) * this.m_perp.y - (h + f) * this.m_perp.x; this.m_s2 = e * this.m_perp.y - a * this.m_perp.x; l = this.m_invMassA; c = this.m_invMassB; f = this.m_invIA; e = this.m_invIB; this.m_K.col1.x = l + c + f * this.m_s1 * this.m_s1 + e * this.m_s2 * this.m_s2; this.m_K.col1.y = f * this.m_s1 * this.m_a1 + e * this.m_s2 * this.m_a2; this.m_K.col2.x = this.m_K.col1.y; this.m_K.col2.y = l + c + f * this.m_a1 * this.m_a1 + e * this.m_a2 * this.m_a2; this.m_enableLimit ? (u = this.m_axis.x * u + this.m_axis.y * h, i.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * r.b2_linearSlop ? this.m_limitState = n.e_equalLimits : u <= this.m_lowerTranslation ? this.m_limitState != n.e_atLowerLimit && (this.m_limitState = n.e_atLowerLimit, this.m_impulse.y = 0) : u >= this.m_upperTranslation ? this.m_limitState != n.e_atUpperLimit && (this.m_limitState = n.e_atUpperLimit, this.m_impulse.y = 0) : (this.m_limitState = n.e_inactiveLimit, this.m_impulse.y = 0)) : this.m_limitState = n.e_inactiveLimit; this.m_enableMotor == !1 && (this.m_motorImpulse = 0); t.warmStarting ? (this.m_impulse.x *= t.dtRatio, this.m_impulse.y *= t.dtRatio, this.m_motorImpulse *= t.dtRatio, t = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x, u = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y, h = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1, l = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2, o.m_linearVelocity.x -= this.m_invMassA * t, o.m_linearVelocity.y -= this.m_invMassA * u, o.m_angularVelocity -= this.m_invIA * h, s.m_linearVelocity.x += this.m_invMassB * t, s.m_linearVelocity.y += this.m_invMassB * u, s.m_angularVelocity += this.m_invIB * l) : (this.m_impulse.SetZero(), this.m_motorImpulse = 0) }; e.prototype.SolveVelocityConstraints = function (r) { var a = this.m_bodyA, v = this.m_bodyB, o = a.m_linearVelocity, c = a.m_angularVelocity, s = v.m_linearVelocity, l = v.m_angularVelocity, f = 0, u = 0, h = 0, e = 0; this.m_enableMotor && this.m_limitState != n.e_equalLimits && (e = this.m_motorMass * (this.m_motorSpeed - (this.m_axis.x * (s.x - o.x) + this.m_axis.y * (s.y - o.y) + this.m_a2 * l - this.m_a1 * c)), f = this.m_motorImpulse, u = r.dt * this.m_maxMotorForce, this.m_motorImpulse = i.Clamp(this.m_motorImpulse + e, -u, u), e = this.m_motorImpulse - f, f = e * this.m_axis.x, u = e * this.m_axis.y, h = e * this.m_a1, e = e * this.m_a2, o.x -= this.m_invMassA * f, o.y -= this.m_invMassA * u, c -= this.m_invIA * h, s.x += this.m_invMassB * f, s.y += this.m_invMassB * u, l += this.m_invIB * e); u = this.m_perp.x * (s.x - o.x) + this.m_perp.y * (s.y - o.y) + this.m_s2 * l - this.m_s1 * c; this.m_enableLimit && this.m_limitState != n.e_inactiveLimit ? (h = this.m_axis.x * (s.x - o.x) + this.m_axis.y * (s.y - o.y) + this.m_a2 * l - this.m_a1 * c, f = this.m_impulse.Copy(), r = this.m_K.Solve(new t, -u, -h), this.m_impulse.Add(r), this.m_limitState == n.e_atLowerLimit ? this.m_impulse.y = i.Max(this.m_impulse.y, 0) : this.m_limitState == n.e_atUpperLimit && (this.m_impulse.y = i.Min(this.m_impulse.y, 0)), u = -u - (this.m_impulse.y - f.y) * this.m_K.col2.x, h = 0, h = this.m_K.col1.x != 0 ? u / this.m_K.col1.x + f.x : f.x, this.m_impulse.x = h, r.x = this.m_impulse.x - f.x, r.y = this.m_impulse.y - f.y, f = r.x * this.m_perp.x + r.y * this.m_axis.x, u = r.x * this.m_perp.y + r.y * this.m_axis.y, h = r.x * this.m_s1 + r.y * this.m_a1, e = r.x * this.m_s2 + r.y * this.m_a2) : (r = 0, r = this.m_K.col1.x != 0 ? -u / this.m_K.col1.x : 0, this.m_impulse.x += r, f = r * this.m_perp.x, u = r * this.m_perp.y, h = r * this.m_s1, e = r * this.m_s2); o.x -= this.m_invMassA * f; o.y -= this.m_invMassA * u; c -= this.m_invIA * h; s.x += this.m_invMassB * f; s.y += this.m_invMassB * u; l += this.m_invIB * e; a.m_linearVelocity.SetV(o); a.m_angularVelocity = c; v.m_linearVelocity.SetV(s); v.m_angularVelocity = l }; e.prototype.SolvePositionConstraints = function () { var p = this.m_bodyA, w = this.m_bodyB, b = p.m_sweep.c, d = p.m_sweep.a, k = w.m_sweep.c, g = w.m_sweep.a, n, c = 0, f = 0, e = 0, o = 0, y = n = 0, a = 0, h, u, s, v; return f = !1, h = 0, u = l.FromAngle(d), e = l.FromAngle(g), n = u, a = this.m_localAnchor1.x - this.m_localCenterA.x, s = this.m_localAnchor1.y - this.m_localCenterA.y, c = n.col1.x * a + n.col2.x * s, s = n.col1.y * a + n.col2.y * s, a = c, n = e, e = this.m_localAnchor2.x - this.m_localCenterB.x, o = this.m_localAnchor2.y - this.m_localCenterB.y, c = n.col1.x * e + n.col2.x * o, o = n.col1.y * e + n.col2.y * o, e = c, n = k.x + e - b.x - a, c = k.y + o - b.y - s, this.m_enableLimit && (this.m_axis = i.MulMV(u, this.m_localXAxis1), this.m_a1 = (n + a) * this.m_axis.y - (c + s) * this.m_axis.x, this.m_a2 = e * this.m_axis.y - o * this.m_axis.x, v = this.m_axis.x * n + this.m_axis.y * c, i.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * r.b2_linearSlop ? (h = i.Clamp(v, -r.b2_maxLinearCorrection, r.b2_maxLinearCorrection), y = i.Abs(v), f = !0) : v <= this.m_lowerTranslation ? (h = i.Clamp(v - this.m_lowerTranslation + r.b2_linearSlop, -r.b2_maxLinearCorrection, 0), y = this.m_lowerTranslation - v, f = !0) : v >= this.m_upperTranslation && (h = i.Clamp(v - this.m_upperTranslation + r.b2_linearSlop, 0, r.b2_maxLinearCorrection), y = v - this.m_upperTranslation, f = !0)), this.m_perp = i.MulMV(u, this.m_localYAxis1), this.m_s1 = (n + a) * this.m_perp.y - (c + s) * this.m_perp.x, this.m_s2 = e * this.m_perp.y - o * this.m_perp.x, u = new t, s = this.m_perp.x * n + this.m_perp.y * c, y = i.Max(y, i.Abs(s)), a = 0, f ? (f = this.m_invMassA, e = this.m_invMassB, o = this.m_invIA, n = this.m_invIB, this.m_K.col1.x = f + e + o * this.m_s1 * this.m_s1 + n * this.m_s2 * this.m_s2, this.m_K.col1.y = o * this.m_s1 * this.m_a1 + n * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = f + e + o * this.m_a1 * this.m_a1 + n * this.m_a2 * this.m_a2, this.m_K.Solve(u, -s, -h)) : (f = this.m_invMassA, e = this.m_invMassB, o = this.m_invIA, n = this.m_invIB, h = f + e + o * this.m_s1 * this.m_s1 + n * this.m_s2 * this.m_s2, f = 0, f = h != 0 ? -s / h : 0, u.x = f, u.y = 0), h = u.x * this.m_perp.x + u.y * this.m_axis.x, f = u.x * this.m_perp.y + u.y * this.m_axis.y, s = u.x * this.m_s1 + u.y * this.m_a1, u = u.x * this.m_s2 + u.y * this.m_a2, b.x -= this.m_invMassA * h, b.y -= this.m_invMassA * f, d -= this.m_invIA * s, k.x += this.m_invMassB * h, k.y += this.m_invMassB * f, g += this.m_invIB * u, p.m_sweep.a = d, w.m_sweep.a = g, p.SynchronizeTransform(), w.SynchronizeTransform(), y <= r.b2_linearSlop && a <= r.b2_angularSlop }; Box2D.inherit(b, Box2D.Dynamics.Joints.b2JointDef); b.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype; b.b2LineJointDef = function () { Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments); this.localAnchorA = new t; this.localAnchorB = new t; this.localAxisA = new t }; b.prototype.b2LineJointDef = function () { this.__super.b2JointDef.call(this); this.type = n.e_lineJoint; this.localAxisA.Set(1, 0); this.enableLimit = !1; this.upperTranslation = this.lowerTranslation = 0; this.enableMotor = !1; this.motorSpeed = this.maxMotorForce = 0 }; b.prototype.Initialize = function (n, t, i, r) { this.bodyA = n; this.bodyB = t; this.localAnchorA = this.bodyA.GetLocalPoint(i); this.localAnchorB = this.bodyB.GetLocalPoint(i); this.localAxisA = this.bodyA.GetLocalVector(r) }; Box2D.inherit(s, Box2D.Dynamics.Joints.b2Joint); s.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype; s.b2MouseJoint = function () { Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments); this.K = new l; this.K1 = new l; this.K2 = new l; this.m_localAnchor = new t; this.m_target = new t; this.m_impulse = new t; this.m_mass = new l; this.m_C = new t }; s.prototype.GetAnchorA = function () { return this.m_target }; s.prototype.GetAnchorB = function () { return this.m_bodyB.GetWorldPoint(this.m_localAnchor) }; s.prototype.GetReactionForce = function (n) { return n === undefined && (n = 0), new t(n * this.m_impulse.x, n * this.m_impulse.y) }; s.prototype.GetReactionTorque = function () { return 0 }; s.prototype.GetTarget = function () { return this.m_target }; s.prototype.SetTarget = function (n) { this.m_bodyB.IsAwake() == !1 && this.m_bodyB.SetAwake(!0); this.m_target = n }; s.prototype.GetMaxForce = function () { return this.m_maxForce }; s.prototype.SetMaxForce = function (n) { n === undefined && (n = 0); this.m_maxForce = n }; s.prototype.GetFrequency = function () { return this.m_frequencyHz }; s.prototype.SetFrequency = function (n) { n === undefined && (n = 0); this.m_frequencyHz = n }; s.prototype.GetDampingRatio = function () { return this.m_dampingRatio }; s.prototype.SetDampingRatio = function (n) { n === undefined && (n = 0); this.m_dampingRatio = n }; s.prototype.b2MouseJoint = function (n) { this.__super.b2Joint.call(this, n); this.m_target.SetV(n.target); var i = this.m_target.x - this.m_bodyB.m_xf.position.x, r = this.m_target.y - this.m_bodyB.m_xf.position.y, t = this.m_bodyB.m_xf.R; this.m_localAnchor.x = i * t.col1.x + r * t.col1.y; this.m_localAnchor.y = i * t.col2.x + r * t.col2.y; this.m_maxForce = n.maxForce; this.m_impulse.SetZero(); this.m_frequencyHz = n.frequencyHz; this.m_dampingRatio = n.dampingRatio; this.m_gamma = this.m_beta = 0 }; s.prototype.InitVelocityConstraints = function (n) { var i = this.m_bodyB, r = i.GetMass(), t = 2 * Math.PI * this.m_frequencyHz, u = r * t * t, f; this.m_gamma = n.dt * (2 * r * this.m_dampingRatio * t + n.dt * u); this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0; this.m_beta = n.dt * u * this.m_gamma; u = i.m_xf.R; r = this.m_localAnchor.x - i.m_sweep.localCenter.x; t = this.m_localAnchor.y - i.m_sweep.localCenter.y; f = u.col1.x * r + u.col2.x * t; t = u.col1.y * r + u.col2.y * t; r = f; u = i.m_invMass; f = i.m_invI; this.K1.col1.x = u; this.K1.col2.x = 0; this.K1.col1.y = 0; this.K1.col2.y = u; this.K2.col1.x = f * t * t; this.K2.col2.x = -f * r * t; this.K2.col1.y = -f * r * t; this.K2.col2.y = f * r * r; this.K.SetM(this.K1); this.K.AddM(this.K2); this.K.col1.x += this.m_gamma; this.K.col2.y += this.m_gamma; this.K.GetInverse(this.m_mass); this.m_C.x = i.m_sweep.c.x + r - this.m_target.x; this.m_C.y = i.m_sweep.c.y + t - this.m_target.y; i.m_angularVelocity *= .98; this.m_impulse.x *= n.dtRatio; this.m_impulse.y *= n.dtRatio; i.m_linearVelocity.x += u * this.m_impulse.x; i.m_linearVelocity.y += u * this.m_impulse.y; i.m_angularVelocity += f * (r * this.m_impulse.y - t * this.m_impulse.x) }; s.prototype.SolveVelocityConstraints = function (n) { var t = this.m_bodyB, i, r = 0, u = 0, e, o, f; i = t.m_xf.R; e = this.m_localAnchor.x - t.m_sweep.localCenter.x; o = this.m_localAnchor.y - t.m_sweep.localCenter.y; r = i.col1.x * e + i.col2.x * o; o = i.col1.y * e + i.col2.y * o; e = r; r = t.m_linearVelocity.x + -t.m_angularVelocity * o; f = t.m_linearVelocity.y + t.m_angularVelocity * e; i = this.m_mass; r = r + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x; u = f + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y; f = -(i.col1.x * r + i.col2.x * u); u = -(i.col1.y * r + i.col2.y * u); i = this.m_impulse.x; r = this.m_impulse.y; this.m_impulse.x += f; this.m_impulse.y += u; n = n.dt * this.m_maxForce; this.m_impulse.LengthSquared() > n * n && this.m_impulse.Multiply(n / this.m_impulse.Length()); f = this.m_impulse.x - i; u = this.m_impulse.y - r; t.m_linearVelocity.x += t.m_invMass * f; t.m_linearVelocity.y += t.m_invMass * u; t.m_angularVelocity += t.m_invI * (e * u - o * f) }; s.prototype.SolvePositionConstraints = function () { return !0 }; Box2D.inherit(rt, Box2D.Dynamics.Joints.b2JointDef); rt.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype; rt.b2MouseJointDef = function () { Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments); this.target = new t }; rt.prototype.b2MouseJointDef = function () { this.__super.b2JointDef.call(this); this.type = n.e_mouseJoint; this.maxForce = 0; this.frequencyHz = 5; this.dampingRatio = .7 }; Box2D.inherit(f, Box2D.Dynamics.Joints.b2Joint); f.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype; f.b2PrismaticJoint = function () { Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments); this.m_localAnchor1 = new t; this.m_localAnchor2 = new t; this.m_localXAxis1 = new t; this.m_localYAxis1 = new t; this.m_axis = new t; this.m_perp = new t; this.m_K = new ut; this.m_impulse = new y }; f.prototype.GetAnchorA = function () { return this.m_bodyA.GetWorldPoint(this.m_localAnchor1) }; f.prototype.GetAnchorB = function () { return this.m_bodyB.GetWorldPoint(this.m_localAnchor2) }; f.prototype.GetReactionForce = function (n) { return n === undefined && (n = 0), new t(n * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), n * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y)) }; f.prototype.GetReactionTorque = function (n) { return n === undefined && (n = 0), n * this.m_impulse.y }; f.prototype.GetJointTranslation = function () { var n = this.m_bodyA, i = this.m_bodyB, t = n.GetWorldPoint(this.m_localAnchor1), r = i.GetWorldPoint(this.m_localAnchor2); return i = r.x - t.x, t = r.y - t.y, n = n.GetWorldVector(this.m_localXAxis1), n.x * i + n.y * t }; f.prototype.GetJointSpeed = function () { var n = this.m_bodyA, i = this.m_bodyB, t, r, u; t = n.m_xf.R; var f = this.m_localAnchor1.x - n.m_sweep.localCenter.x, e = this.m_localAnchor1.y - n.m_sweep.localCenter.y, o = t.col1.x * f + t.col2.x * e; e = t.col1.y * f + t.col2.y * e; f = o; t = i.m_xf.R; r = this.m_localAnchor2.x - i.m_sweep.localCenter.x; u = this.m_localAnchor2.y - i.m_sweep.localCenter.y; o = t.col1.x * r + t.col2.x * u; u = t.col1.y * r + t.col2.y * u; r = o; t = i.m_sweep.c.x + r - (n.m_sweep.c.x + f); o = i.m_sweep.c.y + u - (n.m_sweep.c.y + e); var s = n.GetWorldVector(this.m_localXAxis1), h = n.m_linearVelocity, c = i.m_linearVelocity; return n = n.m_angularVelocity, i = i.m_angularVelocity, t * -n * s.y + o * n * s.x + (s.x * (c.x + -i * u - h.x - -n * e) + s.y * (c.y + i * r - h.y - n * f)) }; f.prototype.IsLimitEnabled = function () { return this.m_enableLimit }; f.prototype.EnableLimit = function (n) { this.m_bodyA.SetAwake(!0); this.m_bodyB.SetAwake(!0); this.m_enableLimit = n }; f.prototype.GetLowerLimit = function () { return this.m_lowerTranslation }; f.prototype.GetUpperLimit = function () { return this.m_upperTranslation }; f.prototype.SetLimits = function (n, t) { n === undefined && (n = 0); t === undefined && (t = 0); this.m_bodyA.SetAwake(!0); this.m_bodyB.SetAwake(!0); this.m_lowerTranslation = n; this.m_upperTranslation = t }; f.prototype.IsMotorEnabled = function () { return this.m_enableMotor }; f.prototype.EnableMotor = function (n) { this.m_bodyA.SetAwake(!0); this.m_bodyB.SetAwake(!0); this.m_enableMotor = n }; f.prototype.SetMotorSpeed = function (n) { n === undefined && (n = 0); this.m_bodyA.SetAwake(!0); this.m_bodyB.SetAwake(!0); this.m_motorSpeed = n }; f.prototype.GetMotorSpeed = function () { return this.m_motorSpeed }; f.prototype.SetMaxMotorForce = function (n) { n === undefined && (n = 0); this.m_bodyA.SetAwake(!0); this.m_bodyB.SetAwake(!0); this.m_maxMotorForce = n }; f.prototype.GetMotorForce = function () { return this.m_motorImpulse }; f.prototype.b2PrismaticJoint = function (t) { this.__super.b2Joint.call(this, t); this.m_localAnchor1.SetV(t.localAnchorA); this.m_localAnchor2.SetV(t.localAnchorB); this.m_localXAxis1.SetV(t.localAxisA); this.m_localYAxis1.x = -this.m_localXAxis1.y; this.m_localYAxis1.y = this.m_localXAxis1.x; this.m_refAngle = t.referenceAngle; this.m_impulse.SetZero(); this.m_motorImpulse = this.m_motorMass = 0; this.m_lowerTranslation = t.lowerTranslation; this.m_upperTranslation = t.upperTranslation; this.m_maxMotorForce = t.maxMotorForce; this.m_motorSpeed = t.motorSpeed; this.m_enableLimit = t.enableLimit; this.m_enableMotor = t.enableMotor; this.m_limitState = n.e_inactiveLimit; this.m_axis.SetZero(); this.m_perp.SetZero() }; f.prototype.InitVelocityConstraints = function (t) { var o = this.m_bodyA, s = this.m_bodyB, u, h = 0, l, c, f, e, a; this.m_localCenterA.SetV(o.GetLocalCenter()); this.m_localCenterB.SetV(s.GetLocalCenter()); l = o.GetTransform(); s.GetTransform(); u = o.m_xf.R; c = this.m_localAnchor1.x - this.m_localCenterA.x; f = this.m_localAnchor1.y - this.m_localCenterA.y; h = u.col1.x * c + u.col2.x * f; f = u.col1.y * c + u.col2.y * f; c = h; u = s.m_xf.R; e = this.m_localAnchor2.x - this.m_localCenterB.x; a = this.m_localAnchor2.y - this.m_localCenterB.y; h = u.col1.x * e + u.col2.x * a; a = u.col1.y * e + u.col2.y * a; e = h; u = s.m_sweep.c.x + e - o.m_sweep.c.x - c; h = s.m_sweep.c.y + a - o.m_sweep.c.y - f; this.m_invMassA = o.m_invMass; this.m_invMassB = s.m_invMass; this.m_invIA = o.m_invI; this.m_invIB = s.m_invI; this.m_axis.SetV(i.MulMV(l.R, this.m_localXAxis1)); this.m_a1 = (u + c) * this.m_axis.y - (h + f) * this.m_axis.x; this.m_a2 = e * this.m_axis.y - a * this.m_axis.x; this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2; this.m_motorMass > Number.MIN_VALUE && (this.m_motorMass = 1 / this.m_motorMass); this.m_perp.SetV(i.MulMV(l.R, this.m_localYAxis1)); this.m_s1 = (u + c) * this.m_perp.y - (h + f) * this.m_perp.x; this.m_s2 = e * this.m_perp.y - a * this.m_perp.x; l = this.m_invMassA; c = this.m_invMassB; f = this.m_invIA; e = this.m_invIB; this.m_K.col1.x = l + c + f * this.m_s1 * this.m_s1 + e * this.m_s2 * this.m_s2; this.m_K.col1.y = f * this.m_s1 + e * this.m_s2; this.m_K.col1.z = f * this.m_s1 * this.m_a1 + e * this.m_s2 * this.m_a2; this.m_K.col2.x = this.m_K.col1.y; this.m_K.col2.y = f + e; this.m_K.col2.z = f * this.m_a1 + e * this.m_a2; this.m_K.col3.x = this.m_K.col1.z; this.m_K.col3.y = this.m_K.col2.z; this.m_K.col3.z = l + c + f * this.m_a1 * this.m_a1 + e * this.m_a2 * this.m_a2; this.m_enableLimit ? (u = this.m_axis.x * u + this.m_axis.y * h, i.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * r.b2_linearSlop ? this.m_limitState = n.e_equalLimits : u <= this.m_lowerTranslation ? this.m_limitState != n.e_atLowerLimit && (this.m_limitState = n.e_atLowerLimit, this.m_impulse.z = 0) : u >= this.m_upperTranslation ? this.m_limitState != n.e_atUpperLimit && (this.m_limitState = n.e_atUpperLimit, this.m_impulse.z = 0) : (this.m_limitState = n.e_inactiveLimit, this.m_impulse.z = 0)) : this.m_limitState = n.e_inactiveLimit; this.m_enableMotor == !1 && (this.m_motorImpulse = 0); t.warmStarting ? (this.m_impulse.x *= t.dtRatio, this.m_impulse.y *= t.dtRatio, this.m_motorImpulse *= t.dtRatio, t = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x, u = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y, h = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1, l = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2, o.m_linearVelocity.x -= this.m_invMassA * t, o.m_linearVelocity.y -= this.m_invMassA * u, o.m_angularVelocity -= this.m_invIA * h, s.m_linearVelocity.x += this.m_invMassB * t, s.m_linearVelocity.y += this.m_invMassB * u, s.m_angularVelocity += this.m_invIB * l) : (this.m_impulse.SetZero(), this.m_motorImpulse = 0) }; f.prototype.SolveVelocityConstraints = function (r) { var a = this.m_bodyA, v = this.m_bodyB, o = a.m_linearVelocity, c = a.m_angularVelocity, s = v.m_linearVelocity, l = v.m_angularVelocity, f = 0, u = 0, h = 0, e = 0; this.m_enableMotor && this.m_limitState != n.e_equalLimits && (e = this.m_motorMass * (this.m_motorSpeed - (this.m_axis.x * (s.x - o.x) + this.m_axis.y * (s.y - o.y) + this.m_a2 * l - this.m_a1 * c)), f = this.m_motorImpulse, r = r.dt * this.m_maxMotorForce, this.m_motorImpulse = i.Clamp(this.m_motorImpulse + e, -r, r), e = this.m_motorImpulse - f, f = e * this.m_axis.x, u = e * this.m_axis.y, h = e * this.m_a1, e = e * this.m_a2, o.x -= this.m_invMassA * f, o.y -= this.m_invMassA * u, c -= this.m_invIA * h, s.x += this.m_invMassB * f, s.y += this.m_invMassB * u, l += this.m_invIB * e); h = this.m_perp.x * (s.x - o.x) + this.m_perp.y * (s.y - o.y) + this.m_s2 * l - this.m_s1 * c; u = l - c; this.m_enableLimit && this.m_limitState != n.e_inactiveLimit ? (r = this.m_axis.x * (s.x - o.x) + this.m_axis.y * (s.y - o.y) + this.m_a2 * l - this.m_a1 * c, f = this.m_impulse.Copy(), r = this.m_K.Solve33(new y, -h, -u, -r), this.m_impulse.Add(r), this.m_limitState == n.e_atLowerLimit ? this.m_impulse.z = i.Max(this.m_impulse.z, 0) : this.m_limitState == n.e_atUpperLimit && (this.m_impulse.z = i.Min(this.m_impulse.z, 0)), h = -h - (this.m_impulse.z - f.z) * this.m_K.col3.x, u = -u - (this.m_impulse.z - f.z) * this.m_K.col3.y, u = this.m_K.Solve22(new t, h, u), u.x += f.x, u.y += f.y, this.m_impulse.x = u.x, this.m_impulse.y = u.y, r.x = this.m_impulse.x - f.x, r.y = this.m_impulse.y - f.y, r.z = this.m_impulse.z - f.z, f = r.x * this.m_perp.x + r.z * this.m_axis.x, u = r.x * this.m_perp.y + r.z * this.m_axis.y, h = r.x * this.m_s1 + r.y + r.z * this.m_a1, e = r.x * this.m_s2 + r.y + r.z * this.m_a2) : (r = this.m_K.Solve22(new t, -h, -u), this.m_impulse.x += r.x, this.m_impulse.y += r.y, f = r.x * this.m_perp.x, u = r.x * this.m_perp.y, h = r.x * this.m_s1 + r.y, e = r.x * this.m_s2 + r.y); o.x -= this.m_invMassA * f; o.y -= this.m_invMassA * u; c -= this.m_invIA * h; s.x += this.m_invMassB * f; s.y += this.m_invMassB * u; l += this.m_invIB * e; a.m_linearVelocity.SetV(o); a.m_angularVelocity = c; v.m_linearVelocity.SetV(s); v.m_angularVelocity = l }; f.prototype.SolvePositionConstraints = function () { var w = this.m_bodyA, b = this.m_bodyB, k = w.m_sweep.c, d = w.m_sweep.a, g = b.m_sweep.c, nt = b.m_sweep.a, n, u = 0, e = 0, h = 0, p = u = n = 0, v = 0, s, a; e = !1; var o = 0, f = l.FromAngle(d), c = l.FromAngle(nt); return n = f, v = this.m_localAnchor1.x - this.m_localCenterA.x, s = this.m_localAnchor1.y - this.m_localCenterA.y, u = n.col1.x * v + n.col2.x * s, s = n.col1.y * v + n.col2.y * s, v = u, n = c, c = this.m_localAnchor2.x - this.m_localCenterB.x, h = this.m_localAnchor2.y - this.m_localCenterB.y, u = n.col1.x * c + n.col2.x * h, h = n.col1.y * c + n.col2.y * h, c = u, n = g.x + c - k.x - v, u = g.y + h - k.y - s, this.m_enableLimit && (this.m_axis = i.MulMV(f, this.m_localXAxis1), this.m_a1 = (n + v) * this.m_axis.y - (u + s) * this.m_axis.x, this.m_a2 = c * this.m_axis.y - h * this.m_axis.x, a = this.m_axis.x * n + this.m_axis.y * u, i.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * r.b2_linearSlop ? (o = i.Clamp(a, -r.b2_maxLinearCorrection, r.b2_maxLinearCorrection), p = i.Abs(a), e = !0) : a <= this.m_lowerTranslation ? (o = i.Clamp(a - this.m_lowerTranslation + r.b2_linearSlop, -r.b2_maxLinearCorrection, 0), p = this.m_lowerTranslation - a, e = !0) : a >= this.m_upperTranslation && (o = i.Clamp(a - this.m_upperTranslation + r.b2_linearSlop, 0, r.b2_maxLinearCorrection), p = a - this.m_upperTranslation, e = !0)), this.m_perp = i.MulMV(f, this.m_localYAxis1), this.m_s1 = (n + v) * this.m_perp.y - (u + s) * this.m_perp.x, this.m_s2 = c * this.m_perp.y - h * this.m_perp.x, f = new y, s = this.m_perp.x * n + this.m_perp.y * u, c = nt - d - this.m_refAngle, p = i.Max(p, i.Abs(s)), v = i.Abs(c), e ? (e = this.m_invMassA, h = this.m_invMassB, n = this.m_invIA, u = this.m_invIB, this.m_K.col1.x = e + h + n * this.m_s1 * this.m_s1 + u * this.m_s2 * this.m_s2, this.m_K.col1.y = n * this.m_s1 + u * this.m_s2, this.m_K.col1.z = n * this.m_s1 * this.m_a1 + u * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = n + u, this.m_K.col2.z = n * this.m_a1 + u * this.m_a2, this.m_K.col3.x = this.m_K.col1.z, this.m_K.col3.y = this.m_K.col2.z, this.m_K.col3.z = e + h + n * this.m_a1 * this.m_a1 + u * this.m_a2 * this.m_a2, this.m_K.Solve33(f, -s, -c, -o)) : (e = this.m_invMassA, h = this.m_invMassB, n = this.m_invIA, u = this.m_invIB, o = n * this.m_s1 + u * this.m_s2, a = n + u, this.m_K.col1.Set(e + h + n * this.m_s1 * this.m_s1 + u * this.m_s2 * this.m_s2, o, 0), this.m_K.col2.Set(o, a, 0), o = this.m_K.Solve22(new t, -s, -c), f.x = o.x, f.y = o.y, f.z = 0), o = f.x * this.m_perp.x + f.z * this.m_axis.x, e = f.x * this.m_perp.y + f.z * this.m_axis.y, s = f.x * this.m_s1 + f.y + f.z * this.m_a1, f = f.x * this.m_s2 + f.y + f.z * this.m_a2, k.x -= this.m_invMassA * o, k.y -= this.m_invMassA * e, d -= this.m_invIA * s, g.x += this.m_invMassB * o, g.y += this.m_invMassB * e, nt += this.m_invIB * f, w.m_sweep.a = d, b.m_sweep.a = nt, w.SynchronizeTransform(), b.SynchronizeTransform(), p <= r.b2_linearSlop && v <= r.b2_angularSlop }; Box2D.inherit(k, Box2D.Dynamics.Joints.b2JointDef); k.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype; k.b2PrismaticJointDef = function () { Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments); this.localAnchorA = new t; this.localAnchorB = new t; this.localAxisA = new t }; k.prototype.b2PrismaticJointDef = function () { this.__super.b2JointDef.call(this); this.type = n.e_prismaticJoint; this.localAxisA.Set(1, 0); this.referenceAngle = 0; this.enableLimit = !1; this.upperTranslation = this.lowerTranslation = 0; this.enableMotor = !1; this.motorSpeed = this.maxMotorForce = 0 }; k.prototype.Initialize = function (n, t, i, r) { this.bodyA = n; this.bodyB = t; this.localAnchorA = this.bodyA.GetLocalPoint(i); this.localAnchorB = this.bodyB.GetLocalPoint(i); this.localAxisA = this.bodyA.GetLocalVector(r); this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle() }; Box2D.inherit(o, Box2D.Dynamics.Joints.b2Joint); o.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype; o.b2PulleyJoint = function () { Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments); this.m_groundAnchor1 = new t; this.m_groundAnchor2 = new t; this.m_localAnchor1 = new t; this.m_localAnchor2 = new t; this.m_u1 = new t; this.m_u2 = new t }; o.prototype.GetAnchorA = function () { return this.m_bodyA.GetWorldPoint(this.m_localAnchor1) }; o.prototype.GetAnchorB = function () { return this.m_bodyB.GetWorldPoint(this.m_localAnchor2) }; o.prototype.GetReactionForce = function (n) { return n === undefined && (n = 0), new t(n * this.m_impulse * this.m_u2.x, n * this.m_impulse * this.m_u2.y) }; o.prototype.GetReactionTorque = function () { return 0 }; o.prototype.GetGroundAnchorA = function () { var n = this.m_ground.m_xf.position.Copy(); return n.Add(this.m_groundAnchor1), n }; o.prototype.GetGroundAnchorB = function () { var n = this.m_ground.m_xf.position.Copy(); return n.Add(this.m_groundAnchor2), n }; o.prototype.GetLength1 = function () { var n = this.m_bodyA.GetWorldPoint(this.m_localAnchor1), t = n.x - (this.m_ground.m_xf.position.x + this.m_groundAnchor1.x); return n = n.y - (this.m_ground.m_xf.position.y + this.m_groundAnchor1.y), Math.sqrt(t * t + n * n) }; o.prototype.GetLength2 = function () { var n = this.m_bodyB.GetWorldPoint(this.m_localAnchor2), t = n.x - (this.m_ground.m_xf.position.x + this.m_groundAnchor2.x); return n = n.y - (this.m_ground.m_xf.position.y + this.m_groundAnchor2.y), Math.sqrt(t * t + n * n) }; o.prototype.GetRatio = function () { return this.m_ratio }; o.prototype.b2PulleyJoint = function (n) { this.__super.b2Joint.call(this, n); this.m_ground = this.m_bodyA.m_world.m_groundBody; this.m_groundAnchor1.x = n.groundAnchorA.x - this.m_ground.m_xf.position.x; this.m_groundAnchor1.y = n.groundAnchorA.y - this.m_ground.m_xf.position.y; this.m_groundAnchor2.x = n.groundAnchorB.x - this.m_ground.m_xf.position.x; this.m_groundAnchor2.y = n.groundAnchorB.y - this.m_ground.m_xf.position.y; this.m_localAnchor1.SetV(n.localAnchorA); this.m_localAnchor2.SetV(n.localAnchorB); this.m_ratio = n.ratio; this.m_constant = n.lengthA + this.m_ratio * n.lengthB; this.m_maxLength1 = i.Min(n.maxLengthA, this.m_constant - this.m_ratio * o.b2_minPulleyLength); this.m_maxLength2 = i.Min(n.maxLengthB, (this.m_constant - o.b2_minPulleyLength) / this.m_ratio); this.m_limitImpulse2 = this.m_limitImpulse1 = this.m_impulse = 0 }; o.prototype.InitVelocityConstraints = function (t) { var f = this.m_bodyA, e = this.m_bodyB, i, o, s, l, a; i = f.m_xf.R; var h = this.m_localAnchor1.x - f.m_sweep.localCenter.x, c = this.m_localAnchor1.y - f.m_sweep.localCenter.y, u = i.col1.x * h + i.col2.x * c; c = i.col1.y * h + i.col2.y * c; h = u; i = e.m_xf.R; o = this.m_localAnchor2.x - e.m_sweep.localCenter.x; s = this.m_localAnchor2.y - e.m_sweep.localCenter.y; u = i.col1.x * o + i.col2.x * s; s = i.col1.y * o + i.col2.y * s; o = u; i = e.m_sweep.c.x + o; u = e.m_sweep.c.y + s; l = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x; a = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y; this.m_u1.Set(f.m_sweep.c.x + h - (this.m_ground.m_xf.position.x + this.m_groundAnchor1.x), f.m_sweep.c.y + c - (this.m_ground.m_xf.position.y + this.m_groundAnchor1.y)); this.m_u2.Set(i - l, u - a); i = this.m_u1.Length(); u = this.m_u2.Length(); i > r.b2_linearSlop ? this.m_u1.Multiply(1 / i) : this.m_u1.SetZero(); u > r.b2_linearSlop ? this.m_u2.Multiply(1 / u) : this.m_u2.SetZero(); this.m_constant - i - this.m_ratio * u > 0 ? (this.m_state = n.e_inactiveLimit, this.m_impulse = 0) : this.m_state = n.e_atUpperLimit; i < this.m_maxLength1 ? (this.m_limitState1 = n.e_inactiveLimit, this.m_limitImpulse1 = 0) : this.m_limitState1 = n.e_atUpperLimit; u < this.m_maxLength2 ? (this.m_limitState2 = n.e_inactiveLimit, this.m_limitImpulse2 = 0) : this.m_limitState2 = n.e_atUpperLimit; i = h * this.m_u1.y - c * this.m_u1.x; u = o * this.m_u2.y - s * this.m_u2.x; this.m_limitMass1 = f.m_invMass + f.m_invI * i * i; this.m_limitMass2 = e.m_invMass + e.m_invI * u * u; this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2; this.m_limitMass1 = 1 / this.m_limitMass1; this.m_limitMass2 = 1 / this.m_limitMass2; this.m_pulleyMass = 1 / this.m_pulleyMass; t.warmStarting ? (this.m_impulse *= t.dtRatio, this.m_limitImpulse1 *= t.dtRatio, this.m_limitImpulse2 *= t.dtRatio, t = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.x, i = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.y, u = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.x, l = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.y, f.m_linearVelocity.x += f.m_invMass * t, f.m_linearVelocity.y += f.m_invMass * i, f.m_angularVelocity += f.m_invI * (h * i - c * t), e.m_linearVelocity.x += e.m_invMass * u, e.m_linearVelocity.y += e.m_invMass * l, e.m_angularVelocity += e.m_invI * (o * l - s * u)) : this.m_limitImpulse2 = this.m_limitImpulse1 = this.m_impulse = 0 }; o.prototype.SolveVelocityConstraints = function () { var u = this.m_bodyA, f = this.m_bodyB, t, s, h, o, r; t = u.m_xf.R; var c = this.m_localAnchor1.x - u.m_sweep.localCenter.x, l = this.m_localAnchor1.y - u.m_sweep.localCenter.y, e = t.col1.x * c + t.col2.x * l; l = t.col1.y * c + t.col2.y * l; c = e; t = f.m_xf.R; s = this.m_localAnchor2.x - f.m_sweep.localCenter.x; h = this.m_localAnchor2.y - f.m_sweep.localCenter.y; e = t.col1.x * s + t.col2.x * h; h = t.col1.y * s + t.col2.y * h; s = e; o = e = t = 0; r = 0; t = r = t = r = o = e = t = 0; this.m_state == n.e_atUpperLimit && (t = u.m_linearVelocity.x + -u.m_angularVelocity * l, e = u.m_linearVelocity.y + u.m_angularVelocity * c, o = f.m_linearVelocity.x + -f.m_angularVelocity * h, r = f.m_linearVelocity.y + f.m_angularVelocity * s, t = -(this.m_u1.x * t + this.m_u1.y * e) - this.m_ratio * (this.m_u2.x * o + this.m_u2.y * r), r = this.m_pulleyMass * -t, t = this.m_impulse, this.m_impulse = i.Max(0, this.m_impulse + r), r = this.m_impulse - t, t = -r * this.m_u1.x, e = -r * this.m_u1.y, o = -this.m_ratio * r * this.m_u2.x, r = -this.m_ratio * r * this.m_u2.y, u.m_linearVelocity.x += u.m_invMass * t, u.m_linearVelocity.y += u.m_invMass * e, u.m_angularVelocity += u.m_invI * (c * e - l * t), f.m_linearVelocity.x += f.m_invMass * o, f.m_linearVelocity.y += f.m_invMass * r, f.m_angularVelocity += f.m_invI * (s * r - h * o)); this.m_limitState1 == n.e_atUpperLimit && (t = u.m_linearVelocity.x + -u.m_angularVelocity * l, e = u.m_linearVelocity.y + u.m_angularVelocity * c, t = -(this.m_u1.x * t + this.m_u1.y * e), r = -this.m_limitMass1 * t, t = this.m_limitImpulse1, this.m_limitImpulse1 = i.Max(0, this.m_limitImpulse1 + r), r = this.m_limitImpulse1 - t, t = -r * this.m_u1.x, e = -r * this.m_u1.y, u.m_linearVelocity.x += u.m_invMass * t, u.m_linearVelocity.y += u.m_invMass * e, u.m_angularVelocity += u.m_invI * (c * e - l * t)); this.m_limitState2 == n.e_atUpperLimit && (o = f.m_linearVelocity.x + -f.m_angularVelocity * h, r = f.m_linearVelocity.y + f.m_angularVelocity * s, t = -(this.m_u2.x * o + this.m_u2.y * r), r = -this.m_limitMass2 * t, t = this.m_limitImpulse2, this.m_limitImpulse2 = i.Max(0, this.m_limitImpulse2 + r), r = this.m_limitImpulse2 - t, o = -r * this.m_u2.x, r = -r * this.m_u2.y, f.m_linearVelocity.x += f.m_invMass * o, f.m_linearVelocity.y += f.m_invMass * r, f.m_angularVelocity += f.m_invI * (s * r - h * o)) }; o.prototype.SolvePositionConstraints = function () { var f = this.m_bodyA, e = this.m_bodyB, t, y = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x, p = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y, w = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x, b = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y, s = 0, h = 0, c = 0, l = 0, u = t = 0, a = 0, o = 0, v = u = o = t = u = t = 0; return this.m_state == n.e_atUpperLimit && (t = f.m_xf.R, s = this.m_localAnchor1.x - f.m_sweep.localCenter.x, h = this.m_localAnchor1.y - f.m_sweep.localCenter.y, u = t.col1.x * s + t.col2.x * h, h = t.col1.y * s + t.col2.y * h, s = u, t = e.m_xf.R, c = this.m_localAnchor2.x - e.m_sweep.localCenter.x, l = this.m_localAnchor2.y - e.m_sweep.localCenter.y, u = t.col1.x * c + t.col2.x * l, l = t.col1.y * c + t.col2.y * l, c = u, t = f.m_sweep.c.x + s, u = f.m_sweep.c.y + h, a = e.m_sweep.c.x + c, o = e.m_sweep.c.y + l, this.m_u1.Set(t - y, u - p), this.m_u2.Set(a - w, o - b), t = this.m_u1.Length(), u = this.m_u2.Length(), t > r.b2_linearSlop ? this.m_u1.Multiply(1 / t) : this.m_u1.SetZero(), u > r.b2_linearSlop ? this.m_u2.Multiply(1 / u) : this.m_u2.SetZero(), t = this.m_constant - t - this.m_ratio * u, v = i.Max(v, -t), t = i.Clamp(t + r.b2_linearSlop, -r.b2_maxLinearCorrection, 0), o = -this.m_pulleyMass * t, t = -o * this.m_u1.x, u = -o * this.m_u1.y, a = -this.m_ratio * o * this.m_u2.x, o = -this.m_ratio * o * this.m_u2.y, f.m_sweep.c.x += f.m_invMass * t, f.m_sweep.c.y += f.m_invMass * u, f.m_sweep.a += f.m_invI * (s * u - h * t), e.m_sweep.c.x += e.m_invMass * a, e.m_sweep.c.y += e.m_invMass * o, e.m_sweep.a += e.m_invI * (c * o - l * a), f.SynchronizeTransform(), e.SynchronizeTransform()), this.m_limitState1 == n.e_atUpperLimit && (t = f.m_xf.R, s = this.m_localAnchor1.x - f.m_sweep.localCenter.x, h = this.m_localAnchor1.y - f.m_sweep.localCenter.y, u = t.col1.x * s + t.col2.x * h, h = t.col1.y * s + t.col2.y * h, s = u, t = f.m_sweep.c.x + s, u = f.m_sweep.c.y + h, this.m_u1.Set(t - y, u - p), t = this.m_u1.Length(), t > r.b2_linearSlop ? (this.m_u1.x *= 1 / t, this.m_u1.y *= 1 / t) : this.m_u1.SetZero(), t = this.m_maxLength1 - t, v = i.Max(v, -t), t = i.Clamp(t + r.b2_linearSlop, -r.b2_maxLinearCorrection, 0), o = -this.m_limitMass1 * t, t = -o * this.m_u1.x, u = -o * this.m_u1.y, f.m_sweep.c.x += f.m_invMass * t, f.m_sweep.c.y += f.m_invMass * u, f.m_sweep.a += f.m_invI * (s * u - h * t), f.SynchronizeTransform()), this.m_limitState2 == n.e_atUpperLimit && (t = e.m_xf.R, c = this.m_localAnchor2.x - e.m_sweep.localCenter.x, l = this.m_localAnchor2.y - e.m_sweep.localCenter.y, u = t.col1.x * c + t.col2.x * l, l = t.col1.y * c + t.col2.y * l, c = u, a = e.m_sweep.c.x + c, o = e.m_sweep.c.y + l, this.m_u2.Set(a - w, o - b), u = this.m_u2.Length(), u > r.b2_linearSlop ? (this.m_u2.x *= 1 / u, this.m_u2.y *= 1 / u) : this.m_u2.SetZero(), t = this.m_maxLength2 - u, v = i.Max(v, -t), t = i.Clamp(t + r.b2_linearSlop, -r.b2_maxLinearCorrection, 0), o = -this.m_limitMass2 * t, a = -o * this.m_u2.x, o = -o * this.m_u2.y, e.m_sweep.c.x += e.m_invMass * a, e.m_sweep.c.y += e.m_invMass * o, e.m_sweep.a += e.m_invI * (c * o - l * a), e.SynchronizeTransform()), v < r.b2_linearSlop }; Box2D.postDefs.push(function () { Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 2 }); Box2D.inherit(d, Box2D.Dynamics.Joints.b2JointDef); d.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype; d.b2PulleyJointDef = function () { Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments); this.groundAnchorA = new t; this.groundAnchorB = new t; this.localAnchorA = new t; this.localAnchorB = new t }; d.prototype.b2PulleyJointDef = function () { this.__super.b2JointDef.call(this); this.type = n.e_pulleyJoint; this.groundAnchorA.Set(-1, 1); this.groundAnchorB.Set(1, 1); this.localAnchorA.Set(-1, 0); this.localAnchorB.Set(1, 0); this.maxLengthB = this.lengthB = this.maxLengthA = this.lengthA = 0; this.ratio = 1; this.collideConnected = !0 }; d.prototype.Initialize = function (n, t, i, r, u, f, e) { e === undefined && (e = 0); this.bodyA = n; this.bodyB = t; this.groundAnchorA.SetV(i); this.groundAnchorB.SetV(r); this.localAnchorA = this.bodyA.GetLocalPoint(u); this.localAnchorB = this.bodyB.GetLocalPoint(f); n = u.x - i.x; i = u.y - i.y; this.lengthA = Math.sqrt(n * n + i * i); i = f.x - r.x; r = f.y - r.y; this.lengthB = Math.sqrt(i * i + r * r); this.ratio = e; e = this.lengthA + this.ratio * this.lengthB; this.maxLengthA = e - this.ratio * o.b2_minPulleyLength; this.maxLengthB = (e - o.b2_minPulleyLength) / this.ratio }; Box2D.inherit(u, Box2D.Dynamics.Joints.b2Joint); u.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype; u.b2RevoluteJoint = function () { Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments); this.K = new l; this.K1 = new l; this.K2 = new l; this.K3 = new l; this.impulse3 = new y; this.impulse2 = new t; this.reduced = new t; this.m_localAnchor1 = new t; this.m_localAnchor2 = new t; this.m_impulse = new y; this.m_mass = new ut }; u.prototype.GetAnchorA = function () { return this.m_bodyA.GetWorldPoint(this.m_localAnchor1) }; u.prototype.GetAnchorB = function () { return this.m_bodyB.GetWorldPoint(this.m_localAnchor2) }; u.prototype.GetReactionForce = function (n) { return n === undefined && (n = 0), new t(n * this.m_impulse.x, n * this.m_impulse.y) }; u.prototype.GetReactionTorque = function (n) { return n === undefined && (n = 0), n * this.m_impulse.z }; u.prototype.GetJointAngle = function () { return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle }; u.prototype.GetJointSpeed = function () { return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity }; u.prototype.IsLimitEnabled = function () { return this.m_enableLimit }; u.prototype.EnableLimit = function (n) { this.m_enableLimit = n }; u.prototype.GetLowerLimit = function () { return this.m_lowerAngle }; u.prototype.GetUpperLimit = function () { return this.m_upperAngle }; u.prototype.SetLimits = function (n, t) { n === undefined && (n = 0); t === undefined && (t = 0); this.m_lowerAngle = n; this.m_upperAngle = t }; u.prototype.IsMotorEnabled = function () { return this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor }; u.prototype.EnableMotor = function (n) { this.m_enableMotor = n }; u.prototype.SetMotorSpeed = function (n) { n === undefined && (n = 0); this.m_bodyA.SetAwake(!0); this.m_bodyB.SetAwake(!0); this.m_motorSpeed = n }; u.prototype.GetMotorSpeed = function () { return this.m_motorSpeed }; u.prototype.SetMaxMotorTorque = function (n) { n === undefined && (n = 0); this.m_maxMotorTorque = n }; u.prototype.GetMotorTorque = function () { return this.m_maxMotorTorque }; u.prototype.b2RevoluteJoint = function (t) { this.__super.b2Joint.call(this, t); this.m_localAnchor1.SetV(t.localAnchorA); this.m_localAnchor2.SetV(t.localAnchorB); this.m_referenceAngle = t.referenceAngle; this.m_impulse.SetZero(); this.m_motorImpulse = 0; this.m_lowerAngle = t.lowerAngle; this.m_upperAngle = t.upperAngle; this.m_maxMotorTorque = t.maxMotorTorque; this.m_motorSpeed = t.motorSpeed; this.m_enableLimit = t.enableLimit; this.m_enableMotor = t.enableMotor; this.m_limitState = n.e_inactiveLimit }; u.prototype.InitVelocityConstraints = function (t) { var f = this.m_bodyA, e = this.m_bodyB, u, o = 0, s, h, c, l, a, v, y; u = f.m_xf.R; s = this.m_localAnchor1.x - f.m_sweep.localCenter.x; h = this.m_localAnchor1.y - f.m_sweep.localCenter.y; o = u.col1.x * s + u.col2.x * h; h = u.col1.y * s + u.col2.y * h; s = o; u = e.m_xf.R; c = this.m_localAnchor2.x - e.m_sweep.localCenter.x; l = this.m_localAnchor2.y - e.m_sweep.localCenter.y; o = u.col1.x * c + u.col2.x * l; l = u.col1.y * c + u.col2.y * l; c = o; u = f.m_invMass; o = e.m_invMass; a = f.m_invI; v = e.m_invI; this.m_mass.col1.x = u + o + h * h * a + l * l * v; this.m_mass.col2.x = -h * s * a - l * c * v; this.m_mass.col3.x = -h * a - l * v; this.m_mass.col1.y = this.m_mass.col2.x; this.m_mass.col2.y = u + o + s * s * a + c * c * v; this.m_mass.col3.y = s * a + c * v; this.m_mass.col1.z = this.m_mass.col3.x; this.m_mass.col2.z = this.m_mass.col3.y; this.m_mass.col3.z = a + v; this.m_motorMass = 1 / (a + v); this.m_enableMotor == !1 && (this.m_motorImpulse = 0); this.m_enableLimit ? (y = e.m_sweep.a - f.m_sweep.a - this.m_referenceAngle, i.Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * r.b2_angularSlop ? this.m_limitState = n.e_equalLimits : y <= this.m_lowerAngle ? (this.m_limitState != n.e_atLowerLimit && (this.m_impulse.z = 0), this.m_limitState = n.e_atLowerLimit) : y >= this.m_upperAngle ? (this.m_limitState != n.e_atUpperLimit && (this.m_impulse.z = 0), this.m_limitState = n.e_atUpperLimit) : (this.m_limitState = n.e_inactiveLimit, this.m_impulse.z = 0)) : this.m_limitState = n.e_inactiveLimit; t.warmStarting ? (this.m_impulse.x *= t.dtRatio, this.m_impulse.y *= t.dtRatio, this.m_motorImpulse *= t.dtRatio, t = this.m_impulse.x, y = this.m_impulse.y, f.m_linearVelocity.x -= u * t, f.m_linearVelocity.y -= u * y, f.m_angularVelocity -= a * (s * y - h * t + this.m_motorImpulse + this.m_impulse.z), e.m_linearVelocity.x += o * t, e.m_linearVelocity.y += o * y, e.m_angularVelocity += v * (c * y - l * t + this.m_motorImpulse + this.m_impulse.z)) : (this.m_impulse.SetZero(), this.m_motorImpulse = 0) }; u.prototype.SolveVelocityConstraints = function (t) { var o = this.m_bodyA, s = this.m_bodyB, e = 0, r = e = 0, f = 0, u = 0, h = 0, a = o.m_linearVelocity, c = o.m_angularVelocity, v = s.m_linearVelocity, l = s.m_angularVelocity, y = o.m_invMass, p = s.m_invMass, b = o.m_invI, k = s.m_invI, w; this.m_enableMotor && this.m_limitState != n.e_equalLimits && (r = this.m_motorMass * -(l - c - this.m_motorSpeed), f = this.m_motorImpulse, u = t.dt * this.m_maxMotorTorque, this.m_motorImpulse = i.Clamp(this.m_motorImpulse + r, -u, u), r = this.m_motorImpulse - f, c -= b * r, l += k * r); this.m_enableLimit && this.m_limitState != n.e_inactiveLimit ? (t = o.m_xf.R, r = this.m_localAnchor1.x - o.m_sweep.localCenter.x, f = this.m_localAnchor1.y - o.m_sweep.localCenter.y, e = t.col1.x * r + t.col2.x * f, f = t.col1.y * r + t.col2.y * f, r = e, t = s.m_xf.R, u = this.m_localAnchor2.x - s.m_sweep.localCenter.x, h = this.m_localAnchor2.y - s.m_sweep.localCenter.y, e = t.col1.x * u + t.col2.x * h, h = t.col1.y * u + t.col2.y * h, u = e, t = v.x + -l * h - a.x - -c * f, w = v.y + l * u - a.y - c * r, this.m_mass.Solve33(this.impulse3, -t, -w, -(l - c)), this.m_limitState == n.e_equalLimits ? this.m_impulse.Add(this.impulse3) : this.m_limitState == n.e_atLowerLimit ? (e = this.m_impulse.z + this.impulse3.z, e < 0 && (this.m_mass.Solve22(this.reduced, -t, -w), this.impulse3.x = this.reduced.x, this.impulse3.y = this.reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += this.reduced.x, this.m_impulse.y += this.reduced.y, this.m_impulse.z = 0)) : this.m_limitState == n.e_atUpperLimit && (e = this.m_impulse.z + this.impulse3.z, e > 0 && (this.m_mass.Solve22(this.reduced, -t, -w), this.impulse3.x = this.reduced.x, this.impulse3.y = this.reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += this.reduced.x, this.m_impulse.y += this.reduced.y, this.m_impulse.z = 0)), a.x -= y * this.impulse3.x, a.y -= y * this.impulse3.y, c -= b * (r * this.impulse3.y - f * this.impulse3.x + this.impulse3.z), v.x += p * this.impulse3.x, v.y += p * this.impulse3.y, l += k * (u * this.impulse3.y - h * this.impulse3.x + this.impulse3.z)) : (t = o.m_xf.R, r = this.m_localAnchor1.x - o.m_sweep.localCenter.x, f = this.m_localAnchor1.y - o.m_sweep.localCenter.y, e = t.col1.x * r + t.col2.x * f, f = t.col1.y * r + t.col2.y * f, r = e, t = s.m_xf.R, u = this.m_localAnchor2.x - s.m_sweep.localCenter.x, h = this.m_localAnchor2.y - s.m_sweep.localCenter.y, e = t.col1.x * u + t.col2.x * h, h = t.col1.y * u + t.col2.y * h, u = e, this.m_mass.Solve22(this.impulse2, -(v.x + -l * h - a.x - -c * f), -(v.y + l * u - a.y - c * r)), this.m_impulse.x += this.impulse2.x, this.m_impulse.y += this.impulse2.y, a.x -= y * this.impulse2.x, a.y -= y * this.impulse2.y, c -= b * (r * this.impulse2.y - f * this.impulse2.x), v.x += p * this.impulse2.x, v.y += p * this.impulse2.y, l += k * (u * this.impulse2.y - h * this.impulse2.x)); o.m_linearVelocity.SetV(a); o.m_angularVelocity = c; s.m_linearVelocity.SetV(v); s.m_angularVelocity = l }; u.prototype.SolvePositionConstraints = function () { var t = 0, c, f = this.m_bodyA, e = this.m_bodyB, w = 0, v = c = 0, s = 0, h = 0, o, l, a, y; this.m_enableLimit && this.m_limitState != n.e_inactiveLimit && (t = e.m_sweep.a - f.m_sweep.a - this.m_referenceAngle, o = 0, this.m_limitState == n.e_equalLimits ? (t = i.Clamp(t - this.m_lowerAngle, -r.b2_maxAngularCorrection, r.b2_maxAngularCorrection), o = -this.m_motorMass * t, w = i.Abs(t)) : this.m_limitState == n.e_atLowerLimit ? (t = t - this.m_lowerAngle, w = -t, t = i.Clamp(t + r.b2_angularSlop, -r.b2_maxAngularCorrection, 0), o = -this.m_motorMass * t) : this.m_limitState == n.e_atUpperLimit && (w = t = t - this.m_upperAngle, t = i.Clamp(t - r.b2_angularSlop, 0, r.b2_maxAngularCorrection), o = -this.m_motorMass * t), f.m_sweep.a -= f.m_invI * o, e.m_sweep.a += e.m_invI * o, f.SynchronizeTransform(), e.SynchronizeTransform()); c = f.m_xf.R; o = this.m_localAnchor1.x - f.m_sweep.localCenter.x; t = this.m_localAnchor1.y - f.m_sweep.localCenter.y; v = c.col1.x * o + c.col2.x * t; t = c.col1.y * o + c.col2.y * t; o = v; c = e.m_xf.R; l = this.m_localAnchor2.x - e.m_sweep.localCenter.x; a = this.m_localAnchor2.y - e.m_sweep.localCenter.y; v = c.col1.x * l + c.col2.x * a; a = c.col1.y * l + c.col2.y * a; l = v; s = e.m_sweep.c.x + l - f.m_sweep.c.x - o; h = e.m_sweep.c.y + a - f.m_sweep.c.y - t; y = s * s + h * h; c = Math.sqrt(y); v = f.m_invMass; var p = e.m_invMass, b = f.m_invI, k = e.m_invI, d = 10 * r.b2_linearSlop; return y > d * d && (y = 1 / (v + p), s = y * -s, h = y * -h, f.m_sweep.c.x -= .5 * v * s, f.m_sweep.c.y -= .5 * v * h, e.m_sweep.c.x += .5 * p * s, e.m_sweep.c.y += .5 * p * h, s = e.m_sweep.c.x + l - f.m_sweep.c.x - o, h = e.m_sweep.c.y + a - f.m_sweep.c.y - t), this.K1.col1.x = v + p, this.K1.col2.x = 0, this.K1.col1.y = 0, this.K1.col2.y = v + p, this.K2.col1.x = b * t * t, this.K2.col2.x = -b * o * t, this.K2.col1.y = -b * o * t, this.K2.col2.y = b * o * o, this.K3.col1.x = k * a * a, this.K3.col2.x = -k * l * a, this.K3.col1.y = -k * l * a, this.K3.col2.y = k * l * l, this.K.SetM(this.K1), this.K.AddM(this.K2), this.K.AddM(this.K3), this.K.Solve(u.tImpulse, -s, -h), s = u.tImpulse.x, h = u.tImpulse.y, f.m_sweep.c.x -= f.m_invMass * s, f.m_sweep.c.y -= f.m_invMass * h, f.m_sweep.a -= f.m_invI * (o * h - t * s), e.m_sweep.c.x += e.m_invMass * s, e.m_sweep.c.y += e.m_invMass * h, e.m_sweep.a += e.m_invI * (l * h - a * s), f.SynchronizeTransform(), e.SynchronizeTransform(), c <= r.b2_linearSlop && w <= r.b2_angularSlop }; Box2D.postDefs.push(function () { Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse = new t }); Box2D.inherit(g, Box2D.Dynamics.Joints.b2JointDef); g.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype; g.b2RevoluteJointDef = function () { Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments); this.localAnchorA = new t; this.localAnchorB = new t }; g.prototype.b2RevoluteJointDef = function () { this.__super.b2JointDef.call(this); this.type = n.e_revoluteJoint; this.localAnchorA.Set(0, 0); this.localAnchorB.Set(0, 0); this.motorSpeed = this.maxMotorTorque = this.upperAngle = this.lowerAngle = this.referenceAngle = 0; this.enableMotor = this.enableLimit = !1 }; g.prototype.Initialize = function (n, t, i) { this.bodyA = n; this.bodyB = t; this.localAnchorA = this.bodyA.GetLocalPoint(i); this.localAnchorB = this.bodyB.GetLocalPoint(i); this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle() }; Box2D.inherit(v, Box2D.Dynamics.Joints.b2Joint); v.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype; v.b2WeldJoint = function () { Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments); this.m_localAnchorA = new t; this.m_localAnchorB = new t; this.m_impulse = new y; this.m_mass = new ut }; v.prototype.GetAnchorA = function () { return this.m_bodyA.GetWorldPoint(this.m_localAnchorA) }; v.prototype.GetAnchorB = function () { return this.m_bodyB.GetWorldPoint(this.m_localAnchorB) }; v.prototype.GetReactionForce = function (n) { return n === undefined && (n = 0), new t(n * this.m_impulse.x, n * this.m_impulse.y) }; v.prototype.GetReactionTorque = function (n) { return n === undefined && (n = 0), n * this.m_impulse.z }; v.prototype.b2WeldJoint = function (n) { this.__super.b2Joint.call(this, n); this.m_localAnchorA.SetV(n.localAnchorA); this.m_localAnchorB.SetV(n.localAnchorB); this.m_referenceAngle = n.referenceAngle; this.m_impulse.SetZero(); this.m_mass = new ut }; v.prototype.InitVelocityConstraints = function (n) { var t, i = 0, o = this.m_bodyA, s = this.m_bodyB, r, u, f, e, h, c; t = o.m_xf.R; r = this.m_localAnchorA.x - o.m_sweep.localCenter.x; u = this.m_localAnchorA.y - o.m_sweep.localCenter.y; i = t.col1.x * r + t.col2.x * u; u = t.col1.y * r + t.col2.y * u; r = i; t = s.m_xf.R; f = this.m_localAnchorB.x - s.m_sweep.localCenter.x; e = this.m_localAnchorB.y - s.m_sweep.localCenter.y; i = t.col1.x * f + t.col2.x * e; e = t.col1.y * f + t.col2.y * e; f = i; t = o.m_invMass; i = s.m_invMass; h = o.m_invI; c = s.m_invI; this.m_mass.col1.x = t + i + u * u * h + e * e * c; this.m_mass.col2.x = -u * r * h - e * f * c; this.m_mass.col3.x = -u * h - e * c; this.m_mass.col1.y = this.m_mass.col2.x; this.m_mass.col2.y = t + i + r * r * h + f * f * c; this.m_mass.col3.y = r * h + f * c; this.m_mass.col1.z = this.m_mass.col3.x; this.m_mass.col2.z = this.m_mass.col3.y; this.m_mass.col3.z = h + c; n.warmStarting ? (this.m_impulse.x *= n.dtRatio, this.m_impulse.y *= n.dtRatio, this.m_impulse.z *= n.dtRatio, o.m_linearVelocity.x -= t * this.m_impulse.x, o.m_linearVelocity.y -= t * this.m_impulse.y, o.m_angularVelocity -= h * (r * this.m_impulse.y - u * this.m_impulse.x + this.m_impulse.z), s.m_linearVelocity.x += i * this.m_impulse.x, s.m_linearVelocity.y += i * this.m_impulse.y, s.m_angularVelocity += c * (f * this.m_impulse.y - e * this.m_impulse.x + this.m_impulse.z)) : this.m_impulse.SetZero() }; v.prototype.SolveVelocityConstraints = function () { var t, u = 0, i = this.m_bodyA, r = this.m_bodyB, l = i.m_linearVelocity, h = i.m_angularVelocity, a = r.m_linearVelocity, c = r.m_angularVelocity, v = i.m_invMass, p = r.m_invMass, b = i.m_invI, k = r.m_invI, f, e, o, s, w, n; t = i.m_xf.R; f = this.m_localAnchorA.x - i.m_sweep.localCenter.x; e = this.m_localAnchorA.y - i.m_sweep.localCenter.y; u = t.col1.x * f + t.col2.x * e; e = t.col1.y * f + t.col2.y * e; f = u; t = r.m_xf.R; o = this.m_localAnchorB.x - r.m_sweep.localCenter.x; s = this.m_localAnchorB.y - r.m_sweep.localCenter.y; u = t.col1.x * o + t.col2.x * s; s = t.col1.y * o + t.col2.y * s; o = u; t = a.x - c * s - l.x + h * e; u = a.y + c * o - l.y - h * f; w = c - h; n = new y; this.m_mass.Solve33(n, -t, -u, -w); this.m_impulse.Add(n); l.x -= v * n.x; l.y -= v * n.y; h -= b * (f * n.y - e * n.x + n.z); a.x += p * n.x; a.y += p * n.y; c += k * (o * n.y - s * n.x + n.z); i.m_angularVelocity = h; r.m_angularVelocity = c }; v.prototype.SolvePositionConstraints = function () { var n, c = 0, u = this.m_bodyA, f = this.m_bodyB, e, o, s, h; n = u.m_xf.R; e = this.m_localAnchorA.x - u.m_sweep.localCenter.x; o = this.m_localAnchorA.y - u.m_sweep.localCenter.y; c = n.col1.x * e + n.col2.x * o; o = n.col1.y * e + n.col2.y * o; e = c; n = f.m_xf.R; s = this.m_localAnchorB.x - f.m_sweep.localCenter.x; h = this.m_localAnchorB.y - f.m_sweep.localCenter.y; c = n.col1.x * s + n.col2.x * h; h = n.col1.y * s + n.col2.y * h; s = c; n = u.m_invMass; c = f.m_invMass; var l = u.m_invI, a = f.m_invI, v = f.m_sweep.c.x + s - u.m_sweep.c.x - e, p = f.m_sweep.c.y + h - u.m_sweep.c.y - o, w = f.m_sweep.a - u.m_sweep.a - this.m_referenceAngle, t = 10 * r.b2_linearSlop, b = Math.sqrt(v * v + p * p), k = i.Abs(w); return b > t && (l *= 1, a *= 1), this.m_mass.col1.x = n + c + o * o * l + h * h * a, this.m_mass.col2.x = -o * e * l - h * s * a, this.m_mass.col3.x = -o * l - h * a, this.m_mass.col1.y = this.m_mass.col2.x, this.m_mass.col2.y = n + c + e * e * l + s * s * a, this.m_mass.col3.y = e * l + s * a, this.m_mass.col1.z = this.m_mass.col3.x, this.m_mass.col2.z = this.m_mass.col3.y, this.m_mass.col3.z = l + a, t = new y, this.m_mass.Solve33(t, -v, -p, -w), u.m_sweep.c.x -= n * t.x, u.m_sweep.c.y -= n * t.y, u.m_sweep.a -= l * (e * t.y - o * t.x + t.z), f.m_sweep.c.x += c * t.x, f.m_sweep.c.y += c * t.y, f.m_sweep.a += a * (s * t.y - h * t.x + t.z), u.SynchronizeTransform(), f.SynchronizeTransform(), b <= r.b2_linearSlop && k <= r.b2_angularSlop }; Box2D.inherit(nt, Box2D.Dynamics.Joints.b2JointDef); nt.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype; nt.b2WeldJointDef = function () { Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments); this.localAnchorA = new t; this.localAnchorB = new t }; nt.prototype.b2WeldJointDef = function () { this.__super.b2JointDef.call(this); this.type = n.e_weldJoint; this.referenceAngle = 0 }; nt.prototype.Initialize = function (n, t, i) { this.bodyA = n; this.bodyB = t; this.localAnchorA.SetV(this.bodyA.GetLocalPoint(i)); this.localAnchorB.SetV(this.bodyB.GetLocalPoint(i)); this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle() } }(), function () { var n = Box2D.Dynamics.b2DebugDraw; n.b2DebugDraw = function () { this.m_xformScale = this.m_fillAlpha = this.m_alpha = this.m_lineThickness = this.m_drawScale = 1; var n = this; this.m_sprite = { graphics: { clear: function () { n.m_ctx.clearRect(0, 0, n.m_ctx.canvas.width, n.m_ctx.canvas.height) } } } }; n.prototype._color = function (n, t) { return "rgba(" + ((n & 16711680) >> 16) + "," + ((n & 65280) >> 8) + "," + (n & 255) + "," + t + ")" }; n.prototype.b2DebugDraw = function () { this.m_drawFlags = 0 }; n.prototype.SetFlags = function (n) { n === undefined && (n = 0); this.m_drawFlags = n }; n.prototype.GetFlags = function () { return this.m_drawFlags }; n.prototype.AppendFlags = function (n) { n === undefined && (n = 0); this.m_drawFlags |= n }; n.prototype.ClearFlags = function (n) { n === undefined && (n = 0); this.m_drawFlags &= ~n }; n.prototype.SetSprite = function (n) { this.m_ctx = n }; n.prototype.GetSprite = function () { return this.m_ctx }; n.prototype.SetDrawScale = function (n) { n === undefined && (n = 0); this.m_drawScale = n }; n.prototype.GetDrawScale = function () { return this.m_drawScale }; n.prototype.SetLineThickness = function (n) { n === undefined && (n = 0); this.m_lineThickness = n; this.m_ctx.strokeWidth = n }; n.prototype.GetLineThickness = function () { return this.m_lineThickness }; n.prototype.SetAlpha = function (n) { n === undefined && (n = 0); this.m_alpha = n }; n.prototype.GetAlpha = function () { return this.m_alpha }; n.prototype.SetFillAlpha = function (n) { n === undefined && (n = 0); this.m_fillAlpha = n }; n.prototype.GetFillAlpha = function () { return this.m_fillAlpha }; n.prototype.SetXFormScale = function (n) { n === undefined && (n = 0); this.m_xformScale = n }; n.prototype.GetXFormScale = function () { return this.m_xformScale }; n.prototype.DrawPolygon = function (n, t, i) { if (t) { var r = this.m_ctx, u = this.m_drawScale; for (r.beginPath(), r.strokeStyle = this._color(i.color, this.m_alpha), r.moveTo(n[0].x * u, n[0].y * u), i = 1; i < t; i++) r.lineTo(n[i].x * u, n[i].y * u); r.lineTo(n[0].x * u, n[0].y * u); r.closePath(); r.stroke() } }; n.prototype.DrawSolidPolygon = function (n, t, i) { if (t) { var r = this.m_ctx, u = this.m_drawScale; for (r.beginPath(), r.strokeStyle = this._color(i.color, this.m_alpha), r.fillStyle = this._color(i.color, this.m_fillAlpha), r.moveTo(n[0].x * u, n[0].y * u), i = 1; i < t; i++) r.lineTo(n[i].x * u, n[i].y * u); r.lineTo(n[0].x * u, n[0].y * u); r.closePath(); r.fill(); r.stroke() } }; n.prototype.DrawCircle = function (n, t, i) { if (t) { var r = this.m_ctx, u = this.m_drawScale; r.beginPath(); r.strokeStyle = this._color(i.color, this.m_alpha); r.arc(n.x * u, n.y * u, t * u, 0, Math.PI * 2, !0); r.closePath(); r.stroke() } }; n.prototype.DrawSolidCircle = function (n, t, i, r) { if (t) { var u = this.m_ctx, f = this.m_drawScale, e = n.x * f, o = n.y * f; u.moveTo(0, 0); u.beginPath(); u.strokeStyle = this._color(r.color, this.m_alpha); u.fillStyle = this._color(r.color, this.m_fillAlpha); u.arc(e, o, t * f, 0, Math.PI * 2, !0); u.moveTo(e, o); u.lineTo((n.x + i.x * t) * f, (n.y + i.y * t) * f); u.closePath(); u.fill(); u.stroke() } }; n.prototype.DrawSegment = function (n, t, i) { var r = this.m_ctx, u = this.m_drawScale; r.strokeStyle = this._color(i.color, this.m_alpha); r.beginPath(); r.moveTo(n.x * u, n.y * u); r.lineTo(t.x * u, t.y * u); r.closePath(); r.stroke() }; n.prototype.DrawTransform = function (n) { var t = this.m_ctx, i = this.m_drawScale; t.beginPath(); t.strokeStyle = this._color(16711680, this.m_alpha); t.moveTo(n.position.x * i, n.position.y * i); t.lineTo((n.position.x + this.m_xformScale * n.R.col1.x) * i, (n.position.y + this.m_xformScale * n.R.col1.y) * i); t.strokeStyle = this._color(65280, this.m_alpha); t.moveTo(n.position.x * i, n.position.y * i); t.lineTo((n.position.x + this.m_xformScale * n.R.col2.x) * i, (n.position.y + this.m_xformScale * n.R.col2.y) * i); t.closePath(); t.stroke() } }(), i = 0; i < Box2D.postDefs.length; ++i) Box2D.postDefs[i](); delete Box2D.postDefs; Box2D.Box2DSeparator || (Box2D.Box2DSeparator = {}), function () { function n() { } var i = Box2D.Collision.Shapes.b2PolygonShape, t = Box2D.Common.Math.b2Vec2, r = Box2D.Dynamics.b2Body, u = Box2D.Dynamics.b2FixtureDef; n.prototype.Separate = function (n, r, u, f) { f || (f = 30); for (var h = u.length, s, a, o = [], c, l, e = 0; e < h; e++) o.push(new t(u[e].x * f, u[e].y * f)); for (c = this.calcShapes(o), h = c.length, e = 0; e < h; e++) { for (u = [], o = c[e], a = o.length, s = 0; s < a; s++) u.push(new t(o[s].x / f, o[s].y / f)); l = new i; l.SetAsVector(u); r.shape = l; n.CreateFixture(r) } }; n.prototype.Validate = function (n) { for (var u = n.length, i, o, r, s, h, f = 0, e, c = !1, t = 0; t < u; t++) { for (r = t < u - 1 ? t + 1 : 0, s = t > 0 ? t - 1 : u - 1, e = !1, i = 0; i < u; i++) i != t && i != r && (e || (h = this.det(n[t].x, n[t].y, n[r].x, n[r].y, n[i].x, n[i].y), h > 0 && (e = !0)), i != s && (o = i < u - 1 ? i + 1 : 0, this.hitSegment(n[t].x, n[t].y, n[r].x, n[r].y, n[i].x, n[i].y, n[o].x, n[o].y) && (f = 1))); e || (c = !0) } return c && (f = f == 1 ? 3 : 2), f }; n.prototype.calcShapes = function (n) { var i, f, u, o, ft, nt, tt, it, k, d, g, et, c, e, rt, l, y, s, h, t, r, a, w, b, v, ut, ot = [], p = []; for (p.push(n) ; p.length;) { for (i = p[0], u = i.length, ut = !0, f = 0; f < u; f++) if (d = f, g = f < u - 1 ? f + 1 : f + 1 - u, et = f < u - 2 ? f + 2 : f + 2 - u, c = i[d], e = i[g], rt = i[et], ft = this.det(c.x, c.y, e.x, e.y, rt.x, rt.y), ft < 0) { for (ut = !1, k = Number.MAX_VALUE, o = 0; o < u; o++) o != d && o != g && (l = o, y = o < u - 1 ? o + 1 : 0, s = i[l], h = i[y], b = this.hitRay(c.x, c.y, e.x, e.y, s.x, s.y, h.x, h.y), b && (tt = e.x - b.x, it = e.y - b.y, nt = tt * tt + it * it, nt < k && (r = l, t = y, v = b, k = nt))); for (k == Number.MAX_VALUE && err(), a = [], w = [], l = r, y = t, s = i[l], h = i[y], this.pointsMatch(v.x, v.y, h.x, h.y) || a.push(v), this.pointsMatch(v.x, v.y, s.x, s.y) || w.push(v), r = -1, t = d; ;) { if (t != y) a.push(i[t]); else { (r < 0 || r >= u) && this.err(); this.isOnSegment(h.x, h.y, i[r].x, i[r].y, c.x, c.y) || a.push(i[t]); break } r = t; t - 1 < 0 ? t = u - 1 : t-- } for (a = a.reverse(), r = -1, t = g; ;) { if (t != l) w.push(i[t]); else { (r < 0 || r >= u) && this.err(); t != l || this.isOnSegment(s.x, s.y, i[r].x, i[r].y, e.x, e.y) || w.push(i[t]); break } r = t; t + 1 > u - 1 ? t = 0 : t++ } p.push(a, w); p.shift(); break } ut && ot.push(p.shift()) } return ot }; n.prototype.hitRay = function (n, i, r, u, f, e, o, s) { var w = f - n, b = e - i, l = r - n, a = u - i, v = o - f, y = s - e, k = a * v - l * y, p = (v * b - y * w) / k; var h = n + p * l, c = i + p * a, d = this.isOnSegment(r, u, n, i, h, c), g = this.isOnSegment(h, c, f, e, o, s); return d && g ? new t(h, c) : null }; n.prototype.hitSegment = function (n, i, r, u, f, e, o, s) { var w = f - n, b = e - i, l = r - n, a = u - i, v = o - f, y = s - e, k = a * v - l * y, p = (v * b - y * w) / k; var h = n + p * l, c = i + p * a, d = this.isOnSegment(h, c, n, i, r, u), g = this.isOnSegment(h, c, f, e, o, s); return d && g ? new t(h, c) : null }; n.prototype.isOnSegment = function (n, t, i, r, u, f) { var e = i + .1 >= n && n >= u - .1 || i - .1 <= n && n <= u + .1, o = r + .1 >= t && t >= f - .1 || r - .1 <= t && t <= f + .1; return e && o && this.isOnLine(n, t, i, r, u, f) }; n.prototype.pointsMatch = function (n, t, i, r) { var u = i >= n ? i - n : n - i, f = r >= t ? r - t : t - r; return u < .1 && f < .1 }; n.prototype.isOnLine = function (n, t, i, r, u, f) { if (u - i > .1 || i - u > .1) { var o = (f - r) / (u - i), e = o * (n - i) + r, s = e > t ? e - t : t - e; return s < .1 } return n - i < .1 || i - n < .1 }; n.prototype.det = function (n, t, i, r, u, f) { return n * r + i * f + u * t - t * i - r * u - f * n }; n.prototype.err = function () { throw new Error("A problem has occurred. Use the Validate() method to see where the problem is."); }; Box2D.Box2DSeparator.b2Separator = n }(); !function () { var t = !1, i = /xyz/.test(function () { }) ? /\b_super\b/ : /.*/, n = function () { }; n.extend = function (n) { function u() { !t && this.ctor && this.ctor.apply(this, arguments) } var e, f, r, o = this.prototype; t = !0; e = new this; t = !1; for (r in n) "statics" != r && (e[r] = "function" == typeof n[r] && "function" == typeof o[r] && i.test(n[r]) ? function (n, t) { return function () { var i, r = this._super; return this._super = o[n], i = t.apply(this, arguments), this._super = r, i } }(r, n[r]) : n[r]); for (f in this) this.hasOwnProperty(f) && "extend" != f && (u[f] = this[f]); if (u.prototype = e, n.statics) for (r in n.statics) n.statics.hasOwnProperty(r) && (u[r] = n.statics[r], "ctor" == r && u[r]()); return u.prototype.constructor = u, u.extend = arguments.callee, u.implement = function (n) { for (var t in n) e[t] = n[t] }, u }, function () { var t = {}, i = {}; t.CanvasRenderer = n.extend({ ctor: function (n) { n && (this.stage = n, this.ctx = n.ctx, this.height = n.width, this.width = n.height) }, update: function () { this.ctx.clearRect(0, 0, this.height, this.width); this.render(this.ctx, this.stage) }, render: function (n, i, r) { var s, h, o, f, u, l, e; if (i.isVisible()) { if (r ? i._matrix.reinitialize(r.a, r.b, r.c, r.d, r.tx, r.ty, r.alpha, r.shadow, r.compositeOperation) : i._matrix.reinitialize(1, 0, 0, 1, 0, 0), r = i._matrix, r.appendTransform(i.x, i.y, i.scaleX, i.scaleY, i.rotation, i.skewX, i.skewY, i.regX, i.regY), s = n.globalAlpha, h = n.globalCompositeOperation, n.globalAlpha *= i.alpha, n.globalCompositeOperation = i.compositeOperation, o = i.cacheCanvas || i.txtCanvas, o) n.setTransform(r.a, r.b, r.c, r.d, r.tx + .5 | 0, r.ty + .5 | 0), n.drawImage(o, 0, 0); else if (i instanceof t.Container || i instanceof t.Stage) for (var c = i.children.slice(0), u = 0, a = c.length; a > u; u++) n.save(), this.render(n, c[u], r), n.restore(); else if (i instanceof t.Bitmap || i instanceof t.Sprite) f = i.rect, n.setTransform(r.a, r.b, r.c, r.d, r.tx + .5 | 0, r.ty + .5 | 0), n.drawImage(i.img, f[0], f[1], f[2], f[3], 0, 0, f[2], f[3]); else if (i instanceof t.Shape) for (n.setTransform(r.a, r.b, r.c, r.d, r.tx + .5 | 0, r.ty + .5 | 0), u = 0, l = i.cmds.length; l > u; u++) e = i.cmds[u], i.assMethod.join("-").match(new RegExp("\\b" + e[0] + "\\b", "g")) ? n[e[0]] = e[1][0] : n[e[0]].apply(n, Array.prototype.slice.call(e[1])); n.globalAlpha = s; n.globalCompositeOperation = h } }, hitRender: function (n, t, i, r, u, f) { var s; n.clearRect(0, 0, 2, 2); i ? t._matrix.reinitialize(i.a, i.b, i.c, i.d, i.tx, i.ty, i.alpha, i.shadow, i.compositeOperation) : t._matrix.reinitialize(1, 0, 0, 1, 0, 0); i = t._matrix; i.appendTransform(t.x, t.y, t.scaleX, t.scaleY, t.rotation, t.skewX, t.skewY, t.regX, t.regY); for (var o = t.children.slice(0), h = o.length, e = h - 1; e >= 0; e--) if (s = o[e], i.reinitialize(1, 0, 0, 1, 0, 0), i.appendTransform(t.x - r, t.y - u, t.scaleX, t.scaleY, t.rotation, t.skewX, t.skewY, t.regX, t.regY), n.save(), s = o[e], this._hitRender(n, o[e], i, f), n.restore(), n.getImageData(0, 0, 1, 1).data[3] > 1) return s.execEvent(f), s }, _hitRender: function (n, i, r, u) { var h, s, f; if (i.isVisible()) { if (r ? i._matrix.reinitialize(r.a, r.b, r.c, r.d, r.tx, r.ty, r.alpha, r.shadow, r.compositeOperation) : i._matrix.reinitialize(1, 0, 0, 1, 0, 0), r = i._matrix, r.appendTransform(i.x, i.y, i.scaleX, i.scaleY, i.rotation, i.skewX, i.skewY, i.regX, i.regY), h = n.globalAlpha, n.globalAlpha *= i.alpha, i.cacheCanvas) n.setTransform(r.a, r.b, r.c, r.d, r.tx + .5 | 0, r.ty + .5 | 0), n.drawImage(i.cacheCanvas || i.img, 0, 0); else if (i instanceof t.Container) for (var o = i.children.slice(0), c = o.length, e = c - 1; e >= 0; e--) s = o[e], n.save(), s = o[e], this._hitRender(n, o[e], r), n.restore(), n.getImageData(0, 0, 1, 1).data[3] > 1 && s.execEvent(u); else (i instanceof t.Bitmap || i instanceof t.Sprite) && (f = i.rect, n.setTransform(r.a, r.b, r.c, r.d, r.tx + .5 | 0, r.ty + .5 | 0), n.drawImage(i.img, f[0], f[1], f[2], f[3], 0, 0, f[2], f[3])); n.globalAlpha = h } }, updateCache: function (n, t, i, r) { n.clearRect(0, 0, i + 1, r + 1); this.renderCache(n, t) }, renderCache: function (n, i) { var u, r, o, f; if (i.isVisible()) if (i instanceof t.Container || i instanceof t.Stage) for (var e = i.children.slice(0), r = 0, s = e.length; s > r; r++) n.save(), this.render(n, e[r]), n.restore(); else if (i instanceof t.Bitmap || i instanceof t.Sprite) u = i.rect, n.drawImage(i.img, u[0], u[1], u[2], u[3], 0, 0, u[2], u[3]); else if (i instanceof t.Shape) for (r = 0, o = i.cmds.length; o > r; r++) f = i.cmds[r], i.assMethod.join("-").match(new RegExp("\\b" + f[0] + "\\b", "g")) ? n[f[0]] = f[1][0] : n[f[0]].apply(n, Array.prototype.slice.call(f[1])) } }); i.Main = n.extend({ ctor: function () { function l() { var t = n.pyBody, i = t.GetPosition(), r = t.GetAngle(); n.x = 30 * i.x; n.y = 30 * i.y; n.rotation = 180 * r / Math.PI } function a() { for (var t = 0, i = s.length; i > t; t++) { var n = s[t], r = n.GetPosition(), u = n.GetAngle(); n.bitmap.x = 30 * r.x; n.bitmap.y = 30 * r.y; n.bitmap.rotation = 180 * u / Math.PI } } function o() { n.direction = p(); n.direction ? ("left" == n.direction ? n.pyBody.SetLinearVelocity(new u(-3, 0)) : "right" == n.direction ? n.pyBody.SetLinearVelocity(new u(3, 0)) : "down" == n.direction ? n.pyBody.SetLinearVelocity(new u(0, 3)) : "up" == n.direction && n.pyBody.SetLinearVelocity(new u(0, -3)), n.pyBody.SetAngle(n.rttDirMap[n.direction] * Math.PI / 180)) : (n.pyBody.SetAngularVelocity(0), n.pyBody.SetLinearVelocity(new u(0, 0))) } function v() { r.onKeyboard("left", function () { n.pyBody.SetAngularVelocity(0); n.pyBody.SetAngle(3 * Math.PI / 2); n.pyBody.SetLinearVelocity(new u(-3, 0)) }, function () { o() }); r.onKeyboard("right", function () { n.pyBody.SetAngularVelocity(0); n.pyBody.SetAngle(Math.PI / 2); n.pyBody.SetLinearVelocity(new u(3, 0)) }, function () { o() }); r.onKeyboard("down", function () { n.pyBody.SetAngularVelocity(0); n.pyBody.SetAngle(Math.PI); n.pyBody.SetLinearVelocity(new u(0, 3)) }, function () { o() }); r.onKeyboard("up", function () { n.pyBody.SetAngularVelocity(0); n.pyBody.SetAngle(0); n.pyBody.SetLinearVelocity(new u(0, -3)) }, function () { o() }); r.onKeyboard("left+up", function () { n.pyBody.SetAngularVelocity(0); n.pyBody.SetAngle(7 * Math.PI / 4); n.pyBody.SetLinearVelocity(new u(-1.5, -1.5)) }, function () { o() }); r.onKeyboard("right+up", function () { n.pyBody.SetAngularVelocity(0); n.pyBody.SetAngle(Math.PI / 4); n.pyBody.SetLinearVelocity(new u(1.5, -1.5)) }, function () { o() }); r.onKeyboard("right+down", function () { n.pyBody.SetAngularVelocity(0); n.pyBody.SetAngle(3 * Math.PI / 4); n.pyBody.SetLinearVelocity(new u(1.5, 1.5)) }, function () { o() }); r.onKeyboard("left+down", function () { n.pyBody.SetAngularVelocity(0); n.pyBody.SetAngle(5 * Math.PI / 4); n.pyBody.SetLinearVelocity(new u(-1.5, 1.5)) }, function () { o() }) } function y() { return -1 == r.getActiveKeys().indexOf("left") && -1 == r.getActiveKeys().indexOf("up") && -1 == r.getActiveKeys().indexOf("down") && -1 == r.getActiveKeys().indexOf("right") } function p() { return -1 !== r.getActiveKeys().indexOf("left") ? "left" : -1 !== r.getActiveKeys().indexOf("right") ? "right" : -1 !== r.getActiveKeys().indexOf("up") ? "up" : -1 !== r.getActiveKeys().indexOf("down") ? "down" : void 0 } function w() { var n = new c; n.SetSprite(document.getElementById("canvas").getContext("2d")); n.SetDrawScale(30); n.SetFillAlpha(.5); n.SetLineThickness(1); n.SetFlags(c.e_shapeBit | c.e_jointBit); f.SetDebugDraw(n) } var n, u = Box2D.Common.Math.b2Vec2, e = (Box2D.Collision.b2AABB, Box2D.Dynamics.b2BodyDef, Box2D.Dynamics.b2Body), b = (Box2D.Dynamics.b2FixtureDef, Box2D.Dynamics.b2Fixture, Box2D.Dynamics.b2World), c = (Box2D.Collision.Shapes.b2PolygonShape, Box2D.Dynamics.b2DebugDraw), f = (Box2D.Collision.Shapes.b2CircleShape, Box2D.Box2DSeparator.b2Separator, new b(new u(0, 0), !1)), s = [], h = new t.Loader, r = new t.Stage("#ourCanvas", "1" == localStorage.webgl); h.loadRes([{ id: "tanks", src: "../asset/img/tanks.png" }, { id: "elements", src: "../asset/img/elements.png" }, { id: "box", src: "../asset/img/box.jpg" }, { id: "ball", src: "../asset/img/basketball.png" }]); h.complete(function () { var o, c, b, p; n = new i.Tank({ img: h.get("tanks"), imgRect: [109, 5, 31, 44], width: 31, height: 44, x: 300, y: 300, type: e.b2_dynamicBody, world: f }); r.add(n); v(); w(); var t = h.get("box"), k = i.PyBodyFactory.createRect({ x: 320, y: 480, width: 640, height: 30, type: e.b2_staticBody, world: f, img: t, imgRect: [0, 0, t.width, t.height], stage: r }), d = i.PyBodyFactory.createRect({ x: 320, y: 0, width: 640, height: 30, type: e.b2_staticBody, world: f, img: t, imgRect: [0, 0, t.width, t.height], stage: r }), g = i.PyBodyFactory.createRect({ x: 0, y: 240, width: 30, height: 480, type: e.b2_staticBody, world: f, img: t, imgRect: [0, 0, t.width, t.height], stage: r }), nt = i.PyBodyFactory.createRect({ x: 640, y: 240, width: 30, height: 480, type: e.b2_staticBody, world: f, img: t, imgRect: [0, 0, t.width, t.height], stage: r }); s.push(k, d, g, nt); o = i.PyBodyFactory.createRect({ x: 100, y: 100, width: 50, height: 50, type: e.b2_staticBody, world: f, img: t, imgRect: [0, 0, t.width, t.height], stage: r }); s.push(o); o = i.PyBodyFactory.createRect({ x: 300, y: 100, width: 50, height: 50, type: e.b2_staticBody, world: f, img: t, imgRect: [0, 0, t.width, t.height], stage: r }); s.push(o); c = h.get("ball"); b = i.PyBodyFactory.createCircle({ x: 200, y: 200, r: 50, type: e.b2_staticBody, world: f, img: c, imgRect: [0, 0, c.width, c.height], stage: r }); s.push(b); p = new i.Block({ x: 340, y: 230, type: e.b2_staticBody, world: f, stage: r, verticesList: [{ x: 15, y: 1 }, { x: 37, y: 25 }, { x: 101, y: 2 }, { x: 136, y: 16 }, { x: 131, y: 86 }, { x: 81, y: 60 }, { x: 34, y: 85 }, { x: 17, y: 77 }, { x: 25, y: 62 }, { x: 3, y: 31 }], img: h.get("elements"), imgRect: [250, 150, 135, 86], world: f }); s.push(p.body); r.add(p); r.onTick(function () { y() && (n.stop(), n.pyBody.SetAngularVelocity(0), n.pyBody.SetLinearVelocity(new u(0, 0))); f.Step(1 / 60, 10, 10); f.DrawDebugData(); a(); l() }) }) } }); t.DisplayObject = n.extend({ ctor: function () { this.alpha = this.scaleX = this.scaleY = 1; this.x = this.y = this.rotation = this.originX = this.originY = this.skewX = this.skewY = this.width = this.height = 0; this.visible = !0; this._matrix = new t.Matrix2D; this.events = {}; this.id = t.UID.get(); this.baseInstanceof = "DisplayObject"; var n = this; this._watch(this, "originX", function (t, i) { n.regX = n.width * i }); this._watch(this, "originY", function (t, i) { n.regY = n.height * i }) }, _watch: function (n, t, i) { n["__" + t] = this[t]; Object.defineProperty(n, t, { get: function () { return this["__" + t] }, set: function (n) { this["__" + t] = n; i(t, n) } }) }, isVisible: function () { return !!(this.visible && this.alpha > 0 && 0 != this.scaleX && 0 != this.scaleY) }, on: function (n, i) { "mouseover_mousemove_mouseout_touchstart_touchmove_touchend".match(n) && (t.Stage.checkMove = !0); this.events[n] || (this.events[n] = []); this.events[n].push(i) }, execEvent: function (n) { var t = this.events[n]; this._fireFns(t) }, hover: function (n, t) { this.on("mouseover", n); this.on("mouseout", t) }, _fireFns: function (n) { if (n) for (var t = 0, i = n.length; i > t; t++) n[t].call(this) }, clone: function () { var n = new t.DisplayObject; return this.cloneProps(n), n }, cloneProps: function (n) { n.visible = this.visible; n.alpha = this.alpha; n.originX = this.originX; n.originY = this.originY; n.rotation = this.rotation; n.scaleX = this.scaleX; n.scaleY = this.scaleY; n.skewX = this.skewX; n.skewY = this.skewY; n.x = this.x; n.y = this.y; n.regX = this.regX; n.regY = this.regY }, cache: function (n, i, r, u) { if (!this.cacheCanvas) { this.cacheCanvas = document.createElement("canvas"); var f = this.getBound(); this.cacheCanvas.width = f.width; this.cacheCanvas.height = f.height; this.cacheCtx = this.cacheCanvas.getContext("2d") } t.Stage.renderer.updateCache(this.cacheCtx, this, r, u) }, uncache: function () { this.cacheCanvas = null; this.cacheCtx = null; this.cacheID = null }, getBound: function () { return { width: this.width, height: this.height } }, toCenter: function () { this.originX = .5; this.originY = .5; this.x = this.parent.width / 2; this.y = this.parent.height / 2 }, onClick: function (n) { this.on("click", n) }, onMouseMove: function (n) { this.on("mousemove", n) } }); t.Container = t.DisplayObject.extend({ ctor: function () { this._super(); this.children = []; this.baseInstanceof = "Container" }, add: function (n) { var r = arguments.length, t, i; if (r > 1) for (t = 0; r > t; t++) i = arguments[t], i && (this.children.push(i), i.parent = this); else n && (this.children.push(n), n.parent = this) }, remove: function (n) { var f = arguments.length, e = this.children.length, t, u, i, r; if (f > 1) { for (t = 0; f > t; t++) for (u = arguments[t], i = e; --i >= 0;) if (this.children[i].id == u.id) { u.parent = null; this.children.splice(i, 1); break } } else for (r = e; --r >= 0;) if (this.children[r].id == n.id) { n.parent = null; this.children.splice(r, 1); break } }, clone: function () { var i = new t.Container, r, n, u; for (this.cloneProps(i), r = i.children = [], n = this.children.length - 1; n > -1; n--) u = this.children[n].clone(), r.unshift(u); return i }, removeAll: function () { for (var n = this.children; n.length;) n.pop().parent = null } }); i.Block = t.Container.extend({ ctor: function (n) { this._super(); this.body = i.PyBodyFactory.createPolygon(n); this.add(this.body.bitmap) } }); i.PyBodyFactory = n.extend({ statics: { ctor: function () { this.b2Vec2 = Box2D.Common.Math.b2Vec2; this.b2AABB = Box2D.Collision.b2AABB; this.b2BodyDef = Box2D.Dynamics.b2BodyDef; this.b2Body = Box2D.Dynamics.b2Body; this.b2FixtureDef = Box2D.Dynamics.b2FixtureDef; this.b2Fixture = Box2D.Dynamics.b2Fixture; this.b2World = Box2D.Dynamics.b2World; this.b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape; this.b2DebugDraw = Box2D.Dynamics.b2DebugDraw; this.b2CircleShape = Box2D.Collision.Shapes.b2CircleShape; this.b2Separator = Box2D.Box2DSeparator.b2Separator; this.worldScale = 30 }, createRect: function (n) { var c = n.x, l = n.y, o = n.width, s = n.height, a = n.type, v = n.world, y = n.img, h = n.stage, u = n.imgRect, f = new this.b2BodyDef, e, r, i; return f.type = a, f.position.Set(c / this.worldScale, l / this.worldScale), e = new this.b2PolygonShape, e.SetAsBox(o / 2 / this.worldScale, s / 2 / this.worldScale), r = new this.b2FixtureDef, r.density = 1, r.friction = .5, r.restitution = .5, r.shape = e, i = v.CreateBody(f), i.bitmap = new t.Bitmap(y), i.bitmap.scaleX = o / u[2], i.bitmap.scaleY = s / u[3], i.bitmap.setRect(u), i.bitmap.originX = i.bitmap.originY = .5, h && h.add(i.bitmap), i.CreateFixture(r), i }, createCircle: function (n) { var h = n.x, c = n.y, e = n.r, l = n.type, a = n.world, v = n.img, o = n.stage, s = n.imgRect, u = new this.b2BodyDef, f, r, i; return u.type = l, u.position.Set(h / this.worldScale, c / this.worldScale), f = new this.b2CircleShape, f.SetRadius(e / this.worldScale), r = new this.b2FixtureDef, r.density = 1, r.friction = .5, r.restitution = .5, r.shape = f, i = a.CreateBody(u), i.bitmap = new t.Bitmap(v), i.bitmap.originX = i.bitmap.originY = .5, i.bitmap.scaleX = i.bitmap.scaleY = 2 * e / s[2], i.bitmap.setRect(s), o && o.add(i.bitmap), i.CreateFixture(r), i }, createPolygon: function (n) { var c = n.x, l = n.y, i = n.verticesList, a = n.type, v = n.world, o = n.stage, y = n.img, p = n.imgRect, f = new this.b2BodyDef, s = new this.b2FixtureDef, u; for (f.type = a, f.position.Set(c / this.worldScale, l / this.worldScale), u = 0; u < i.length; u++) i[u].x /= this.worldScale, i[u].y /= this.worldScale; var e = new this.b2Separator, r = v.CreateBody(f), h = e.Validate(i); return 2 == h ? (i.reverse(), e.Separate(r, s, i)) : 0 == h && e.Separate(r, s, i), r.bitmap = new t.Bitmap(y), r.bitmap.setRect(p), o && o.add(r.bitmap), r } } }); t.Loader = n.extend({ ctor: function () { this.audios = {}; this.res = {}; this.loadedCount = 0; this.resCount = -1; this.FILE_PATTERN = /(\w+:\/{2})?((?:\w+\.){2}\w+)?(\/?[\S]+\/|\/)?([\w\-%\.]+)(?:\.)(\w+)?(\?\S+)?/i; this.ns = 3; this.sounds = []; for (var n = 0; n < this.ns; n++) this.sounds.push([]); this.playing = []; this.soundsCount = 0 }, get: function (n) { return this.res[n] }, loadRes: function (n) { this.resCount = n.length; for (var t = 0; t < n.length; t++) "audio" == this._getTypeByExtension(n[t].src.match(this.FILE_PATTERN)[5]) ? this.loadAudio(n[t].id, n[t].src) : this.loadImage(n[t].id, n[t].src) }, loadImage: function (n, t) { var i = document.createElement("img"), r = this; i.onload = function () { r._handleLoad(this, n); i.onreadystatechange = null }; i.onreadystatechange = function () { ("loaded" == i.readyState || "complete" == i.readyState) && (r._handleLoad(this, n), i.onload = null) }; i.onerror = function () { }; i.src = t }, loadAudio: function (n, t) { var i = document.createElement("audio"), r, u; i.autoplay = !1; this.res[n] = i; i.src = null; i.preload = "auto"; i.onerror = function () { }; i.onstalled = function () { }; r = this; u = function () { r.playing[n] = 0; for (var i = 0; i < r.ns; i++) r.sounds[i][n] = new Audio(t); r.loadedCount++; r.handleProgress(r.loadedCount, r.resCount); r._clean(this); this.removeEventListener && this.removeEventListener("canplaythrough", u, !1); r.checkComplete() }; i.addEventListener("canplaythrough", u, !1); i.src = t; null != i.load && i.load() }, checkComplete: function () { this.loadedCount === this.resCount && this.handleComplete() }, complete: function (n) { this.handleComplete = n }, progress: function (n) { this.handleProgress = n }, playSound: function (n) { this.sounds[this.playing[n]][n].play(); ++this.playing[n]; this.playing[n] >= this.ns && (this.playing[n] = 0) }, _handleLoad: function (n, t) { this._clean(n); this.res[t] = n; this.loadedCount++; this.handleProgress && this.handleProgress(this.loadedCount, this.resCount); this.checkComplete() }, _getTypeByExtension: function (n) { switch (n) { case "jpeg": case "jpg": case "gif": case "png": case "webp": case "bmp": return "img"; case "ogg": case "mp3": case "wav": return "audio" } }, _clean: function (n) { n.onload = null; n.onstalled = null; n.onprogress = null; n.onerror = null } }); t.Stage = t.Container.extend({ statics: { checkMove: !1 }, ctor: function (n, i) { var u, r; this._super(); this.canvas = "string" == typeof n ? document.querySelector(n) : n; this.width = this.canvas.width; this.height = this.canvas.height; u = (!!window.CanvasRenderingContext2D, function () { try { var n = document.createElement("canvas"); return !(!window.WebGLRenderingContext || !n.getContext("webgl") && !n.getContext("experimental-webgl")) } catch (t) { return !1 } }()); u && !i ? this.renderer = new t.WebGLRenderer(this) : (this.ctx = this.canvas.getContext("2d"), this.renderer = new t.CanvasRenderer(this)); t.Stage.renderer = this.renderer; this.hitRenderer = new t.CanvasRenderer(this); this.hitCanvas = document.createElement("canvas"); this.hitCanvas.width = 1; this.hitCanvas.height = 1; this.hitCtx = this.hitCanvas.getContext("2d"); Function.prototype.bind = function () { var t = this, n = Array.prototype.slice.call(arguments), i = n.shift(); return function () { return t.apply(i, n.concat(Array.prototype.slice.call(arguments))) } }; this.canvas.addEventListener("click", this._handleClick.bind(this), !1); this.canvas.addEventListener("mousemove", this._handleMouseMove.bind(this), !1); window.addEventListener("keydown", this._handleKeyDown.bind(this), !1); window.addEventListener("keyup", this._handleKeyUp.bind(this), !1); this.offset = this._getXY(this.canvas); this.overObj = null; this.pause = !1; this.interval = Math.floor(1e3 / 60); r = this; r.loop = t.RAF.requestInterval(function () { r._tick(r) }, r.interval) }, update: function () { this.pause || this.renderer.update() }, _handleKeyDown: function (n) { this.keyDownCallback && this.keyDownCallback(n.keyCode) }, _handleKeyUp: function (n) { this.keyUpCallback && this.keyUpCallback(n.keyCode) }, _handleClick: function (n) { var t, i, r, u; if (n.stageX = n.pageX - this.offset[0], n.stageY = n.pageY - this.offset[1], t = this.events.click, t) for (i = 0, r = t.length; r > i; i++) u = t[i], u(n); this.hitRenderer.hitRender(this.hitCtx, this, null, n.pageX - this.offset[0], n.pageY - this.offset[1], "click") }, _handleMouseMove: function (n) { var t, i, r, u; if (n.stageX = n.pageX - this.offset[0], n.stageY = n.pageY - this.offset[1], t = this.events.mousemove, t) for (i = 0, r = t.length; r > i; i++) u = t[i], u(n) }, _getXY: function (n) { var t = 0, i = 0, r; if (!document.documentElement.getBoundingClientRect || !n.getBoundingClientRect) { for (; n.offsetParent;) t += n.offsetTop, i += n.offsetLeft, n = n.offsetParent; return [i, t] } return r = n.getBoundingClientRect(), i = r.left, t = r.top, [i + Math.max(document.documentElement.scrollLeft, document.body.scrollLeft), t + Math.max(document.documentElement.scrollTop, document.body.scrollTop)] }, destroy: function () { }, _tick: function (n) { var t, i; n.tick && ((this._initInterval(n), n.hasOwnProperty("_tickInterval")) ? (n._tickIntervalCurrent = new Date, n._tickIntervalLast || (n._tickIntervalLast = new Date), i = n._tickIntervalCurrent - n._tickIntervalLast, i > n._tickInterval && (n.tick(), n._tickIntervalLast = n._tickIntervalCurrent)) : n.tick()); for (var u = n.children, f = u.length, r = 0; f > r; r++) t = u[r], t.tick && ((this._initInterval(t), t.hasOwnProperty("_tickInterval")) ? (t._tickIntervalCurrent = new Date, t._tickIntervalLast || (t._tickIntervalLast = new Date), i = t._tickIntervalCurrent - t._tickIntervalLast, i > t._tickInterval && (t.tick(), t._tickIntervalLast = t._tickIntervalCurrent)) : t.tick()), "Container" == t.baseInstanceof && this._tick(t) }, _initInterval: function (n) { n.hasOwnProperty("tickFPS") && (n._tickInterval = 0 == n.tickFPS ? 1e4 : 1e3 / n.tickFPS) }, tick: function () { this.tickFn && this.tickFn(); this.update() }, onTick: function (n) { this.tickFn = n }, setFPS: function (n) { this.interval = Math.floor(1e3 / n) }, onKeyDown: function (n) { this.keyDownCallback = n }, onKeyUp: function (n) { this.keyUpCallback = n }, onKeyboard: function (n, i, r) { t.Keyboard.on(n, i, r) }, getActiveKeys: function () { return t.Keyboard.getActiveKeys() } }); t.Bitmap = t.DisplayObject.extend({ ctor: function (n) { if (this._super(), "string" == typeof n) { var t = this; this.visible = !1; this.img = document.createElement("img"); this.img.onload = function () { t.visible = !0; t.rect || (t.rect = [0, 0, t.img.width, t.img.height]); t.width = t.rect[2]; t.height = t.rect[3]; t.regX = t.width * t.originX; t.regY = t.height * t.originY }; this.img.src = n } else this.img = n, this.rect = [0, 0, n.width, n.height], this.width = n.width, this.height = n.height }, setFilter: function (n, t, i, r) { this.uncache(); this.cache(); for (var e = this.cacheCtx.getImageData(0, 0, this.cacheCanvas.width, this.cacheCanvas.height), f = e.data, u = 0, o = f.length; o > u; u += 4) f[u + 3] > 0 && (f[u] *= n, f[u + 1] *= t, f[u + 2] *= i, f[u + 3] *= r); this.cacheCtx.putImageData(e, 0, 0) }, setRect: function (n, t, i, r) { 1 === arguments.length ? this.setRect.apply(this, arguments[0]) : (this.rect = [n, t, i, r], this.width = i, this.height = r, this.regX = this.width * this.originX, this.regY = this.height * this.originY) }, clone: function () { var n = new t.Bitmap(this.img); return n.rect = this.rect.slice(0), this.cloneProps(n), n } }); t.RAF = n.extend({ statics: { ctor: function () { var n = function () { return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (n) { window.setTimeout(n, 1e3 / 60) } }(), t = function (t, i) { function u() { var e = (new Date).getTime(), o = e - f; o >= i && (t.call(), f = (new Date).getTime()); r.value = n(u) } if (!(window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame && window.mozCancelRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame)) return window.setInterval(t, i); var f = (new Date).getTime(), r = {}; return r.value = n(u), r }, i = function (n) { n && setTimeout(function () { window.cancelAnimationFrame ? window.cancelAnimationFrame(n.value) : window.webkitCancelAnimationFrame ? window.webkitCancelAnimationFrame(n.value) : window.webkitCancelRequestAnimationFrame ? window.webkitCancelRequestAnimationFrame(n.value) : window.mozCancelRequestAnimationFrame ? window.mozCancelRequestAnimationFrame(n.value) : window.oCancelRequestAnimationFrame ? window.oCancelRequestAnimationFrame(n.value) : window.msCancelRequestAnimationFrame ? window.msCancelRequestAnimationFrame(n.value) : clearInterval(n) }, 0) }; this.requestInterval = t; this.clearRequestInterval = i } } }); i.Tank = t.Container.extend({ ctor: function (n) { this._super(); this.pyBody = i.PyBodyFactory.createRect(n); this.add(this.pyBody.bitmap); this.gun = new t.Bitmap(n.img); this.gun.setRect(165, 0, 17, 39); this.gun.originX = .5; this.gun.originY = .6; this.gun.y = -5; this.x = 300; this.y = 300; this.add(this.gun); this.direction = ""; this.speed = 2; this.splitSpeed = this.speed / 1.4; this.rttDirMap = { up: 0, up_right: 45, right: 90, right_down: 135, down: 180, down_left: 225, left: 270, left_up: 315 } }, tick: function () { switch (this.turn(this.direction), this.direction) { case "up": this.y -= this.speed; break; case "down": this.y += this.speed; break; case "left": this.x -= this.speed; break; case "right": this.x += this.speed; break; case "up_right": this.x += this.splitSpeed; this.y -= this.splitSpeed; break; case "right_down": this.x += this.splitSpeed; this.y += this.splitSpeed; break; case "down_left": this.x -= this.splitSpeed; this.y += this.splitSpeed; break; case "left_up": this.x -= this.splitSpeed; this.y -= this.splitSpeed } }, stop: function () { this.direction = "" }, turn: function () { this.direction && (this.rotation = this.rttDirMap[this.direction]) } }); t.WebGLRenderer = n.extend({ ctor: function (n) { this.root = n; this.surface = n.canvas; this.MAX_DEPTH = 1048576; this.snapToPixel = !0; this.canvasRenderer = new t.CanvasRenderer }, getSurface: function (n, t) { return null == this.surface && (this.surface = document.createElement("canvas")), n && (this.surface.width = n), t && (this.surface.height = t), this.surface }, clear: function () { this.surface && (this.surface.init || this.initSurface(this.surface)) }, initSurface: function (n) { var i = void 0, f, e, r, s, o, h, u; try { i = n.ctx = n.getContext("experimental-webgl", { preserveDrawingBuffer: !0 }); i.viewportWidth = n.width; i.viewportHeight = n.height } catch (c) { } for (i || alert("Could not initialise WebGL. Make sure you've updated your browser, or try a different one like Google Chrome."), n.idMatrix = t.GLMatrix.mat4.create(), n.orthMatrix = t.GLMatrix.mat4.create(), this._matPool = [], f = i.createShader(i.FRAGMENT_SHADER), i.shaderSource(f, "precision highp float;\nvarying vec3 vTextureCoord;\nvarying float vAlpha;\nuniform float uAlpha;\nuniform sampler2D uSampler0,uSampler1,uSampler2,uSampler3,uSampler4,uSampler5,uSampler6,uSampler7,uSampler8,uSampler9,uSampler10,uSampler11,uSampler12,uSampler13,uSampler14,uSampler15;\nvoid main(void) { \nint sampler = int(vTextureCoord.z); \nvec4 color;\nvec2 coord = vec2(vTextureCoord.s, vTextureCoord.t);\n if (sampler == 0) { color = texture2D(uSampler0, coord); } \nelse if (sampler == 1) { color = texture2D(uSampler1, coord); } \nelse if (sampler == 2) { color = texture2D(uSampler2, coord); } \nelse if (sampler == 3) { color = texture2D(uSampler3, coord); } \nelse if (sampler == 4) { color = texture2D(uSampler4, coord); } \nelse if (sampler == 5) { color = texture2D(uSampler5, coord); } \nelse if (sampler == 6) { color = texture2D(uSampler6, coord); } \nelse if (sampler == 7) { color = texture2D(uSampler7, coord); } \nelse if (sampler == 8) { color = texture2D(uSampler8, coord); } \nelse if (sampler == 9) { color = texture2D(uSampler9, coord); } \nelse if (sampler == 10) { color = texture2D(uSampler10, coord); } \nelse if (sampler == 11) { color = texture2D(uSampler11, coord); } \nelse if (sampler == 12) { color = texture2D(uSampler12, coord); } \nelse if (sampler == 13) { color = texture2D(uSampler13, coord); } \nelse if (sampler == 14) { color = texture2D(uSampler14, coord); } \nelse if (sampler == 15) { color = texture2D(uSampler15, coord); } \nelse { color = texture2D(uSampler0, vec2(vTextureCoord.s, vTextureCoord.t)); } \ngl_FragColor = vec4(color.rgb, color.a * vAlpha);\n}"), i.compileShader(f), i.getShaderParameter(f, i.COMPILE_STATUS) || alert(i.getShaderInfoLog(f)), e = i.createShader(i.VERTEX_SHADER), i.shaderSource(e, "attribute vec3 aVertexPosition;\nattribute vec3 aTextureCoord;\nattribute float aAlpha;\nuniform mat4 uPMatrix;\nuniform bool uSnapToPixel;\nvarying vec3 vTextureCoord;\nvarying float vAlpha;\nvoid main(void) { \nvTextureCoord = aTextureCoord; \nvAlpha = aAlpha; \ngl_Position = uPMatrix * vec4(aVertexPosition, 1.0);\n}"), i.compileShader(e), i.getShaderParameter(e, i.COMPILE_STATUS) || alert(i.getShaderInfoLog(e)), r = n.shader = i.createProgram(), i.attachShader(r, e), i.attachShader(r, f), i.linkProgram(r), i.getProgramParameter(r, i.LINK_STATUS) || alert("Could not initialise shaders"), i.enableVertexAttribArray(r.vertexPositionAttribute = i.getAttribLocation(r, "aVertexPosition")), i.enableVertexAttribArray(r.uvCoordAttribute = i.getAttribLocation(r, "aTextureCoord")), i.enableVertexAttribArray(r.colorAttribute = i.getAttribLocation(r, "aAlpha")), r.orthMatrixUniform = i.getUniformLocation(r, "uPMatrix"), r.alphaUniform = i.getUniformLocation(r, "uAlpha"), r.snapToUniform = i.getUniformLocation(r, "uSnapToPixel"), i.useProgram(r), this._vertexDataCount = 7, this._root2 = Math.sqrt(2), this._index = 0, this._textures = [], this._cacheTextures = [], this._degToRad = Math.PI / 180, this.vertices = window.Float32Array ? new window.Float32Array(2e4 * this._vertexDataCount) : new Array(2e4 * this._vertexDataCount), this.arrayBuffer = i.createBuffer(), this.indexBuffer = i.createBuffer(), i.bindBuffer(i.ARRAY_BUFFER, this.arrayBuffer), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this.indexBuffer), s = 4 * this._vertexDataCount, i.vertexAttribPointer(r.vertexPositionAttribute, 3, i.FLOAT, 0, s, 0), i.vertexAttribPointer(r.uvCoordAttribute, 3, i.FLOAT, 0, s, 12), i.vertexAttribPointer(r.colorAttribute, 1, i.FLOAT, 0, s, 24), this.indices = window.Uint16Array ? new window.Uint16Array(3e4) : new Array(3e4), o = 0, h = this.indices.length; h > o; o += 6) u = 4 * o / 6, this.indices.set([u, u + 1, u + 2, u, u + 2, u + 3], o); i.bufferData(i.ARRAY_BUFFER, this.vertices, i.STREAM_DRAW); i.bufferData(i.ELEMENT_ARRAY_BUFFER, this.indices, i.STATIC_DRAW); t.GLMatrix.mat4.ortho(0, i.viewportWidth, i.viewportHeight, 0, -this.MAX_DEPTH, this.MAX_DEPTH, n.orthMatrix); i.viewport(0, 0, i.viewportWidth, i.viewportHeight); i.colorMask(!0, !0, !0, !0); i.blendFuncSeparate(i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA, i.SRC_ALPHA, i.ONE); i.enable(i.BLEND); i.disable(i.DEPTH_TEST); n.init = !0 }, _initTexture: function (n, t) { if (n) { for (var u = this._textures, i = this._cacheTextures.length + this._textures.length, r = 0, f = u.length; f > r; r++) if (u[r].image == n) return n.glTexture = u[r], r; return n.glTexture ? (t.activeTexture(t["TEXTURE" + i]), t.bindTexture(t.TEXTURE_2D, n.glTexture)) : (n.glTexture = t.createTexture(), n.glTexture.image = n, t.activeTexture(t["TEXTURE" + i]), t.bindTexture(t.TEXTURE_2D, n.glTexture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, n.glTexture.image), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE)), t.uniform1i(t.getUniformLocation(t.canvas.shader, "uSampler" + i.toString()), i), u.push(n.glTexture), i } }, _initCache: function (n, t, i) { if (t) { for (var f = this._cacheTextures, r = this._textures.length, u = 0, e = f.length; e > u; u++) if (n.cacheID && f[u]._cacheID == n.cacheID) return f[u]._isUsed = !0, t.glTexture = f[u], i.activeTexture(i["TEXTURE" + r]), i.bindTexture(i.TEXTURE_2D, t.glTexture), this._textures.push(t.glTexture), u; return t.glTexture ? (i.activeTexture(i["TEXTURE" + r]), i.bindTexture(i.TEXTURE_2D, t.glTexture)) : (t.glTexture = i.createTexture(), t.glTexture.image = t, i.activeTexture(i["TEXTURE" + r]), i.bindTexture(i.TEXTURE_2D, t.glTexture), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, i.RGBA, i.UNSIGNED_BYTE, t.glTexture.image), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE)), i.uniform1i(i.getUniformLocation(i.canvas.shader, "uSampler" + r.toString()), r), t._cacheID = n.cacheID, t.glTexture._isUsed = !0, this._textures.push(t.glTexture), f.push(t.glTexture), r } }, render: function (n, i) { var r, u; n = n || this.root; i = i || this.surface; r = i.ctx; (this.snapToPixel ? r.uniform1i(i.shader.snapToUniform, 1) : r.uniform1i(i.shader.snapToUniform, 0), t.GLMatrix.mat4.identity(i.idMatrix), r.clear(r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT), r.uniformMatrix4fv(i.shader.orthMatrixUniform, !1, i.orthMatrix), i.init || this.initSurface(i), n && i) && (u = document.createDocumentFragment(), this._render(r, n, i.idMatrix, u), this._draw(r)); this._cleanCache() }, _getCompositeOperation: function (n) { return n.compositeOperation ? n.compositeOperation : n.parent ? this._getCompositeOperation(n.parent) : void 0 }, _render: function (n, i, r) { var f = t.GLMatrix.mat4, tt, a, b, v, it, o; if (i.isVisible()) { tt = (this._index + 4) * this._vertexDataCount; this.vertices.length < tt && this._draw(n); var c = 0, l = 0, p = 1, w = 1, s = 0, e = this._degToRad, u = this._getMat4(), h = 0, rt = this._getCompositeOperation(i); if ("lighter" === rt ? n.blendFunc(n.SRC_ALPHA, n.ONE) : n.blendFunc(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA), a = i.cacheCanvas || i.txtCanvas, a) h = this._initCache(i, a, n), f.translate(r, [i.x, i.y, 0], u), f.rotateX(u, i.skewX * e), f.rotateY(u, i.skewY * e), f.rotateZ(u, i.rotation * e), f.scale(u, [i.scaleX * a.width, i.scaleY * a.height, 1]), f.translate(u, [-i.originX, -i.originY, 0]); else { if (i instanceof t.Container) { for (b = i.children.slice(0), f.translate(r, [i.x, i.y, 0], u), f.rotateX(u, i.skewX * e), f.rotateY(u, i.skewY * e), f.rotateZ(u, i.rotation * e), f.scale(u, [i.scaleX, i.scaleY, 1]), f.translate(u, [-i.originX, -i.originY, 0]), v = 0, it = b.length; it > v; v++) this._render(n, b[v], u); return void this._poolMat4(u) } (i instanceof t.Bitmap || i instanceof t.Sprite) && (o = i.rect, s = i.img, h = this._initTexture(s, n), p = o[2] / s.width, w = o[3] / s.height, c = o[0] / s.width, l = o[1] / s.height, f.translate(r, [i.x, i.y, 0], u), f.rotateX(u, i.skewX * e), f.rotateY(u, i.skewY * e), f.rotateZ(u, i.rotation * e), f.scale(u, [i.scaleX * o[2], i.scaleY * o[3], 1]), f.translate(u, [-i.originX, -i.originY, 0])) } var k = f.multiplyVec3(u, [0, 0, 0]), d = f.multiplyVec3(u, [0, 1, 0]), g = f.multiplyVec3(u, [1, 1, 0]), nt = f.multiplyVec3(u, [1, 0, 0]), y = i.alpha; this.vertices.set([k[0], k[1], k[2], c, l, h, y, d[0], d[1], d[2], c, l + w, h, y, g[0], g[1], g[2], c + p, l + w, h, y, nt[0], nt[1], nt[2], c + p, l, h, y], this._index * this._vertexDataCount); this._index += 4; this._poolMat4(u); this._textures.length + this._cacheTextures.length > 31 && this._draw(n) } }, _draw: function (n) { n.bufferSubData(n.ARRAY_BUFFER, 0, this.vertices.subarray(0, this._index * this._vertexDataCount)); n.drawElements(n.TRIANGLES, 1.5 * this._index, n.UNSIGNED_SHORT, 0); this._index = 0; this._textureCount = 0; this._textures = [] }, _cleanCache: function () { for (var t = this._cacheTextures, n = 0, i = t.length; i > n; n++) t[n]._isUsed ? t[n]._isUsed = !1 : (t.splice(n, 1), n--, i--) }, _getMat4: function () { return this._matPool.length > 0 ? this._matPool.pop() : t.GLMatrix.mat4.create() }, _poolMat4: function (n) { this._matPool.push(n) }, update: function () { this.clear(); this.tickOnUpdate && this.tickDisplayList(this.root, this.arguments); this.render(this.root, this.surface) }, updateCache: function (n, t, i, r) { n.clearRect(0, 0, i + 1, r + 1); this.renderCache(n, t) }, renderCache: function (n, i) { var u, r, o, f; if (i.isVisible()) if (i instanceof t.Container || i instanceof t.Stage) for (var e = i.children.slice(0), r = 0, s = e.length; s > r; r++) n.save(), this.canvasRenderer.render(n, e[r]), n.restore(); else if (i instanceof t.Bitmap || i instanceof t.Sprite) u = i.rect, n.drawImage(i.img, u[0], u[1], u[2], u[3], 0, 0, u[2], u[3]); else if (i instanceof t.Shape) for (r = 0, o = i.cmds.length; o > r; r++) f = i.cmds[r], i.assMethod.join("-").match(new RegExp("\\b" + f[0] + "\\b", "g")) ? n[f[0]] = f[1][0] : n[f[0]].apply(n, Array.prototype.slice.call(f[1])) } }); t.Keyboard = n.extend({ statics: { ctor: function () { function d() { window.addEventListener ? (window.document.addEventListener("keydown", c, !1), window.document.addEventListener("keyup", l, !1), window.addEventListener("blur", u, !1), window.addEventListener("webkitfullscreenchange", u, !1), window.addEventListener("mozfullscreenchange", u, !1)) : window.attachEvent && (window.document.attachEvent("onkeydown", c), window.document.attachEvent("onkeyup", l), window.attachEvent("onblur", u)) } function st() { u(); window.removeEventListener ? (window.document.removeEventListener("keydown", c, !1), window.document.removeEventListener("keyup", l, !1), window.removeEventListener("blur", u, !1), window.removeEventListener("webkitfullscreenchange", u, !1), window.removeEventListener("mozfullscreenchange", u, !1)) : window.detachEvent && (window.document.detachEvent("onkeydown", c), window.document.detachEvent("onkeyup", l), window.detachEvent("onblur", u)) } function u(n) { r = []; nt(); tt(n) } function c(n) { var t, r, i; if (t = b(n.keyCode), !(t.length < 1)) { for (n.isRepeat = !1, i = 0; i < t.length; i += 1) r = t[i], -1 != a().indexOf(r) && (n.isRepeat = !0), k(r); lt(); pt(n) } } function l(n) { var t, i; if (t = b(n.keyCode), !(t.length < 1)) { for (i = 0; i < t.length; i += 1) v(t[i]); nt(); tt(n) } } function b(n) { return h[n] || [] } function g(n) { for (var t in h) if (h.hasOwnProperty(t) && h[t].indexOf(n) > -1) return t; return !1 } function ht(n, t) { if ("string" != typeof n && ("object" != typeof n || "function" != typeof n.push)) throw new Error("Cannot create macro. The combo must be a string or array."); if ("object" != typeof t || "function" != typeof t.push) throw new Error("Cannot create macro. The injectedKeys must be an array."); i.push([n, t]) } function ct(n) { var r, t; if ("string" != typeof n && ("object" != typeof n || "function" != typeof n.push)) throw new Error("Cannot remove macro. The combo must be a string or array."); for (t = 0; t < i.length; t += 1) if (r = i[t], it(n, r[0])) { v(r[1]); i.splice(t, 1); break } } function lt() { for (var r, t, n = 0; n < i.length; n += 1) if (r = f(i[n][0]), -1 === o.indexOf(i[n]) && s(r)) for (o.push(i[n]), t = 0; t < i[n][1].length; t += 1) k(i[n][1][t]) } function nt() { for (var i, t, n = 0; n < o.length; n += 1) if (i = f(o[n][0]), s(i) === !1) { for (t = 0; t < o[n][1].length; t += 1) v(o[n][1][t]); o.splice(n, 1); n -= 1 } } function at(n, i, r) { function c() { for (var n = 0; n < u.length; n += 1) t.splice(t.indexOf(u[n]), 1) } function l(n) { function e() { for (var i, r = 0; r < t.length; r += 1) if ("function" == typeof t[r]) if ("keyup" === n) for (i = 0; i < u.length; i += 1) u[i].keyUpCallback.splice(u[i].keyUpCallback.indexOf(t[r]), 1); else for (i = 0; i < u.length; i += 1) u[i].keyDownCallback.splice(u[i].keyDownCallback.indexOf(t[r]), 1) } var t, r, i, f = {}; if ("string" != typeof n) throw new Error("Cannot bind callback. The event name must be a string."); if ("keyup" !== n && "keydown" !== n) throw new Error('Cannot bind callback. The event name must be a "keyup" or "keydown".'); for (t = Array.prototype.slice.apply(arguments, [1]), r = 0; r < t.length; r += 1) if ("function" == typeof t[r]) if ("keyup" === n) for (i = 0; i < u.length; i += 1) u[i].keyUpCallback.push(t[r]); else if ("keydown" === n) for (i = 0; i < u.length; i += 1) u[i].keyDownCallback.push(t[r]); return f.clear = e, f } var e, o, s, h = {}, u = []; for ("string" == typeof n && (n = f(n)), o = 0; o < n.length; o += 1) { if (e = {}, s = ut([n[o]]), "string" != typeof s) throw new Error("Failed to bind key combo. The key combo must be string."); e.keyCombo = s; e.keyDownCallback = []; e.keyUpCallback = []; i && e.keyDownCallback.push(i); r && e.keyUpCallback.push(r); t.push(e); u.push(e) } return h.clear = c, h.on = l, h } function vt(n) { for (var r, i = 0; i < t.length; i += 1) r = t[i], it(n, r.keyCombo) && (t.splice(i, 1), i -= 1) } function yt(n) { var i, r, u; if (n) { for (i = 0; i < t.length; i += 1) for (u = t[i], r = 0; r < u.keyCombo.length; r += 1) if (u.keyCombo[r].indexOf(n) > -1) { t.splice(i, 1); i -= 1; break } } else t = [] } function pt(n) { for (var o, f, h, l, b, u, y, p, v, e = [], c = [].concat(r), i = 0; i < t.length; i += 1) v = rt(t[i].keyCombo).length, e[v] || (e[v] = []), e[v].push(t[i]); for (o = e.length - 1; o >= 0; o -= 1) if (e[o]) for (i = 0; i < e[o].length; i += 1) { for (f = e[o][i], h = rt(f.keyCombo), y = !0, u = 0; u < h.length; u += 1) if (-1 === c.indexOf(h[u])) { y = !1; break } if (y && s(f.keyCombo)) { for (w.push(f), u = 0; u < h.length; u += 1) p = c.indexOf(h[u]), p > -1 && (c.splice(p, 1), u -= 1); for (l = 0; l < f.keyDownCallback.length; l += 1) f.keyDownCallback[l](n, a(), f.keyCombo) === !1 && (b = !0); b === !0 && (n.preventDefault(), n.stopPropagation()) } } } function tt(n) { for (var r, i, u, t = 0; t < w.length; t += 1) if (i = w[t], s(i.keyCombo) === !1) { for (r = 0; r < i.keyUpCallback.length; r += 1) i.keyUpCallback[r](n, a(), i.keyCombo) === !1 && (u = !0); u === !0 && (n.preventDefault(), n.stopPropagation()); w.splice(t, 1); t -= 1 } } function it(n, t) { var i, r, u; if (n = f(n), t = f(t), n.length !== t.length) return !1; for (i = 0; i < n.length; i += 1) { if (n[i].length !== t[i].length) return !1; for (r = 0; r < n[i].length; r += 1) { if (n[i][r].length !== t[i][r].length) return !1; for (u = 0; u < n[i][r].length; u += 1) if (-1 === t[i][r].indexOf(n[i][r][u])) return !1 } } return !0 } function s(n) { var t, u, e, i, o, s, h = 0; for (n = f(n), t = 0; t < n.length; t += 1) { for (s = !0, h = 0, u = 0; u < n[t].length; u += 1) { for (e = [].concat(n[t][u]), i = h; i < r.length; i += 1) o = e.indexOf(r[i]), o > -1 && (e.splice(o, 1), h = i); if (0 !== e.length) { s = !1; break } } if (s) return !0 } return !1 } function rt(n) { var t, i, r = []; for (n = f(n), t = 0; t < n.length; t += 1) for (i = 0; i < n[t].length; i += 1) r = r.concat(n[t][i]); return r } function f(n) { var i = n, t = 0, e = 0, s = !1, o = !1, h = [], f = [], u = [], r = ""; if ("object" == typeof n && "function" == typeof n.push) return n; if ("string" != typeof n) throw new Error('Cannot parse "keyCombo" because its type is "' + typeof n + '". It must be a "string".'); for (; " " === i.charAt(t) ;) t += 1; for (; ;) { if (" " === i.charAt(t)) { for (; " " === i.charAt(t) ;) t += 1; s = !0 } else if ("," === i.charAt(t)) { if (e || o) throw new Error("Failed to parse key combo. Unexpected , at character index " + t + "."); o = !0; t += 1 } else if ("+" === i.charAt(t)) { if (r.length && (u.push(r), r = ""), e || o) throw new Error("Failed to parse key combo. Unexpected + at character index " + t + "."); e = !0; t += 1 } else if (">" === i.charAt(t)) { if (r.length && (u.push(r), r = ""), u.length && (f.push(u), u = []), e || o) throw new Error("Failed to parse key combo. Unexpected > at character index " + t + "."); e = !0; t += 1 } else if (t < i.length - 1 && "!" === i.charAt(t) && (">" === i.charAt(t + 1) || "," === i.charAt(t + 1) || "+" === i.charAt(t + 1))) r += i.charAt(t + 1), e = !1, s = !1, o = !1, t += 2; else { if (!(t < i.length && "+" !== i.charAt(t) && ">" !== i.charAt(t) && "," !== i.charAt(t) && " " !== i.charAt(t))) { t += 1; continue } for ((e === !1 && s === !0 || o === !0) && (r.length && (u.push(r), r = ""), u.length && (f.push(u), u = []), f.length && (h.push(f), f = [])), e = !1, s = !1, o = !1; t < i.length && "+" !== i.charAt(t) && ">" !== i.charAt(t) && "," !== i.charAt(t) && " " !== i.charAt(t) ;) r += i.charAt(t), t += 1 } if (t >= i.length) { r.length && (u.push(r), r = ""); u.length && (f.push(u), u = []); f.length && (h.push(f), f = []); break } } return h } function ut(n) { var t, i, r = []; if ("string" == typeof n) return n; if ("object" != typeof n || "function" != typeof n.push) throw new Error("Cannot stringify key combo."); for (t = 0; t < n.length; t += 1) { for (r[t] = [], i = 0; i < n[t].length; i += 1) r[t][i] = n[t][i].join(" + "); r[t] = r[t].join(" > ") } return r.join(" ") } function a() { return [].concat(r) } function k(n) { if (n.match(/\s/)) throw new Error("Cannot add key name " + n + " to active keys because it contains whitespace."); r.indexOf(n) > -1 || r.push(n) } function v(n) { var t = g(n); "91" === t || "92" === t ? r = [] : r.splice(r.indexOf(n), 1) } function ft(n, t) { if ("string" != typeof n) throw new Error("Cannot register new locale. The locale name must be a string."); if ("object" != typeof t) throw new Error("Cannot register " + n + " locale. The locale map must be an object."); if ("object" != typeof t.map) throw new Error("Cannot register " + n + " locale. The locale map is invalid."); t.macros || (t.macros = []); p[n] = t } function et(n) { if (n) { if ("string" != typeof n) throw new Error("Cannot set locale. The locale name must be a string."); if (!p[n]) throw new Error("Cannot set locale to " + n + " because it does not exist. If you would like to submit a " + n + " locale map for KeyboardJS please submit it at https://github.com/RobertWHurst/KeyboardJS/issues."); h = p[n].map; i = p[n].macros; ot = n } return ot } for (var ot, h, i, n = {}, p = {}, r = [], t = [], w = [], o = [], y = { map: { 3: ["cancel"], 8: ["backspace"], 9: ["tab"], 12: ["clear"], 13: ["enter"], 16: ["shift"], 17: ["ctrl"], 18: ["alt", "menu"], 19: ["pause", "break"], 20: ["capslock"], 27: ["escape", "esc"], 32: ["space", "spacebar"], 33: ["pageup"], 34: ["pagedown"], 35: ["end"], 36: ["home"], 37: ["left"], 38: ["up"], 39: ["right"], 40: ["down"], 41: ["select"], 42: ["printscreen"], 43: ["execute"], 44: ["snapshot"], 45: ["insert", "ins"], 46: ["delete", "del"], 47: ["help"], 91: ["command", "windows", "win", "super", "leftcommand", "leftwindows", "leftwin", "leftsuper"], 92: ["command", "windows", "win", "super", "rightcommand", "rightwindows", "rightwin", "rightsuper"], 145: ["scrolllock", "scroll"], 186: ["semicolon", ";"], 187: ["equal", "equalsign", "="], 188: ["comma", ","], 189: ["dash", "-"], 190: ["period", "."], 191: ["slash", "forwardslash", "/"], 192: ["graveaccent", "`"], 219: ["openbracket", "["], 220: ["backslash", "\\"], 221: ["closebracket", "]"], 222: ["apostrophe", "'"], 48: ["zero", "0"], 49: ["one", "1"], 50: ["two", "2"], 51: ["three", "3"], 52: ["four", "4"], 53: ["five", "5"], 54: ["six", "6"], 55: ["seven", "7"], 56: ["eight", "8"], 57: ["nine", "9"], 96: ["numzero", "num0"], 97: ["numone", "num1"], 98: ["numtwo", "num2"], 99: ["numthree", "num3"], 100: ["numfour", "num4"], 101: ["numfive", "num5"], 102: ["numsix", "num6"], 103: ["numseven", "num7"], 104: ["numeight", "num8"], 105: ["numnine", "num9"], 106: ["nummultiply", "num*"], 107: ["numadd", "num+"], 108: ["numenter"], 109: ["numsubtract", "num-"], 110: ["numdecimal", "num."], 111: ["numdivide", "num/"], 144: ["numlock", "num"], 112: ["f1"], 113: ["f2"], 114: ["f3"], 115: ["f4"], 116: ["f5"], 117: ["f6"], 118: ["f7"], 119: ["f8"], 120: ["f9"], 121: ["f10"], 122: ["f11"], 123: ["f12"] }, macros: [["shift + `", ["tilde", "~"]], ["shift + 1", ["exclamation", "exclamationpoint", "!"]], ["shift + 2", ["at", "@"]], ["shift + 3", ["number", "#"]], ["shift + 4", ["dollar", "dollars", "dollarsign", "$"]], ["shift + 5", ["percent", "%"]], ["shift + 6", ["caret", "^"]], ["shift + 7", ["ampersand", "and", "&"]], ["shift + 8", ["asterisk", "*"]], ["shift + 9", ["openparen", "("]], ["shift + 0", ["closeparen", ")"]], ["shift + -", ["underscore", "_"]], ["shift + =", ["plus", "+"]], ["shift + (", ["opencurlybrace", "opencurlybracket", "{"]], ["shift + )", ["closecurlybrace", "closecurlybracket", "}"]], ["shift + \\", ["verticalbar", "|"]], ["shift + ;", ["colon", ":"]], ["shift + '", ["quotationmark", '"']], ["shift + !,", ["openanglebracket", "<"]], ["shift + .", ["closeanglebracket", ">"]], ["shift + /", ["questionmark", "?"]]] }, e = 65; 90 >= e; e += 1) y.map[e] = String.fromCharCode(e + 32), y.macros.push(["shift + " + String.fromCharCode(e + 32) + ", capslock + " + String.fromCharCode(e + 32), [String.fromCharCode(e)]]); ft("us", y); et("us"); d(); n.enable = d; n.disable = st; n.activeKeys = a; n.releaseKey = v; n.pressKey = k; n.on = at; n.clear = vt; n.clear.key = yt; n.locale = et; n.locale.register = ft; n.macro = ht; n.macro.remove = ct; n.key = {}; n.key.name = b; n.key.code = g; n.combo = {}; n.combo.active = s; n.combo.parse = f; n.combo.stringify = ut; this.Keyboard = n }, on: function (n, t, i) { this.Keyboard.on(n, t, i) }, getActiveKeys: function () { return this.Keyboard.activeKeys() } } }); t.Sprite = t.DisplayObject.extend({ ctor: function (n) { this._super(); this.option = n; this.x = n.x || 0; this.y = n.y || 0; this.currentFrameIndex = 0; this.animationFrameIndex = 0; this.currentAnimation = n.currentAnimation || null; this.rect = [0, 0, 10, 10]; this.img = this.option.imgs[0]; this.interval = 1e3 / n.framerate; this.loop = null; this.paused = !1; this.animationEnd = n.animationEnd || null; this.currentAnimation && this.gotoAndPlay(this.currentAnimation); this.tickAnimationEnd = n.tickAnimationEnd || null }, play: function () { this.paused = !1 }, stop: function () { this.paused = !0 }, reset: function () { this.currentFrameIndex = 0; this.animationFrameIndex = 0 }, gotoAndPlay: function (n, i) { this.paused = !1; this.reset(); t.RAF.clearRequestInterval(this.loop); this.currentAnimation = n; var r = this, u = 0; this.loop = t.RAF.requestInterval(function () { if (!r.paused) { var n = r.option, f = n.animations[r.currentAnimation].frames, e = f.length; r.animationFrameIndex++; r.animationFrameIndex > e - 1 && (u++, r.animationFrameIndex = 0, r.tickAnimationEnd && r.tickAnimationEnd(), i && u == i && (r.animationEnd && r.animationEnd(), r.paused = !0, t.RAF.clearRequestInterval(r.loop), r.parent.remove(r))); r.rect = n.frames[f[r.animationFrameIndex]]; r.rect.length > 4 && (r.img = n.imgs[r.rect[4]]) } }, this.interval) }, gotoAndStop: function (n) { var i, r, u; this.reset(); t.RAF.clearRequestInterval(this.loop); i = this; i.currentAnimation = n; r = i.option; u = r.animations[i.currentAnimation].frames; u.length; i.rect = r.frames[u[i.animationFrameIndex]]; i.rect.length > 4 && (i.img = r.imgs[i.rect[4]]) } }); t.Shape = t.DisplayObject.extend({ ctor: function () { this._super(); this.cmds = []; this.assMethod = ["fillStyle", "strokeStyle", "lineWidth"] }, setBound: function (n, t) { this.width = n; this.height = t }, draw: function (n) { for (var t, i = 0, r = this.cmds.length; r > i; i++) t = this.cmds[i], this.assMethod.join("-").match(new RegExp("\\b" + t[0] + "\\b", "g")) ? n[t[0]] = t[1][0] : n[t[0]].apply(n, Array.prototype.slice.call(t[1])) }, strokeRect: function () { return this.cmds.push(["strokeRect", arguments]), this }, fillRect: function () { return this.cmds.push(["fillRect", arguments]), this }, beginPath: function () { return this.cmds.push(["beginPath", arguments]), this }, arc: function () { return this.cmds.push(["arc", arguments]), this }, closePath: function () { return this.cmds.push(["closePath", arguments]), this }, fillStyle: function () { return this.cmds.push(["fillStyle", arguments]), this }, fill: function () { return this.cmds.push(["fill", arguments]), this }, strokeStyle: function () { return this.cmds.push(["strokeStyle", arguments]), this }, lineWidth: function () { return this.cmds.push(["lineWidth", arguments]), this }, stroke: function () { return this.cmds.push(["stroke", arguments]), this }, moveTo: function () { return this.cmds.push(["moveTo", arguments]), this }, lineTo: function () { return this.cmds.push(["lineTo", arguments]), this }, bezierCurveTo: function () { return this.cmds.push(["bezierCurveTo", arguments]), this }, clone: function () { } }); t.GLMatrix = n.extend({ statics: { ctor: function () { var u = "undefined" != typeof Float32Array ? window.Float32Array : "undefined" != typeof WebGLFloatArray ? window.WebGLFloatArray : Array, t = {}, r, n, i; t.create = function (n) { var t = new u(3); return n && (t[0] = n[0], t[1] = n[1], t[2] = n[2]), t }; t.set = function (n, t) { return t[0] = n[0], t[1] = n[1], t[2] = n[2], t }; t.add = function (n, t, i) { return i && n != i ? (i[0] = n[0] + t[0], i[1] = n[1] + t[1], i[2] = n[2] + t[2], i) : (n[0] += t[0], n[1] += t[1], n[2] += t[2], n) }; t.subtract = function (n, t, i) { return i && n != i ? (i[0] = n[0] - t[0], i[1] = n[1] - t[1], i[2] = n[2] - t[2], i) : (n[0] -= t[0], n[1] -= t[1], n[2] -= t[2], n) }; t.negate = function (n, t) { return t || (t = n), t[0] = -n[0], t[1] = -n[1], t[2] = -n[2], t }; t.scale = function (n, t, i) { return i && n != i ? (i[0] = n[0] * t, i[1] = n[1] * t, i[2] = n[2] * t, i) : (n[0] *= t, n[1] *= t, n[2] *= t, n) }; t.normalize = function (n, t) { t || (t = n); var r = n[0], u = n[1], f = n[2], i = Math.sqrt(r * r + u * u + f * f); return i ? 1 == i ? (t[0] = r, t[1] = u, t[2] = f, t) : (i = 1 / i, t[0] = r * i, t[1] = u * i, t[2] = f * i, t) : (t[0] = 0, t[1] = 0, t[2] = 0, t) }; t.cross = function (n, t, i) { var r, u, f, e; return i || (i = n), r = n[0], u = n[1], n = n[2], f = t[0], e = t[1], t = t[2], i[0] = u * t - n * e, i[1] = n * f - r * t, i[2] = r * e - u * f, i }; t.length = function (n) { var t = n[0], i = n[1]; return n = n[2], Math.sqrt(t * t + i * i + n * n) }; t.dot = function (n, t) { return n[0] * t[0] + n[1] * t[1] + n[2] * t[2] }; t.direction = function (n, t, i) { i || (i = n); var r = n[0] - t[0], u = n[1] - t[1]; return n = n[2] - t[2], (t = Math.sqrt(r * r + u * u + n * n)) ? (t = 1 / t, i[0] = r * t, i[1] = u * t, i[2] = n * t, i) : (i[0] = 0, i[1] = 0, i[2] = 0, i) }; t.lerp = function (n, t, i, r) { return r || (r = n), r[0] = n[0] + i * (t[0] - n[0]), r[1] = n[1] + i * (t[1] - n[1]), r[2] = n[2] + i * (t[2] - n[2]), r }; t.str = function (n) { return "[" + n[0] + ", " + n[1] + ", " + n[2] + "]" }; r = {}; r.create = function (n) { var t = new u(9); return n && (t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9]), t }; r.set = function (n, t) { return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t }; r.identity = function (n) { return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 1, n[5] = 0, n[6] = 0, n[7] = 0, n[8] = 1, n }; r.transpose = function (n, t) { if (!t || n == t) { var i = n[1], r = n[2], u = n[5]; return n[1] = n[3], n[2] = n[6], n[3] = i, n[5] = n[7], n[6] = r, n[7] = u, n } return t[0] = n[0], t[1] = n[3], t[2] = n[6], t[3] = n[1], t[4] = n[4], t[5] = n[7], t[6] = n[2], t[7] = n[5], t[8] = n[8], t }; r.toMat4 = function (t, i) { return i || (i = n.create()), i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = 0, i[4] = t[3], i[5] = t[4], i[6] = t[5], i[7] = 0, i[8] = t[6], i[9] = t[7], i[10] = t[8], i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i }; r.str = function (n) { return "[" + n[0] + ", " + n[1] + ", " + n[2] + ", " + n[3] + ", " + n[4] + ", " + n[5] + ", " + n[6] + ", " + n[7] + ", " + n[8] + "]" }; n = {}; n.create = function (n) { var t = new u(16); return n && (t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15]), t }; n.set = function (n, t) { return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], t }; n.identity = function (n) { return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n }; n.transpose = function (n, t) { if (!t || n == t) { var i = n[1], r = n[2], u = n[3], f = n[6], e = n[7], o = n[11]; return n[1] = n[4], n[2] = n[8], n[3] = n[12], n[4] = i, n[6] = n[9], n[7] = n[13], n[8] = r, n[9] = f, n[11] = n[14], n[12] = u, n[13] = e, n[14] = o, n } return t[0] = n[0], t[1] = n[4], t[2] = n[8], t[3] = n[12], t[4] = n[1], t[5] = n[5], t[6] = n[9], t[7] = n[13], t[8] = n[2], t[9] = n[6], t[10] = n[10], t[11] = n[14], t[12] = n[3], t[13] = n[7], t[14] = n[11], t[15] = n[15], t }; n.determinant = function (n) { var t = n[0], i = n[1], r = n[2], u = n[3], f = n[4], e = n[5], o = n[6], s = n[7], h = n[8], c = n[9], l = n[10], a = n[11], v = n[12], y = n[13], p = n[14]; return n = n[15], v * c * o * u - h * y * o * u - v * e * l * u + f * y * l * u + h * e * p * u - f * c * p * u - v * c * r * s + h * y * r * s + v * i * l * s - t * y * l * s - h * i * p * s + t * c * p * s + v * e * r * a - f * y * r * a - v * i * o * a + t * y * o * a + f * i * p * a - t * e * p * a - h * e * r * n + f * c * r * n + h * i * o * n - t * c * o * n - f * i * l * n + t * e * l * n }; n.inverse = function (n, t) { t || (t = n); var r = n[0], u = n[1], f = n[2], e = n[3], o = n[4], s = n[5], h = n[6], c = n[7], l = n[8], a = n[9], v = n[10], y = n[11], p = n[12], w = n[13], b = n[14], k = n[15], d = r * s - u * o, g = r * h - f * o, nt = r * c - e * o, tt = u * h - f * s, it = u * c - e * s, rt = f * c - e * h, ut = l * w - a * p, ft = l * b - v * p, et = l * k - y * p, ot = a * b - v * w, st = a * k - y * w, ht = v * k - y * b, i = 1 / (d * ht - g * st + nt * ot + tt * et - it * ft + rt * ut); return t[0] = (s * ht - h * st + c * ot) * i, t[1] = (-u * ht + f * st - e * ot) * i, t[2] = (w * rt - b * it + k * tt) * i, t[3] = (-a * rt + v * it - y * tt) * i, t[4] = (-o * ht + h * et - c * ft) * i, t[5] = (r * ht - f * et + e * ft) * i, t[6] = (-p * rt + b * nt - k * g) * i, t[7] = (l * rt - v * nt + y * g) * i, t[8] = (o * st - s * et + c * ut) * i, t[9] = (-r * st + u * et - e * ut) * i, t[10] = (p * it - w * nt + k * d) * i, t[11] = (-l * it + a * nt - y * d) * i, t[12] = (-o * ot + s * ft - h * ut) * i, t[13] = (r * ot - u * ft + f * ut) * i, t[14] = (-p * tt + w * g - b * d) * i, t[15] = (l * tt - a * g + v * d) * i, t }; n.toRotationMat = function (t, i) { return i || (i = n.create()), i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i }; n.toMat3 = function (n, t) { return t || (t = r.create()), t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[4], t[4] = n[5], t[5] = n[6], t[6] = n[8], t[7] = n[9], t[8] = n[10], t }; n.toInverseMat3 = function (n, t) { var u = n[0], f = n[1], e = n[2], o = n[4], s = n[5], h = n[6], c = n[8], l = n[9], a = n[10], v = a * s - h * l, y = -a * o + h * c, p = l * o - s * c, i = u * v + f * y + e * p; return i ? (i = 1 / i, t || (t = r.create()), t[0] = v * i, t[1] = (-a * f + e * l) * i, t[2] = (h * f - e * s) * i, t[3] = y * i, t[4] = (a * u - e * c) * i, t[5] = (-h * u + e * o) * i, t[6] = p * i, t[7] = (-l * u + f * c) * i, t[8] = (s * u - f * o) * i, t) : null }; n.multiply = function (n, t, i) { i || (i = n); var r = n[0], u = n[1], f = n[2], e = n[3], o = n[4], s = n[5], h = n[6], c = n[7], l = n[8], a = n[9], v = n[10], y = n[11], p = n[12], w = n[13], b = n[14]; n = n[15]; var k = t[0], d = t[1], g = t[2], nt = t[3], tt = t[4], it = t[5], rt = t[6], ut = t[7], ft = t[8], et = t[9], ot = t[10], st = t[11], ht = t[12], ct = t[13], lt = t[14]; return t = t[15], i[0] = k * r + d * o + g * l + nt * p, i[1] = k * u + d * s + g * a + nt * w, i[2] = k * f + d * h + g * v + nt * b, i[3] = k * e + d * c + g * y + nt * n, i[4] = tt * r + it * o + rt * l + ut * p, i[5] = tt * u + it * s + rt * a + ut * w, i[6] = tt * f + it * h + rt * v + ut * b, i[7] = tt * e + it * c + rt * y + ut * n, i[8] = ft * r + et * o + ot * l + st * p, i[9] = ft * u + et * s + ot * a + st * w, i[10] = ft * f + et * h + ot * v + st * b, i[11] = ft * e + et * c + ot * y + st * n, i[12] = ht * r + ct * o + lt * l + t * p, i[13] = ht * u + ct * s + lt * a + t * w, i[14] = ht * f + ct * h + lt * v + t * b, i[15] = ht * e + ct * c + lt * y + t * n, i }; n.multiplyVec3 = function (n, t, i) { i || (i = t); var r = t[0], u = t[1]; return t = t[2], i[0] = n[0] * r + n[4] * u + n[8] * t + n[12], i[1] = n[1] * r + n[5] * u + n[9] * t + n[13], i[2] = n[2] * r + n[6] * u + n[10] * t + n[14], i }; n.multiplyVec4 = function (n, t, i) { i || (i = t); var r = t[0], u = t[1], f = t[2]; return t = t[3], i[0] = n[0] * r + n[4] * u + n[8] * f + n[12] * t, i[1] = n[1] * r + n[5] * u + n[9] * f + n[13] * t, i[2] = n[2] * r + n[6] * u + n[10] * f + n[14] * t, i[3] = n[3] * r + n[7] * u + n[11] * f + n[15] * t, i }; n.translate = function (n, t, i) { var r = t[0], u = t[1]; if (t = t[2], !i || n == i) return n[12] = n[0] * r + n[4] * u + n[8] * t + n[12], n[13] = n[1] * r + n[5] * u + n[9] * t + n[13], n[14] = n[2] * r + n[6] * u + n[10] * t + n[14], n[15] = n[3] * r + n[7] * u + n[11] * t + n[15], n; var f = n[0], e = n[1], o = n[2], s = n[3], h = n[4], c = n[5], l = n[6], a = n[7], v = n[8], y = n[9], p = n[10], w = n[11]; return i[0] = f, i[1] = e, i[2] = o, i[3] = s, i[4] = h, i[5] = c, i[6] = l, i[7] = a, i[8] = v, i[9] = y, i[10] = p, i[11] = w, i[12] = f * r + h * u + v * t + n[12], i[13] = e * r + c * u + y * t + n[13], i[14] = o * r + l * u + p * t + n[14], i[15] = s * r + a * u + w * t + n[15], i }; n.scale = function (n, t, i) { var r = t[0], u = t[1]; return t = t[2], i && n != i ? (i[0] = n[0] * r, i[1] = n[1] * r, i[2] = n[2] * r, i[3] = n[3] * r, i[4] = n[4] * u, i[5] = n[5] * u, i[6] = n[6] * u, i[7] = n[7] * u, i[8] = n[8] * t, i[9] = n[9] * t, i[10] = n[10] * t, i[11] = n[11] * t, i[12] = n[12], i[13] = n[13], i[14] = n[14], i[15] = n[15], i) : (n[0] *= r, n[1] *= r, n[2] *= r, n[3] *= r, n[4] *= u, n[5] *= u, n[6] *= u, n[7] *= u, n[8] *= t, n[9] *= t, n[10] *= t, n[11] *= t, n) }; n.rotate = function (n, t, i, r) { var u = i[0], f = i[1], e; if (i = i[2], e = Math.sqrt(u * u + f * f + i * i), !e) return null; 1 != e && (e = 1 / e, u *= e, f *= e, i *= e); var s = Math.sin(t), h = Math.cos(t), o = 1 - h; t = n[0]; e = n[1]; var b = n[2], k = n[3], d = n[4], g = n[5], nt = n[6], tt = n[7], it = n[8], rt = n[9], ut = n[10], ft = n[11], c = u * u * o + h, l = f * u * o + i * s, a = i * u * o - f * s, v = u * f * o - i * s, y = f * f * o + h, p = i * f * o + u * s, w = u * i * o + f * s; return u = f * i * o - u * s, f = i * i * o + h, r ? n != r && (r[12] = n[12], r[13] = n[13], r[14] = n[14], r[15] = n[15]) : r = n, r[0] = t * c + d * l + it * a, r[1] = e * c + g * l + rt * a, r[2] = b * c + nt * l + ut * a, r[3] = k * c + tt * l + ft * a, r[4] = t * v + d * y + it * p, r[5] = e * v + g * y + rt * p, r[6] = b * v + nt * y + ut * p, r[7] = k * v + tt * y + ft * p, r[8] = t * w + d * u + it * f, r[9] = e * w + g * u + rt * f, r[10] = b * w + nt * u + ut * f, r[11] = k * w + tt * u + ft * f, r }; n.rotateX = function (n, t, i) { var r = Math.sin(t); t = Math.cos(t); var u = n[4], f = n[5], e = n[6], o = n[7], s = n[8], h = n[9], c = n[10], l = n[11]; return i ? n != i && (i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], i[12] = n[12], i[13] = n[13], i[14] = n[14], i[15] = n[15]) : i = n, i[4] = u * t + s * r, i[5] = f * t + h * r, i[6] = e * t + c * r, i[7] = o * t + l * r, i[8] = u * -r + s * t, i[9] = f * -r + h * t, i[10] = e * -r + c * t, i[11] = o * -r + l * t, i }; n.rotateY = function (n, t, i) { var r = Math.sin(t); t = Math.cos(t); var u = n[0], f = n[1], e = n[2], o = n[3], s = n[8], h = n[9], c = n[10], l = n[11]; return i ? n != i && (i[4] = n[4], i[5] = n[5], i[6] = n[6], i[7] = n[7], i[12] = n[12], i[13] = n[13], i[14] = n[14], i[15] = n[15]) : i = n, i[0] = u * t + s * -r, i[1] = f * t + h * -r, i[2] = e * t + c * -r, i[3] = o * t + l * -r, i[8] = u * r + s * t, i[9] = f * r + h * t, i[10] = e * r + c * t, i[11] = o * r + l * t, i }; n.rotateZ = function (n, t, i) { var r = Math.sin(t); t = Math.cos(t); var u = n[0], f = n[1], e = n[2], o = n[3], s = n[4], h = n[5], c = n[6], l = n[7]; return i ? n != i && (i[8] = n[8], i[9] = n[9], i[10] = n[10], i[11] = n[11], i[12] = n[12], i[13] = n[13], i[14] = n[14], i[15] = n[15]) : i = n, i[0] = u * t + s * r, i[1] = f * t + h * r, i[2] = e * t + c * r, i[3] = o * t + l * r, i[4] = u * -r + s * t, i[5] = f * -r + h * t, i[6] = e * -r + c * t, i[7] = o * -r + l * t, i }; n.frustum = function (t, i, r, u, f, e, o) { o || (o = n.create()); var s = i - t, h = u - r, c = e - f; return o[0] = 2 * f / s, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = 2 * f / h, o[6] = 0, o[7] = 0, o[8] = (i + t) / s, o[9] = (u + r) / h, o[10] = -(e + f) / c, o[11] = -1, o[12] = 0, o[13] = 0, o[14] = -(e * f * 2) / c, o[15] = 0, o }; n.perspective = function (t, i, r, u, f) { return t = r * Math.tan(t * Math.PI / 360), i = t * i, n.frustum(-i, i, -t, t, r, u, f) }; n.ortho = function (t, i, r, u, f, e, o) { o || (o = n.create()); var s = i - t, h = u - r, c = e - f; return o[0] = 2 / s, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = 2 / h, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = -2 / c, o[11] = 0, o[12] = -(t + i) / s, o[13] = -(u + r) / h, o[14] = -(e + f) / c, o[15] = 1, o }; n.lookAt = function (t, i, r, u) { var v, y, e, c, l, a, f; u || (u = n.create()); v = t[0]; y = t[1]; t = t[2]; var o = r[0], h = r[1], s = r[2]; return (r = i[1], e = i[2], v == i[0] && y == r && t == e) ? n.identity(u) : (r = v - i[0], e = y - i[1], i = t - i[2], f = 1 / Math.sqrt(r * r + e * e + i * i), r *= f, e *= f, i *= f, c = h * i - s * e, s = s * r - o * i, o = o * e - h * r, (f = Math.sqrt(c * c + s * s + o * o)) ? (f = 1 / f, c *= f, s *= f, o *= f) : o = s = c = 0, h = e * o - i * s, l = i * c - r * o, a = r * s - e * c, (f = Math.sqrt(h * h + l * l + a * a)) ? (f = 1 / f, h *= f, l *= f, a *= f) : a = l = h = 0, u[0] = c, u[1] = h, u[2] = r, u[3] = 0, u[4] = s, u[5] = l, u[6] = e, u[7] = 0, u[8] = o, u[9] = a, u[10] = i, u[11] = 0, u[12] = -(c * v + s * y + o * t), u[13] = -(h * v + l * y + a * t), u[14] = -(r * v + e * y + i * t), u[15] = 1, u) }; n.str = function (n) { return "[" + n[0] + ", " + n[1] + ", " + n[2] + ", " + n[3] + ", " + n[4] + ", " + n[5] + ", " + n[6] + ", " + n[7] + ", " + n[8] + ", " + n[9] + ", " + n[10] + ", " + n[11] + ", " + n[12] + ", " + n[13] + ", " + n[14] + ", " + n[15] + "]" }; i = {}; i.create = function (n) { var t = new u(4); return n && (t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3]), t }; i.set = function (n, t) { return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t }; i.calculateW = function (n, t) { var i = n[0], r = n[1], u = n[2]; return t && n != t ? (t[0] = i, t[1] = r, t[2] = u, t[3] = -Math.sqrt(Math.abs(1 - i * i - r * r - u * u)), t) : (n[3] = -Math.sqrt(Math.abs(1 - i * i - r * r - u * u)), n) }; i.inverse = function (n, t) { return t && n != t ? (t[0] = -n[0], t[1] = -n[1], t[2] = -n[2], t[3] = n[3], t) : (n[0] *= 1, n[1] *= 1, n[2] *= 1, n) }; i.length = function (n) { var t = n[0], i = n[1], r = n[2]; return n = n[3], Math.sqrt(t * t + i * i + r * r + n * n) }; i.normalize = function (n, t) { t || (t = n); var r = n[0], u = n[1], f = n[2], e = n[3], i = Math.sqrt(r * r + u * u + f * f + e * e); return 0 == i ? (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t) : (i = 1 / i, t[0] = r * i, t[1] = u * i, t[2] = f * i, t[3] = e * i, t) }; i.multiply = function (n, t, i) { i || (i = n); var r = n[0], u = n[1], f = n[2]; n = n[3]; var e = t[0], o = t[1], s = t[2]; return t = t[3], i[0] = r * t + n * e + u * s - f * o, i[1] = u * t + n * o + f * e - r * s, i[2] = f * t + n * s + r * o - u * e, i[3] = n * t - r * e - u * o - f * s, i }; i.multiplyVec3 = function (n, t, i) { var u, f; i || (i = t); var r = t[0], e = t[1], o = t[2]; t = n[0]; u = n[1]; f = n[2]; n = n[3]; var s = n * r + u * o - f * e, h = n * e + f * r - t * o, c = n * o + t * e - u * r; return r = -t * r - u * e - f * o, i[0] = s * n + r * -t + h * -f - c * -u, i[1] = h * n + r * -u + c * -t - s * -f, i[2] = c * n + r * -f + s * -u - h * -t, i }; i.toMat3 = function (n, t) { var c; t || (t = r.create()); var i = n[0], u = n[1], e = n[2], o = n[3], s = i + i, f = u + u, h = e + e, l = i * s, a = i * f; return i *= h, c = u * f, u *= h, e *= h, s = o * s, f = o * f, o *= h, t[0] = 1 - (c + e), t[1] = a - o, t[2] = i + f, t[3] = a + o, t[4] = 1 - (l + e), t[5] = u - s, t[6] = i - f, t[7] = u + s, t[8] = 1 - (l + c), t }; i.toMat4 = function (t, i) { var c; i || (i = n.create()); var r = t[0], u = t[1], e = t[2], o = t[3], s = r + r, f = u + u, h = e + e, l = r * s, a = r * f; return r *= h, c = u * f, u *= h, e *= h, s = o * s, f = o * f, o *= h, i[0] = 1 - (c + e), i[1] = a - o, i[2] = r + f, i[3] = 0, i[4] = a + o, i[5] = 1 - (l + e), i[6] = u - s, i[7] = 0, i[8] = r - f, i[9] = u + s, i[10] = 1 - (l + c), i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i }; i.slerp = function (n, t, i, r) { r || (r = n); var u = i; return n[0] * t[0] + n[1] * t[1] + n[2] * t[2] + n[3] * t[3] < 0 && (u = -1 * i), r[0] = 1 - i * n[0] + u * t[0], r[1] = 1 - i * n[1] + u * t[1], r[2] = 1 - i * n[2] + u * t[2], r[3] = 1 - i * n[3] + u * t[3], r }; i.str = function (n) { return "[" + n[0] + ", " + n[1] + ", " + n[2] + ", " + n[3] + "]" }; this.mat4 = n; this.quat4 = i; this.vec3 = t } } }); t.Matrix2D = n.extend({ statics: { DEG_TO_RAD: .017453292519943295 }, ctor: function (n, t, i, r, u, f) { return this.a = null == n ? 1 : n, this.b = t || 0, this.c = i || 0, this.d = null == r ? 1 : r, this.tx = u || 0, this.ty = f || 0, this }, identity: function () { return this.a = this.d = 1, this.b = this.c = this.tx = this.ty = 0, this }, appendTransform: function (n, i, r, u, f, e, o, s, h) { if (f % 360) var a = f * t.Matrix2D.DEG_TO_RAD, c = Math.cos(a), l = Math.sin(a); else c = 1, l = 0; return e || o ? (e *= t.Matrix2D.DEG_TO_RAD, o *= t.Matrix2D.DEG_TO_RAD, this.append(Math.cos(o), Math.sin(o), -Math.sin(e), Math.cos(e), n, i), this.append(c * r, l * r, -l * u, c * u, 0, 0)) : this.append(c * r, l * r, -l * u, c * u, n, i), (s || h) && (this.tx -= s * this.a + h * this.c, this.ty -= s * this.b + h * this.d), this }, append: function (n, t, i, r, u, f) { var e = this.a, o = this.b, s = this.c, h = this.d; return this.a = n * e + t * s, this.b = n * o + t * h, this.c = i * e + r * s, this.d = i * o + r * h, this.tx = u * e + f * s + this.tx, this.ty = u * o + f * h + this.ty, this }, reinitialize: function (n, t, i, r, u, f, e, o, s) { return this.initialize(n, t, i, r, u, f), this.alpha = e || 1, this.shadow = o, this.compositeOperation = s, this }, initialize: function (n, t, i, r, u, f) { return null != n && (this.a = n), this.b = t || 0, this.c = i || 0, null != r && (this.d = r), this.tx = u || 0, this.ty = f || 0, this } }); t.UID = n.extend({ statics: { _nextID: 0, get: function () { return this._nextID++ } } }); new i.Main }() }(Function("return this")())
    </script>
</body>
</html>